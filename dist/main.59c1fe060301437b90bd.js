/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@firebase/firestore/dist/lite/index.browser.esm2017.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/lite/index.browser.esm2017.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AggregateField\": () => (/* binding */ Tn),\n/* harmony export */   \"AggregateQuerySnapshot\": () => (/* binding */ An),\n/* harmony export */   \"Bytes\": () => (/* binding */ qn),\n/* harmony export */   \"CollectionReference\": () => (/* binding */ $n),\n/* harmony export */   \"DocumentReference\": () => (/* binding */ Pn),\n/* harmony export */   \"DocumentSnapshot\": () => (/* binding */ fr),\n/* harmony export */   \"FieldPath\": () => (/* binding */ On),\n/* harmony export */   \"FieldValue\": () => (/* binding */ Cn),\n/* harmony export */   \"Firestore\": () => (/* binding */ _n),\n/* harmony export */   \"FirestoreError\": () => (/* binding */ U),\n/* harmony export */   \"GeoPoint\": () => (/* binding */ Ln),\n/* harmony export */   \"Query\": () => (/* binding */ Vn),\n/* harmony export */   \"QueryCompositeFilterConstraint\": () => (/* binding */ Er),\n/* harmony export */   \"QueryConstraint\": () => (/* binding */ gr),\n/* harmony export */   \"QueryDocumentSnapshot\": () => (/* binding */ dr),\n/* harmony export */   \"QueryEndAtConstraint\": () => (/* binding */ xr),\n/* harmony export */   \"QueryFieldFilterConstraint\": () => (/* binding */ vr),\n/* harmony export */   \"QueryLimitConstraint\": () => (/* binding */ Pr),\n/* harmony export */   \"QueryOrderByConstraint\": () => (/* binding */ Ar),\n/* harmony export */   \"QuerySnapshot\": () => (/* binding */ wr),\n/* harmony export */   \"QueryStartAtConstraint\": () => (/* binding */ Nr),\n/* harmony export */   \"Timestamp\": () => (/* binding */ Vt),\n/* harmony export */   \"Transaction\": () => (/* binding */ fs),\n/* harmony export */   \"WriteBatch\": () => (/* binding */ rs),\n/* harmony export */   \"addDoc\": () => (/* binding */ Yr),\n/* harmony export */   \"aggregateQuerySnapshotEqual\": () => (/* binding */ Jr),\n/* harmony export */   \"and\": () => (/* binding */ Tr),\n/* harmony export */   \"arrayRemove\": () => (/* binding */ es),\n/* harmony export */   \"arrayUnion\": () => (/* binding */ ts),\n/* harmony export */   \"collection\": () => (/* binding */ Nn),\n/* harmony export */   \"collectionGroup\": () => (/* binding */ Dn),\n/* harmony export */   \"connectFirestoreEmulator\": () => (/* binding */ En),\n/* harmony export */   \"deleteDoc\": () => (/* binding */ Kr),\n/* harmony export */   \"deleteField\": () => (/* binding */ Xr),\n/* harmony export */   \"doc\": () => (/* binding */ Fn),\n/* harmony export */   \"documentId\": () => (/* binding */ kn),\n/* harmony export */   \"endAt\": () => (/* binding */ qr),\n/* harmony export */   \"endBefore\": () => (/* binding */ Sr),\n/* harmony export */   \"getCount\": () => (/* binding */ Hr),\n/* harmony export */   \"getDoc\": () => (/* binding */ Qr),\n/* harmony export */   \"getDocs\": () => (/* binding */ zr),\n/* harmony export */   \"getFirestore\": () => (/* binding */ bn),\n/* harmony export */   \"increment\": () => (/* binding */ ns),\n/* harmony export */   \"initializeFirestore\": () => (/* binding */ vn),\n/* harmony export */   \"limit\": () => (/* binding */ Vr),\n/* harmony export */   \"limitToLast\": () => (/* binding */ $r),\n/* harmony export */   \"or\": () => (/* binding */ Ir),\n/* harmony export */   \"orderBy\": () => (/* binding */ Rr),\n/* harmony export */   \"query\": () => (/* binding */ _r),\n/* harmony export */   \"queryEqual\": () => (/* binding */ Sn),\n/* harmony export */   \"refEqual\": () => (/* binding */ xn),\n/* harmony export */   \"runTransaction\": () => (/* binding */ ds),\n/* harmony export */   \"serverTimestamp\": () => (/* binding */ Zr),\n/* harmony export */   \"setDoc\": () => (/* binding */ Wr),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ p),\n/* harmony export */   \"snapshotEqual\": () => (/* binding */ mr),\n/* harmony export */   \"startAfter\": () => (/* binding */ Fr),\n/* harmony export */   \"startAt\": () => (/* binding */ Dr),\n/* harmony export */   \"terminate\": () => (/* binding */ In),\n/* harmony export */   \"updateDoc\": () => (/* binding */ Gr),\n/* harmony export */   \"where\": () => (/* binding */ br),\n/* harmony export */   \"writeBatch\": () => (/* binding */ is)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.esm2017.js\");\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e18) { throw _e18; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e19) { didErr = true; err = _e19; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nvar d = /*#__PURE__*/function () {\n  function d(t) {\n    _classCallCheck(this, d);\n    this.uid = t;\n  }\n  _createClass(d, [{\n    key: \"isAuthenticated\",\n    value: function isAuthenticated() {\n      return null != this.uid;\n    }\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n  }, {\n    key: \"toKey\",\n    value: function toKey() {\n      return this.isAuthenticated() ? \"uid:\" + this.uid : \"anonymous-user\";\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return t.uid === this.uid;\n    }\n  }]);\n  return d;\n}();\n/** A user with a null UID. */\nd.UNAUTHENTICATED = new d(null),\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\n// non-FirebaseAuth providers.\nd.GOOGLE_CREDENTIALS = new d(\"google-credentials-uid\"), d.FIRST_PARTY = new d(\"first-party-uid\"), d.MOCK_USER = new d(\"mock-user\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar w = \"9.15.0\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar m = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger(\"@firebase/firestore\");\n\n/**\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\n *\n * @param logLevel - The verbosity you set for activity and error logging. Can\n *   be any of the following values:\n *\n *   <ul>\n *     <li>`debug` for the most verbose logging level, primarily for\n *     debugging.</li>\n *     <li>`error` to log errors only.</li>\n *     <li><code>`silent` to turn off logging.</li>\n *   </ul>\n */\nfunction p(t) {\n  m.setLogLevel(t);\n}\nfunction y(t) {\n  if (m.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n    for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      e[_key - 1] = arguments[_key];\n    }\n    var n = e.map(v);\n    m.debug.apply(m, [\"Firestore (\".concat(w, \"): \").concat(t)].concat(_toConsumableArray(n)));\n  }\n}\nfunction g(t) {\n  if (m.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\n    for (var _len2 = arguments.length, e = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      e[_key2 - 1] = arguments[_key2];\n    }\n    var n = e.map(v);\n    m.error.apply(m, [\"Firestore (\".concat(w, \"): \").concat(t)].concat(_toConsumableArray(n)));\n  }\n}\n\n/**\n * @internal\n */\nfunction _(t) {\n  if (m.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\n    for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      e[_key3 - 1] = arguments[_key3];\n    }\n    var n = e.map(v);\n    m.warn.apply(m, [\"Firestore (\".concat(w, \"): \").concat(t)].concat(_toConsumableArray(n)));\n  }\n}\n\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction v(t) {\n  if (\"string\" == typeof t) return t;\n  try {\n    return e = t, JSON.stringify(e);\n  } catch (e) {\n    // Converting to JSON failed, just log the object directly\n    return t;\n  }\n  /**\n  * @license\n  * Copyright 2020 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n  /** Formats an object as a JSON string, suitable for logging. */\n  var e;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nfunction b() {\n  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Unexpected state\";\n  // Log the failure in addition to throw an exception, just in case the\n  // exception is swallowed.\n  var e = \"FIRESTORE (\".concat(w, \") INTERNAL ASSERTION FAILED: \") + t;\n  // NOTE: We don't use FirestoreError here because these are internal failures\n  // that cannot be handled by the user. (Also it would create a circular\n  // dependency between the error and assert modules which doesn't work.)\n  throw g(e), new Error(e);\n}\n\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n */\nfunction E(t, e) {\n  t || b();\n}\n\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nfunction I(t,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ne) {\n  return t;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar T = \"ok\",\n  A = \"cancelled\",\n  R = \"unknown\",\n  P = \"invalid-argument\",\n  V = \"deadline-exceeded\",\n  $ = \"not-found\",\n  N = \"already-exists\",\n  D = \"permission-denied\",\n  F = \"unauthenticated\",\n  x = \"resource-exhausted\",\n  S = \"failed-precondition\",\n  q = \"aborted\",\n  O = \"out-of-range\",\n  k = \"unimplemented\",\n  C = \"internal\",\n  L = \"unavailable\",\n  M = \"data-loss\";\n\n/** An error returned by a Firestore operation. */\nvar U = /*#__PURE__*/function (_FirebaseError) {\n  _inherits(U, _FirebaseError);\n  var _super = _createSuper(U);\n  /** @hideconstructor */\n  function U(\n  /**\n   * The backend error code associated with this error.\n   */\n  t,\n  /**\n   * A custom error description.\n   */\n  e) {\n    var _this;\n    _classCallCheck(this, U);\n    _this = _super.call(this, t, e), _this.code = t, _this.message = e,\n    // HACK: We write a toString property directly because Error is not a real\n    // class and so inheritance does not work correctly. We could alternatively\n    // do the same \"back-door inheritance\" trick that FirebaseError does.\n    _this.toString = function () {\n      return \"\".concat(_this.name, \": [code=\").concat(_this.code, \"]: \").concat(_this.message);\n    };\n    return _this;\n  }\n  return _createClass(U);\n}(_firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError);\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar j = /*#__PURE__*/_createClass(function j() {\n  var _this2 = this;\n  _classCallCheck(this, j);\n  this.promise = new Promise(function (t, e) {\n    _this2.resolve = t, _this2.reject = e;\n  });\n});\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar B = /*#__PURE__*/_createClass(function B(t, e) {\n  _classCallCheck(this, B);\n  this.user = e, this.type = \"OAuth\", this.headers = new Map(), this.headers.set(\"Authorization\", \"Bearer \".concat(t));\n});\n/**\n * A CredentialsProvider that always yields an empty token.\n * @internal\n */\nvar Q = /*#__PURE__*/function () {\n  function Q() {\n    _classCallCheck(this, Q);\n  }\n  _createClass(Q, [{\n    key: \"getToken\",\n    value: function getToken() {\n      return Promise.resolve(null);\n    }\n  }, {\n    key: \"invalidateToken\",\n    value: function invalidateToken() {}\n  }, {\n    key: \"start\",\n    value: function start(t, e) {\n      // Fire with initial user.\n      t.enqueueRetryable(function () {\n        return e(d.UNAUTHENTICATED);\n      });\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {}\n  }]);\n  return Q;\n}();\n/**\n * A CredentialsProvider that always returns a constant token. Used for\n * emulator token mocking.\n */\nvar z = /*#__PURE__*/function () {\n  function z(t) {\n    _classCallCheck(this, z);\n    this.token = t,\n    /**\n     * Stores the listener registered with setChangeListener()\n     * This isn't actually necessary since the UID never changes, but we use this\n     * to verify the listen contract is adhered to in tests.\n     */\n    this.changeListener = null;\n  }\n  _createClass(z, [{\n    key: \"getToken\",\n    value: function getToken() {\n      return Promise.resolve(this.token);\n    }\n  }, {\n    key: \"invalidateToken\",\n    value: function invalidateToken() {}\n  }, {\n    key: \"start\",\n    value: function start(t, e) {\n      var _this3 = this;\n      this.changeListener = e,\n      // Fire with initial user.\n      t.enqueueRetryable(function () {\n        return e(_this3.token.user);\n      });\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.changeListener = null;\n    }\n  }]);\n  return z;\n}();\n/** Credential provider for the Lite SDK. */\nvar W = /*#__PURE__*/function () {\n  function W(t) {\n    var _this4 = this;\n    _classCallCheck(this, W);\n    this.auth = null, t.onInit(function (t) {\n      _this4.auth = t;\n    });\n  }\n  _createClass(W, [{\n    key: \"getToken\",\n    value: function getToken() {\n      var _this5 = this;\n      return this.auth ? this.auth.getToken().then(function (t) {\n        return t ? (E(\"string\" == typeof t.accessToken), new B(t.accessToken, new d(_this5.auth.getUid()))) : null;\n      }) : Promise.resolve(null);\n    }\n  }, {\n    key: \"invalidateToken\",\n    value: function invalidateToken() {}\n  }, {\n    key: \"start\",\n    value: function start(t, e) {}\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {}\n  }]);\n  return W;\n}();\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nvar G = /*#__PURE__*/function () {\n  function G(t, e, n, r) {\n    _classCallCheck(this, G);\n    this.t = t, this.i = e, this.o = n, this.u = r, this.type = \"FirstParty\", this.user = d.FIRST_PARTY, this.h = new Map();\n  }\n  /** Gets an authorization token, using a provided factory function, or falling back to First Party GAPI. */\n  _createClass(G, [{\n    key: \"l\",\n    value: function l() {\n      return this.u ? this.u() : (\n      // Make sure this really is a Gapi client.\n      E(!(\"object\" != _typeof(this.t) || null === this.t || !this.t.auth || !this.t.auth.getAuthHeaderValueForFirstParty)), this.t.auth.getAuthHeaderValueForFirstParty([]));\n    }\n  }, {\n    key: \"headers\",\n    get: function get() {\n      this.h.set(\"X-Goog-AuthUser\", this.i);\n      // Use array notation to prevent minification\n      var t = this.l();\n      return t && this.h.set(\"Authorization\", t), this.o && this.h.set(\"X-Goog-Iam-Authorization-Token\", this.o), this.h;\n    }\n  }]);\n  return G;\n}();\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nvar K = /*#__PURE__*/function () {\n  function K(t, e, n, r) {\n    _classCallCheck(this, K);\n    this.t = t, this.i = e, this.o = n, this.u = r;\n  }\n  _createClass(K, [{\n    key: \"getToken\",\n    value: function getToken() {\n      return Promise.resolve(new G(this.t, this.i, this.o, this.u));\n    }\n  }, {\n    key: \"start\",\n    value: function start(t, e) {\n      // Fire with initial uid.\n      t.enqueueRetryable(function () {\n        return e(d.FIRST_PARTY);\n      });\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {}\n  }, {\n    key: \"invalidateToken\",\n    value: function invalidateToken() {}\n  }]);\n  return K;\n}();\nvar Y = /*#__PURE__*/_createClass(function Y(t) {\n  _classCallCheck(this, Y);\n  this.value = t, this.type = \"AppCheck\", this.headers = new Map(), t && t.length > 0 && this.headers.set(\"x-firebase-appcheck\", this.value);\n});\n/** AppCheck token provider for the Lite SDK. */\nvar H = /*#__PURE__*/function () {\n  function H(t) {\n    var _this6 = this;\n    _classCallCheck(this, H);\n    this.m = t, this.appCheck = null, t.onInit(function (t) {\n      _this6.appCheck = t;\n    });\n  }\n  _createClass(H, [{\n    key: \"getToken\",\n    value: function getToken() {\n      return this.appCheck ? this.appCheck.getToken().then(function (t) {\n        return t ? (E(\"string\" == typeof t.token), new Y(t.token)) : null;\n      }) : Promise.resolve(null);\n    }\n  }, {\n    key: \"invalidateToken\",\n    value: function invalidateToken() {}\n  }, {\n    key: \"start\",\n    value: function start(t, e) {}\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {}\n  }]);\n  return H;\n}();\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar J = /*#__PURE__*/_createClass(\n/**\n * Constructs a DatabaseInfo using the provided host, databaseId and\n * persistenceKey.\n *\n * @param databaseId - The database to use.\n * @param appId - The Firebase App Id.\n * @param persistenceKey - A unique identifier for this Firestore's local\n * storage (used in conjunction with the databaseId).\n * @param host - The Firestore backend host to connect to.\n * @param ssl - Whether to use SSL when connecting.\n * @param forceLongPolling - Whether to use the forceLongPolling option\n * when using WebChannel as the network transport.\n * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\n * option when using WebChannel as the network transport.\n * @param useFetchStreams Whether to use the Fetch API instead of\n * XMLHTTPRequest\n */\nfunction J(t, e, n, r, s, i, o, u) {\n  _classCallCheck(this, J);\n  this.databaseId = t, this.appId = e, this.persistenceKey = n, this.host = r, this.ssl = s, this.forceLongPolling = i, this.autoDetectLongPolling = o, this.useFetchStreams = u;\n});\n/** The default database name for a project. */\n/**\n * Represents the database ID a Firestore client is associated with.\n * @internal\n */\nvar X = /*#__PURE__*/function () {\n  function X(t, e) {\n    _classCallCheck(this, X);\n    this.projectId = t, this.database = e || \"(default)\";\n  }\n  _createClass(X, [{\n    key: \"isDefaultDatabase\",\n    get: function get() {\n      return \"(default)\" === this.database;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return t instanceof X && t.projectId === this.projectId && t.database === this.database;\n    }\n  }], [{\n    key: \"empty\",\n    value: function empty() {\n      return new X(\"\", \"\");\n    }\n  }]);\n  return X;\n}();\n/**\n * Path represents an ordered sequence of string segments.\n */\nvar Z = /*#__PURE__*/function () {\n  function Z(t, e, n) {\n    _classCallCheck(this, Z);\n    void 0 === e ? e = 0 : e > t.length && b(), void 0 === n ? n = t.length - e : n > t.length - e && b(), this.segments = t, this.offset = e, this.len = n;\n  }\n  _createClass(Z, [{\n    key: \"length\",\n    get: function get() {\n      return this.len;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return 0 === Z.comparator(this, t);\n    }\n  }, {\n    key: \"child\",\n    value: function child(t) {\n      var e = this.segments.slice(this.offset, this.limit());\n      return t instanceof Z ? t.forEach(function (t) {\n        e.push(t);\n      }) : e.push(t), this.construct(e);\n    }\n    /** The index of one past the last segment of the path. */\n  }, {\n    key: \"limit\",\n    value: function limit() {\n      return this.offset + this.length;\n    }\n  }, {\n    key: \"popFirst\",\n    value: function popFirst(t) {\n      return t = void 0 === t ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t);\n    }\n  }, {\n    key: \"popLast\",\n    value: function popLast() {\n      return this.construct(this.segments, this.offset, this.length - 1);\n    }\n  }, {\n    key: \"firstSegment\",\n    value: function firstSegment() {\n      return this.segments[this.offset];\n    }\n  }, {\n    key: \"lastSegment\",\n    value: function lastSegment() {\n      return this.get(this.length - 1);\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.segments[this.offset + t];\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return 0 === this.length;\n    }\n  }, {\n    key: \"isPrefixOf\",\n    value: function isPrefixOf(t) {\n      if (t.length < this.length) return !1;\n      for (var e = 0; e < this.length; e++) {\n        if (this.get(e) !== t.get(e)) return !1;\n      }\n      return !0;\n    }\n  }, {\n    key: \"isImmediateParentOf\",\n    value: function isImmediateParentOf(t) {\n      if (this.length + 1 !== t.length) return !1;\n      for (var e = 0; e < this.length; e++) {\n        if (this.get(e) !== t.get(e)) return !1;\n      }\n      return !0;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(t) {\n      for (var e = this.offset, n = this.limit(); e < n; e++) {\n        t(this.segments[e]);\n      }\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this.segments.slice(this.offset, this.limit());\n    }\n  }], [{\n    key: \"comparator\",\n    value: function comparator(t, e) {\n      var n = Math.min(t.length, e.length);\n      for (var r = 0; r < n; r++) {\n        var _n2 = t.get(r),\n          s = e.get(r);\n        if (_n2 < s) return -1;\n        if (_n2 > s) return 1;\n      }\n      return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;\n    }\n  }]);\n  return Z;\n}();\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n *\n * @internal\n */\nvar tt = /*#__PURE__*/function (_Z) {\n  _inherits(tt, _Z);\n  var _super2 = _createSuper(tt);\n  function tt() {\n    _classCallCheck(this, tt);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(tt, [{\n    key: \"construct\",\n    value: function construct(t, e, n) {\n      return new tt(t, e, n);\n    }\n  }, {\n    key: \"canonicalString\",\n    value: function canonicalString() {\n      // NOTE: The client is ignorant of any path segments containing escape\n      // sequences (e.g. __id123__) and just passes them through raw (they exist\n      // for legacy reasons and should not be used frequently).\n      return this.toArray().join(\"/\");\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.canonicalString();\n    }\n    /**\n     * Creates a resource path from the given slash-delimited string. If multiple\n     * arguments are provided, all components are combined. Leading and trailing\n     * slashes from all components are ignored.\n     */\n  }], [{\n    key: \"fromString\",\n    value: function fromString() {\n      // NOTE: The client is ignorant of any path segments containing escape\n      // sequences (e.g. __id123__) and just passes them through raw (they exist\n      // for legacy reasons and should not be used frequently).\n      var e = [];\n      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        t[_key4] = arguments[_key4];\n      }\n      for (var _i = 0, _t2 = t; _i < _t2.length; _i++) {\n        var n = _t2[_i];\n        if (n.indexOf(\"//\") >= 0) throw new U(P, \"Invalid segment (\".concat(n, \"). Paths must not contain // in them.\"));\n        // Strip leading and traling slashed.\n        e.push.apply(e, _toConsumableArray(n.split(\"/\").filter(function (t) {\n          return t.length > 0;\n        })));\n      }\n      return new tt(e);\n    }\n  }, {\n    key: \"emptyPath\",\n    value: function emptyPath() {\n      return new tt([]);\n    }\n  }]);\n  return tt;\n}(Z);\nvar et = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n/**\n * A dot-separated path for navigating sub-objects within a document.\n * @internal\n */\nvar nt = /*#__PURE__*/function (_Z2) {\n  _inherits(nt, _Z2);\n  var _super3 = _createSuper(nt);\n  function nt() {\n    _classCallCheck(this, nt);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(nt, [{\n    key: \"construct\",\n    value: function construct(t, e, n) {\n      return new nt(t, e, n);\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n  }, {\n    key: \"canonicalString\",\n    value: function canonicalString() {\n      return this.toArray().map(function (t) {\n        return t = t.replace(/\\\\/g, \"\\\\\\\\\").replace(/`/g, \"\\\\`\"), nt.isValidIdentifier(t) || (t = \"`\" + t + \"`\"), t;\n      }).join(\".\");\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.canonicalString();\n    }\n    /**\n     * Returns true if this field references the key of a document.\n     */\n  }, {\n    key: \"isKeyField\",\n    value: function isKeyField() {\n      return 1 === this.length && \"__name__\" === this.get(0);\n    }\n    /**\n     * The field designating the key of a document.\n     */\n  }], [{\n    key: \"isValidIdentifier\",\n    value: function isValidIdentifier(t) {\n      return et.test(t);\n    }\n  }, {\n    key: \"keyField\",\n    value: function keyField() {\n      return new nt([\"__name__\"]);\n    }\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n  }, {\n    key: \"fromServerFormat\",\n    value: function fromServerFormat(t) {\n      var e = [];\n      var n = \"\",\n        r = 0;\n      var s = function s() {\n        if (0 === n.length) throw new U(P, \"Invalid field path (\".concat(t, \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\"));\n        e.push(n), n = \"\";\n      };\n      var i = !1;\n      for (; r < t.length;) {\n        var _e2 = t[r];\n        if (\"\\\\\" === _e2) {\n          if (r + 1 === t.length) throw new U(P, \"Path has trailing escape character: \" + t);\n          var _e3 = t[r + 1];\n          if (\"\\\\\" !== _e3 && \".\" !== _e3 && \"`\" !== _e3) throw new U(P, \"Path has invalid escape sequence: \" + t);\n          n += _e3, r += 2;\n        } else \"`\" === _e2 ? (i = !i, r++) : \".\" !== _e2 || i ? (n += _e2, r++) : (s(), r++);\n      }\n      if (s(), i) throw new U(P, \"Unterminated ` in path: \" + t);\n      return new nt(e);\n    }\n  }, {\n    key: \"emptyPath\",\n    value: function emptyPath() {\n      return new nt([]);\n    }\n  }]);\n  return nt;\n}(Z);\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nvar rt = /*#__PURE__*/function () {\n  function rt(t) {\n    _classCallCheck(this, rt);\n    this.path = t;\n  }\n  _createClass(rt, [{\n    key: \"collectionGroup\",\n    get: function get() {\n      return this.path.popLast().lastSegment();\n    }\n    /** Returns true if the document is in the specified collectionId. */\n  }, {\n    key: \"hasCollectionId\",\n    value: function hasCollectionId(t) {\n      return this.path.length >= 2 && this.path.get(this.path.length - 2) === t;\n    }\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\n  }, {\n    key: \"getCollectionGroup\",\n    value: function getCollectionGroup() {\n      return this.path.get(this.path.length - 2);\n    }\n    /** Returns the fully qualified path to the parent collection. */\n  }, {\n    key: \"getCollectionPath\",\n    value: function getCollectionPath() {\n      return this.path.popLast();\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return null !== t && 0 === tt.comparator(this.path, t.path);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.path.toString();\n    }\n  }], [{\n    key: \"fromPath\",\n    value: function fromPath(t) {\n      return new rt(tt.fromString(t));\n    }\n  }, {\n    key: \"fromName\",\n    value: function fromName(t) {\n      return new rt(tt.fromString(t).popFirst(5));\n    }\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      return new rt(tt.emptyPath());\n    }\n  }, {\n    key: \"comparator\",\n    value: function comparator(t, e) {\n      return tt.comparator(t.path, e.path);\n    }\n  }, {\n    key: \"isDocumentKey\",\n    value: function isDocumentKey(t) {\n      return t.length % 2 == 0;\n    }\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param segments - The segments of the path to the document\n     * @returns A new instance of DocumentKey\n     */\n  }, {\n    key: \"fromSegments\",\n    value: function fromSegments(t) {\n      return new rt(new tt(t.slice()));\n    }\n  }]);\n  return rt;\n}();\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction st(t, e, n) {\n  if (!n) throw new U(P, \"Function \".concat(t, \"() cannot be called with an empty \").concat(e, \".\"));\n}\n\n/**\n * Validates that two boolean options are not set at the same time.\n * @internal\n */\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nfunction it(t) {\n  if (!rt.isDocumentKey(t)) throw new U(P, \"Invalid document reference. Document references must have an even number of segments, but \".concat(t, \" has \").concat(t.length, \".\"));\n}\n\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nfunction ot(t) {\n  if (rt.isDocumentKey(t)) throw new U(P, \"Invalid collection reference. Collection references must have an odd number of segments, but \".concat(t, \" has \").concat(t.length, \".\"));\n}\n\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\n/** Returns a string describing the type / value of the provided input. */\nfunction ut(t) {\n  if (void 0 === t) return \"undefined\";\n  if (null === t) return \"null\";\n  if (\"string\" == typeof t) return t.length > 20 && (t = \"\".concat(t.substring(0, 20), \"...\")), JSON.stringify(t);\n  if (\"number\" == typeof t || \"boolean\" == typeof t) return \"\" + t;\n  if (\"object\" == _typeof(t)) {\n    if (t instanceof Array) return \"an array\";\n    {\n      var e = /** try to get the constructor name for an object. */\n      function (t) {\n        if (t.constructor) return t.constructor.name;\n        return null;\n      }\n      /**\n      * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\n      * underlying instance. Throws if  `obj` is not an instance of `T`.\n      *\n      * This cast is used in the Lite and Full SDK to verify instance types for\n      * arguments passed to the public API.\n      * @internal\n      */(t);\n      return e ? \"a custom \".concat(e, \" object\") : \"an object\";\n    }\n  }\n  return \"function\" == typeof t ? \"a function\" : b();\n}\nfunction ct(t,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ne) {\n  if (\"_delegate\" in t && (\n  // Unwrap Compat types\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  t = t._delegate), !(t instanceof e)) {\n    if (e.name === t.constructor.name) throw new U(P, \"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?\");\n    {\n      var n = ut(t);\n      throw new U(P, \"Expected type '\".concat(e.name, \"', but it was: \").concat(n));\n    }\n  }\n  return t;\n}\nfunction at(t, e) {\n  if (e <= 0) throw new U(P, \"Function \".concat(t, \"() requires a positive number, but it was: \").concat(e, \".\"));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction ht(t) {\n  return null == t;\n}\n\n/** Returns whether the value represents -0. */\nfunction lt(t) {\n  // Detect if the value is -0.0. Based on polyfill from\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  return 0 === t && 1 / t == -1 / 0;\n}\n\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value - The value to test for being an integer and in the safe range\n */\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ft = {\n  BatchGetDocuments: \"batchGet\",\n  Commit: \"commit\",\n  RunQuery: \"runQuery\",\n  RunAggregationQuery: \"runAggregationQuery\"\n};\n\n/**\n * Maps RPC names to the corresponding REST endpoint name.\n *\n * We use array notation to avoid mangling.\n */\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers or change this into a const enum.\n */\nvar dt, wt;\n\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status - An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nfunction mt(t) {\n  if (void 0 === t) return g(\"RPC_ERROR\", \"HTTP error has no status\"), R;\n  // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n  // status codes but the mapping is not bijective. In each case of ambiguity\n  // this function chooses a primary error.\n\n  // [1]\n  // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n  switch (t) {\n    case 200:\n      // OK\n      return T;\n    case 400:\n      // Bad Request\n      return S;\n\n    // Other possibilities based on the forward mapping\n    // return Code.INVALID_ARGUMENT;\n    // return Code.OUT_OF_RANGE;\n    case 401:\n      // Unauthorized\n      return F;\n    case 403:\n      // Forbidden\n      return D;\n    case 404:\n      // Not Found\n      return $;\n    case 409:\n      // Conflict\n      return q;\n\n    // Other possibilities:\n    // return Code.ALREADY_EXISTS;\n    case 416:\n      // Range Not Satisfiable\n      return O;\n    case 429:\n      // Too Many Requests\n      return x;\n    case 499:\n      // Client Closed Request\n      return A;\n    case 500:\n      // Internal Server Error\n      return R;\n\n    // Other possibilities:\n    // return Code.INTERNAL;\n    // return Code.DATA_LOSS;\n    case 501:\n      // Unimplemented\n      return k;\n    case 503:\n      // Service Unavailable\n      return L;\n    case 504:\n      // Gateway Timeout\n      return V;\n    default:\n      return t >= 200 && t < 300 ? T : t >= 400 && t < 500 ? S : t >= 500 && t < 600 ? C : R;\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A Rest-based connection that relies on the native HTTP stack\n * (e.g. `fetch` or a polyfill).\n */\n(wt = dt || (dt = {}))[wt.OK = 0] = \"OK\", wt[wt.CANCELLED = 1] = \"CANCELLED\", wt[wt.UNKNOWN = 2] = \"UNKNOWN\", wt[wt.INVALID_ARGUMENT = 3] = \"INVALID_ARGUMENT\", wt[wt.DEADLINE_EXCEEDED = 4] = \"DEADLINE_EXCEEDED\", wt[wt.NOT_FOUND = 5] = \"NOT_FOUND\", wt[wt.ALREADY_EXISTS = 6] = \"ALREADY_EXISTS\", wt[wt.PERMISSION_DENIED = 7] = \"PERMISSION_DENIED\", wt[wt.UNAUTHENTICATED = 16] = \"UNAUTHENTICATED\", wt[wt.RESOURCE_EXHAUSTED = 8] = \"RESOURCE_EXHAUSTED\", wt[wt.FAILED_PRECONDITION = 9] = \"FAILED_PRECONDITION\", wt[wt.ABORTED = 10] = \"ABORTED\", wt[wt.OUT_OF_RANGE = 11] = \"OUT_OF_RANGE\", wt[wt.UNIMPLEMENTED = 12] = \"UNIMPLEMENTED\", wt[wt.INTERNAL = 13] = \"INTERNAL\", wt[wt.UNAVAILABLE = 14] = \"UNAVAILABLE\", wt[wt.DATA_LOSS = 15] = \"DATA_LOSS\";\nvar pt = /*#__PURE__*/function (_ref) {\n  _inherits(pt, _ref);\n  var _super4 = _createSuper(pt);\n  /**\n   * @param databaseInfo - The connection info.\n   * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.\n   */\n  function pt(t, e) {\n    var _this7;\n    _classCallCheck(this, pt);\n    _this7 = _super4.call(this, t), _this7.V = e;\n    return _this7;\n  }\n  _createClass(pt, [{\n    key: \"$\",\n    value: function $(t, e) {\n      throw new Error(\"Not supported by FetchConnection\");\n    }\n  }, {\n    key: \"R\",\n    value: function () {\n      var _R = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(t, e, n, r) {\n        var s, i, o, _e4, _t3, _e5;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                i = JSON.stringify(r);\n                _context.prev = 1;\n                _context.next = 4;\n                return this.V(e, {\n                  method: \"POST\",\n                  headers: n,\n                  body: i\n                });\n              case 4:\n                o = _context.sent;\n                _context.next = 11;\n                break;\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](1);\n                _e4 = _context.t0;\n                throw new U(mt(_e4.status), \"Request failed with error: \" + _e4.statusText);\n              case 11:\n                if (o.ok) {\n                  _context.next = 18;\n                  break;\n                }\n                _context.next = 14;\n                return o.json();\n              case 14:\n                _t3 = _context.sent;\n                Array.isArray(_t3) && (_t3 = _t3[0]);\n                _e5 = null === (s = null == _t3 ? void 0 : _t3.error) || void 0 === s ? void 0 : s.message;\n                throw new U(mt(o.status), \"Request failed with error: \".concat(null != _e5 ? _e5 : o.statusText));\n              case 18:\n                return _context.abrupt(\"return\", o.json());\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 7]]);\n      }));\n      function R(_x, _x2, _x3, _x4) {\n        return _R.apply(this, arguments);\n      }\n      return R;\n    }()\n  }]);\n  return pt;\n}(\n/*#__PURE__*/\n/**\n * Base class for all Rest-based connections to the backend (WebChannel and\n * HTTP).\n */\nfunction () {\n  function _class(t) {\n    _classCallCheck(this, _class);\n    this.databaseInfo = t, this.databaseId = t.databaseId;\n    var e = t.ssl ? \"https\" : \"http\";\n    this.p = e + \"://\" + t.host, this.g = \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database + \"/documents\";\n  }\n  _createClass(_class, [{\n    key: \"v\",\n    get: function get() {\n      // Both `invokeRPC()` and `invokeStreamingRPC()` use their `path` arguments to determine\n      // where to run the query, and expect the `request` to NOT specify the \"path\".\n      return !1;\n    }\n  }, {\n    key: \"I\",\n    value: function I(t, e, n, r, s) {\n      var i = this.T(t, e);\n      y(\"RestConnection\", \"Sending: \", i, n);\n      var o = {};\n      return this.A(o, r, s), this.R(t, i, o, n).then(function (t) {\n        return y(\"RestConnection\", \"Received: \", t), t;\n      }, function (e) {\n        throw _(\"RestConnection\", \"\".concat(t, \" failed with error: \"), e, \"url: \", i, \"request:\", n), e;\n      });\n    }\n  }, {\n    key: \"P\",\n    value: function P(t, e, n, r, s, i) {\n      // The REST API automatically aggregates all of the streamed results, so we\n      // can just use the normal invoke() method.\n      return this.I(t, e, n, r, s);\n    }\n    /**\n     * Modifies the headers for a request, adding any authorization token if\n     * present and any additional headers for the request.\n     */\n  }, {\n    key: \"A\",\n    value: function A(t, e, n) {\n      t[\"X-Goog-Api-Client\"] = \"gl-js/ fire/\" + w,\n      // Content-Type: text/plain will avoid preflight requests which might\n      // mess with CORS and redirects by proxies. If we add custom headers\n      // we will need to change this code to potentially use the $httpOverwrite\n      // parameter supported by ESF to avoid triggering preflight requests.\n      t[\"Content-Type\"] = \"text/plain\", this.databaseInfo.appId && (t[\"X-Firebase-GMPID\"] = this.databaseInfo.appId), e && e.headers.forEach(function (e, n) {\n        return t[n] = e;\n      }), n && n.headers.forEach(function (e, n) {\n        return t[n] = e;\n      });\n    }\n  }, {\n    key: \"T\",\n    value: function T(t, e) {\n      var n = ft[t];\n      return \"\".concat(this.p, \"/v1/\").concat(e, \":\").concat(n);\n    }\n  }]);\n  return _class;\n}());\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Initializes the HTTP connection for the REST API. */\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Generates `nBytes` of random bytes.\n *\n * If `nBytes < 0` , an error will be thrown.\n */\nfunction yt(t) {\n  // Polyfills for IE and WebWorker by using `self` and `msCrypto` when `crypto` is not available.\n  var e =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"undefined\" != typeof self && (self.crypto || self.msCrypto),\n    n = new Uint8Array(t);\n  if (e && \"function\" == typeof e.getRandomValues) e.getRandomValues(n);else\n    // Falls back to Math.random\n    for (var _e6 = 0; _e6 < t; _e6++) {\n      n[_e6] = Math.floor(256 * Math.random());\n    }\n  return n;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar gt = /*#__PURE__*/function () {\n  function gt() {\n    _classCallCheck(this, gt);\n  }\n  _createClass(gt, null, [{\n    key: \"N\",\n    value: function N() {\n      // Alphanumeric characters\n      var t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n        e = Math.floor(256 / t.length) * t.length;\n      // The largest byte value that is a multiple of `char.length`.\n      var n = \"\";\n      for (; n.length < 20;) {\n        var r = yt(40);\n        for (var s = 0; s < r.length; ++s) {\n          // Only accept values that are [0, maxMultiple), this ensures they can\n          // be evenly mapped to indices of `chars` via a modulo operation.\n          n.length < 20 && r[s] < e && (n += t.charAt(r[s] % t.length));\n        }\n      }\n      return n;\n    }\n  }]);\n  return gt;\n}();\nfunction _t(t, e) {\n  return t < e ? -1 : t > e ? 1 : 0;\n}\n\n/** Helper to compare arrays using isEqual(). */\nfunction vt(t, e, n) {\n  return t.length === e.length && t.every(function (t, r) {\n    return n(t, e[r]);\n  });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction bt(t) {\n  var e = 0;\n  for (var n in t) {\n    Object.prototype.hasOwnProperty.call(t, n) && e++;\n  }\n  return e;\n}\nfunction Et(t, e) {\n  for (var n in t) {\n    Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n * @internal\n */\nvar It = /*#__PURE__*/function (_Symbol$iterator) {\n  function It(t) {\n    _classCallCheck(this, It);\n    this.binaryString = t;\n  }\n  _createClass(It, [{\n    key: _Symbol$iterator,\n    value: function value() {\n      var _this8 = this;\n      var t = 0;\n      return {\n        next: function next() {\n          return t < _this8.binaryString.length ? {\n            value: _this8.binaryString.charCodeAt(t++),\n            done: !1\n          } : {\n            value: void 0,\n            done: !0\n          };\n        }\n      };\n    }\n  }, {\n    key: \"toBase64\",\n    value: function toBase64() {\n      return t = this.binaryString, btoa(t);\n      /** Converts a binary string to a Base64 encoded string. */\n      var t;\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      return function (t) {\n        var e = new Uint8Array(t.length);\n        for (var n = 0; n < t.length; n++) {\n          e[n] = t.charCodeAt(n);\n        }\n        return e;\n      }\n      /**\n      * @license\n      * Copyright 2020 Google LLC\n      *\n      * Licensed under the Apache License, Version 2.0 (the \"License\");\n      * you may not use this file except in compliance with the License.\n      * You may obtain a copy of the License at\n      *\n      *   http://www.apache.org/licenses/LICENSE-2.0\n      *\n      * Unless required by applicable law or agreed to in writing, software\n      * distributed under the License is distributed on an \"AS IS\" BASIS,\n      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      * See the License for the specific language governing permissions and\n      * limitations under the License.\n      */\n      // A RegExp matching ISO 8601 UTC timestamps with optional fraction.\n      (this.binaryString);\n    }\n  }, {\n    key: \"approximateByteSize\",\n    value: function approximateByteSize() {\n      return 2 * this.binaryString.length;\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(t) {\n      return _t(this.binaryString, t.binaryString);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this.binaryString === t.binaryString;\n    }\n  }], [{\n    key: \"fromBase64String\",\n    value: function fromBase64String(t) {\n      var e = atob(t);\n      return new It(e);\n    }\n  }, {\n    key: \"fromUint8Array\",\n    value: function fromUint8Array(t) {\n      // TODO(indexing); Remove the copy of the byte string here as this method\n      // is frequently called during indexing.\n      var e =\n      /**\n      * Helper function to convert an Uint8array to a binary string.\n      */\n      function (t) {\n        var e = \"\";\n        for (var n = 0; n < t.length; ++n) {\n          e += String.fromCharCode(t[n]);\n        }\n        return e;\n      }\n      /**\n      * Helper function to convert a binary string to an Uint8Array.\n      */(t);\n      return new It(e);\n    }\n  }]);\n  return It;\n}(Symbol.iterator);\nIt.EMPTY_BYTE_STRING = new It(\"\");\nvar Tt = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nfunction At(t) {\n  // The json interface (for the browser) will return an iso timestamp string,\n  // while the proto js library (for node) will return a\n  // google.protobuf.Timestamp instance.\n  if (E(!!t), \"string\" == typeof t) {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n    // Parse the nanos right out of the string.\n    var e = 0;\n    var n = Tt.exec(t);\n    if (E(!!n), n[1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      var _t4 = n[1];\n      _t4 = (_t4 + \"000000000\").substr(0, 9), e = Number(_t4);\n    }\n    // Parse the date to get the seconds.\n    var r = new Date(t);\n    return {\n      seconds: Math.floor(r.getTime() / 1e3),\n      nanos: e\n    };\n  }\n  return {\n    seconds: Rt(t.seconds),\n    nanos: Rt(t.nanos)\n  };\n}\n\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nfunction Rt(t) {\n  // TODO(bjornick): Handle int64 greater than 53 bits.\n  return \"number\" == typeof t ? t : \"string\" == typeof t ? Number(t) : 0;\n}\n\n/** Converts the possible Proto types for Blobs into a ByteString. */\nfunction Pt(t) {\n  return \"string\" == typeof t ? It.fromBase64String(t) : It.fromUint8Array(t);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\n/**\n * A `Timestamp` represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time.\n *\n * It is encoded using the Proleptic Gregorian Calendar which extends the\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\n * 9999-12-31T23:59:59.999999999Z.\n *\n * For examples and further specifications, refer to the\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\n */\nvar Vt = /*#__PURE__*/function () {\n  /**\n   * Creates a new timestamp.\n   *\n   * @param seconds - The number of seconds of UTC time since Unix epoch\n   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   *     9999-12-31T23:59:59Z inclusive.\n   * @param nanoseconds - The non-negative fractions of a second at nanosecond\n   *     resolution. Negative second values with fractions must still have\n   *     non-negative nanoseconds values that count forward in time. Must be\n   *     from 0 to 999,999,999 inclusive.\n   */\n  function Vt(\n  /**\n   * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n   */\n  t,\n  /**\n   * The fractions of a second at nanosecond resolution.*\n   */\n  e) {\n    _classCallCheck(this, Vt);\n    if (this.seconds = t, this.nanoseconds = e, e < 0) throw new U(P, \"Timestamp nanoseconds out of range: \" + e);\n    if (e >= 1e9) throw new U(P, \"Timestamp nanoseconds out of range: \" + e);\n    if (t < -62135596800) throw new U(P, \"Timestamp seconds out of range: \" + t);\n    // This will break in the year 10,000.\n    if (t >= 253402300800) throw new U(P, \"Timestamp seconds out of range: \" + t);\n  }\n  /**\n   * Creates a new timestamp with the current date, with millisecond precision.\n   *\n   * @returns a new timestamp representing the current date.\n   */\n  _createClass(Vt, [{\n    key: \"toDate\",\n    value:\n    /**\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\n     * causes a loss of precision since `Date` objects only support millisecond\n     * precision.\n     *\n     * @returns JavaScript `Date` object representing the same point in time as\n     *     this `Timestamp`, with millisecond precision.\n     */\n    function toDate() {\n      return new Date(this.toMillis());\n    }\n    /**\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\n     * epoch). This operation causes a loss of precision.\n     *\n     * @returns The point in time corresponding to this timestamp, represented as\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     */\n  }, {\n    key: \"toMillis\",\n    value: function toMillis() {\n      return 1e3 * this.seconds + this.nanoseconds / 1e6;\n    }\n  }, {\n    key: \"_compareTo\",\n    value: function _compareTo(t) {\n      return this.seconds === t.seconds ? _t(this.nanoseconds, t.nanoseconds) : _t(this.seconds, t.seconds);\n    }\n    /**\n     * Returns true if this `Timestamp` is equal to the provided one.\n     *\n     * @param other - The `Timestamp` to compare against.\n     * @returns true if this `Timestamp` is equal to the provided one.\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;\n    }\n    /** Returns a textual representation of this `Timestamp`. */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Timestamp(seconds=\" + this.seconds + \", nanoseconds=\" + this.nanoseconds + \")\";\n    }\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        seconds: this.seconds,\n        nanoseconds: this.nanoseconds\n      };\n    }\n    /**\n     * Converts this object to a primitive string, which allows `Timestamp` objects\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\n     */\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      // This method returns a string of the form <seconds>.<nanoseconds> where\n      // <seconds> is translated to have a non-negative value and both <seconds>\n      // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n      // Strings with this format then have a lexiographical ordering that matches\n      // the expected ordering. The <seconds> translation is done to avoid having\n      // a leading negative sign (i.e. a leading '-' character) in its string\n      // representation, which would affect its lexiographical ordering.\n      var t = this.seconds - -62135596800;\n      // Note: Up to 12 decimal digits are required to represent all valid\n      // 'seconds' values.\n      return String(t).padStart(12, \"0\") + \".\" + String(this.nanoseconds).padStart(9, \"0\");\n    }\n  }], [{\n    key: \"now\",\n    value: function now() {\n      return Vt.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @param date - The date to initialize the `Timestamp` from.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     date.\n     */\n  }, {\n    key: \"fromDate\",\n    value: function fromDate(t) {\n      return Vt.fromMillis(t.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @param milliseconds - Number of milliseconds since Unix epoch\n     *     1970-01-01T00:00:00Z.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     number of milliseconds.\n     */\n  }, {\n    key: \"fromMillis\",\n    value: function fromMillis(t) {\n      var e = Math.floor(t / 1e3),\n        n = Math.floor(1e6 * (t - 1e3 * e));\n      return new Vt(e, n);\n    }\n  }]);\n  return Vt;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   transform. They can only exist in the local view of a document. Therefore\n *   they do not need to be parsed or serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nfunction $t(t) {\n  var e, n;\n  return \"server_timestamp\" === (null === (n = ((null === (e = null == t ? void 0 : t.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue);\n}\n\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nfunction Nt(t) {\n  var e = t.mapValue.fields.__previous_value__;\n  return $t(e) ? Nt(e) : e;\n}\n\n/**\n * Returns the local time at which this timestamp was first set.\n */\nfunction Dt(t) {\n  var e = At(t.mapValue.fields.__local_write_time__.timestampValue);\n  return new Vt(e.seconds, e.nanos);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Ft = {\n  fields: {\n    __type__: {\n      stringValue: \"__max__\"\n    }\n  }\n};\n\n/** Extracts the backend's type order for the provided value. */\nfunction xt(t) {\n  return \"nullValue\" in t ? 0 /* TypeOrder.NullValue */ : \"booleanValue\" in t ? 1 /* TypeOrder.BooleanValue */ : \"integerValue\" in t || \"doubleValue\" in t ? 2 /* TypeOrder.NumberValue */ : \"timestampValue\" in t ? 3 /* TypeOrder.TimestampValue */ : \"stringValue\" in t ? 5 /* TypeOrder.StringValue */ : \"bytesValue\" in t ? 6 /* TypeOrder.BlobValue */ : \"referenceValue\" in t ? 7 /* TypeOrder.RefValue */ : \"geoPointValue\" in t ? 8 /* TypeOrder.GeoPointValue */ : \"arrayValue\" in t ? 9 /* TypeOrder.ArrayValue */ : \"mapValue\" in t ? $t(t) ? 4 /* TypeOrder.ServerTimestampValue */ : /** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\n  function (t) {\n    return \"__max__\" === (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue;\n  }\n  /**\n  * @license\n  * Copyright 2022 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n  /**\n  * Represents a bound of a query.\n  *\n  * The bound is specified with the given components representing a position and\n  * whether it's just before or just after the position (relative to whatever the\n  * query order is).\n  *\n  * The position represents a logical index position for a query. It's a prefix\n  * of values for the (potentially implicit) order by clauses of a query.\n  *\n  * Bound provides a function to determine whether a document comes before or\n  * after a bound. This is influenced by whether the position is just before or\n  * just after the provided values.\n  */(t) ? 9007199254740991 /* TypeOrder.MaxValue */ : 10 /* TypeOrder.ObjectValue */ : b();\n}\n\n/** Tests `left` and `right` for equality based on the backend semantics. */\nfunction St(t, e) {\n  if (t === e) return !0;\n  var n = xt(t);\n  if (n !== xt(e)) return !1;\n  switch (n) {\n    case 0 /* TypeOrder.NullValue */:\n    case 9007199254740991 /* TypeOrder.MaxValue */:\n      return !0;\n    case 1 /* TypeOrder.BooleanValue */:\n      return t.booleanValue === e.booleanValue;\n    case 4 /* TypeOrder.ServerTimestampValue */:\n      return Dt(t).isEqual(Dt(e));\n    case 3 /* TypeOrder.TimestampValue */:\n      return function (t, e) {\n        if (\"string\" == typeof t.timestampValue && \"string\" == typeof e.timestampValue && t.timestampValue.length === e.timestampValue.length)\n          // Use string equality for ISO 8601 timestamps\n          return t.timestampValue === e.timestampValue;\n        var n = At(t.timestampValue),\n          r = At(e.timestampValue);\n        return n.seconds === r.seconds && n.nanos === r.nanos;\n      }(t, e);\n    case 5 /* TypeOrder.StringValue */:\n      return t.stringValue === e.stringValue;\n    case 6 /* TypeOrder.BlobValue */:\n      return function (t, e) {\n        return Pt(t.bytesValue).isEqual(Pt(e.bytesValue));\n      }(t, e);\n    case 7 /* TypeOrder.RefValue */:\n      return t.referenceValue === e.referenceValue;\n    case 8 /* TypeOrder.GeoPointValue */:\n      return function (t, e) {\n        return Rt(t.geoPointValue.latitude) === Rt(e.geoPointValue.latitude) && Rt(t.geoPointValue.longitude) === Rt(e.geoPointValue.longitude);\n      }(t, e);\n    case 2 /* TypeOrder.NumberValue */:\n      return function (t, e) {\n        if (\"integerValue\" in t && \"integerValue\" in e) return Rt(t.integerValue) === Rt(e.integerValue);\n        if (\"doubleValue\" in t && \"doubleValue\" in e) {\n          var _n3 = Rt(t.doubleValue),\n            r = Rt(e.doubleValue);\n          return _n3 === r ? lt(_n3) === lt(r) : isNaN(_n3) && isNaN(r);\n        }\n        return !1;\n      }(t, e);\n    case 9 /* TypeOrder.ArrayValue */:\n      return vt(t.arrayValue.values || [], e.arrayValue.values || [], St);\n    case 10 /* TypeOrder.ObjectValue */:\n      return function (t, e) {\n        var n = t.mapValue.fields || {},\n          r = e.mapValue.fields || {};\n        if (bt(n) !== bt(r)) return !1;\n        for (var _t5 in n) {\n          if (n.hasOwnProperty(_t5) && (void 0 === r[_t5] || !St(n[_t5], r[_t5]))) return !1;\n        }\n        return !0;\n      }\n      /** Returns true if the ArrayValue contains the specified element. */(t, e);\n    default:\n      return b();\n  }\n}\nfunction qt(t, e) {\n  return void 0 !== (t.values || []).find(function (t) {\n    return St(t, e);\n  });\n}\nfunction Ot(t, e) {\n  if (t === e) return 0;\n  var n = xt(t),\n    r = xt(e);\n  if (n !== r) return _t(n, r);\n  switch (n) {\n    case 0 /* TypeOrder.NullValue */:\n    case 9007199254740991 /* TypeOrder.MaxValue */:\n      return 0;\n    case 1 /* TypeOrder.BooleanValue */:\n      return _t(t.booleanValue, e.booleanValue);\n    case 2 /* TypeOrder.NumberValue */:\n      return function (t, e) {\n        var n = Rt(t.integerValue || t.doubleValue),\n          r = Rt(e.integerValue || e.doubleValue);\n        return n < r ? -1 : n > r ? 1 : n === r ? 0 :\n        // one or both are NaN.\n        isNaN(n) ? isNaN(r) ? 0 : -1 : 1;\n      }(t, e);\n    case 3 /* TypeOrder.TimestampValue */:\n      return kt(t.timestampValue, e.timestampValue);\n    case 4 /* TypeOrder.ServerTimestampValue */:\n      return kt(Dt(t), Dt(e));\n    case 5 /* TypeOrder.StringValue */:\n      return _t(t.stringValue, e.stringValue);\n    case 6 /* TypeOrder.BlobValue */:\n      return function (t, e) {\n        var n = Pt(t),\n          r = Pt(e);\n        return n.compareTo(r);\n      }(t.bytesValue, e.bytesValue);\n    case 7 /* TypeOrder.RefValue */:\n      return function (t, e) {\n        var n = t.split(\"/\"),\n          r = e.split(\"/\");\n        for (var _t6 = 0; _t6 < n.length && _t6 < r.length; _t6++) {\n          var _e7 = _t(n[_t6], r[_t6]);\n          if (0 !== _e7) return _e7;\n        }\n        return _t(n.length, r.length);\n      }(t.referenceValue, e.referenceValue);\n    case 8 /* TypeOrder.GeoPointValue */:\n      return function (t, e) {\n        var n = _t(Rt(t.latitude), Rt(e.latitude));\n        if (0 !== n) return n;\n        return _t(Rt(t.longitude), Rt(e.longitude));\n      }(t.geoPointValue, e.geoPointValue);\n    case 9 /* TypeOrder.ArrayValue */:\n      return function (t, e) {\n        var n = t.values || [],\n          r = e.values || [];\n        for (var _t7 = 0; _t7 < n.length && _t7 < r.length; ++_t7) {\n          var _e8 = Ot(n[_t7], r[_t7]);\n          if (_e8) return _e8;\n        }\n        return _t(n.length, r.length);\n      }(t.arrayValue, e.arrayValue);\n    case 10 /* TypeOrder.ObjectValue */:\n      return function (t, e) {\n        if (t === Ft && e === Ft) return 0;\n        if (t === Ft) return 1;\n        if (e === Ft) return -1;\n        var n = t.fields || {},\n          r = Object.keys(n),\n          s = e.fields || {},\n          i = Object.keys(s);\n        // Even though MapValues are likely sorted correctly based on their insertion\n        // order (e.g. when received from the backend), local modifications can bring\n        // elements out of order. We need to re-sort the elements to ensure that\n        // canonical IDs are independent of insertion order.\n        r.sort(), i.sort();\n        for (var _t8 = 0; _t8 < r.length && _t8 < i.length; ++_t8) {\n          var _e9 = _t(r[_t8], i[_t8]);\n          if (0 !== _e9) return _e9;\n          var o = Ot(n[r[_t8]], s[i[_t8]]);\n          if (0 !== o) return o;\n        }\n        return _t(r.length, i.length);\n      }\n      /** Returns a reference value for the provided database and key. */(t.mapValue, e.mapValue);\n    default:\n      throw b();\n  }\n}\nfunction kt(t, e) {\n  if (\"string\" == typeof t && \"string\" == typeof e && t.length === e.length) return _t(t, e);\n  var n = At(t),\n    r = At(e),\n    s = _t(n.seconds, r.seconds);\n  return 0 !== s ? s : _t(n.nanos, r.nanos);\n}\nfunction Ct(t, e) {\n  return {\n    referenceValue: \"projects/\".concat(t.projectId, \"/databases/\").concat(t.database, \"/documents/\").concat(e.path.canonicalString())\n  };\n}\n\n/** Returns true if `value` is an ArrayValue. */\nfunction Lt(t) {\n  return !!t && \"arrayValue\" in t;\n}\n\n/** Returns true if `value` is a NullValue. */\nfunction Mt(t) {\n  return !!t && \"nullValue\" in t;\n}\n\n/** Returns true if `value` is NaN. */\nfunction Ut(t) {\n  return !!t && \"doubleValue\" in t && isNaN(Number(t.doubleValue));\n}\n\n/** Returns true if `value` is a MapValue. */\nfunction jt(t) {\n  return !!t && \"mapValue\" in t;\n}\n\n/** Creates a deep copy of `source`. */\nfunction Bt(t) {\n  if (t.geoPointValue) return {\n    geoPointValue: Object.assign({}, t.geoPointValue)\n  };\n  if (t.timestampValue && \"object\" == _typeof(t.timestampValue)) return {\n    timestampValue: Object.assign({}, t.timestampValue)\n  };\n  if (t.mapValue) {\n    var e = {\n      mapValue: {\n        fields: {}\n      }\n    };\n    return Et(t.mapValue.fields, function (t, n) {\n      return e.mapValue.fields[t] = Bt(n);\n    }), e;\n  }\n  if (t.arrayValue) {\n    var _e10 = {\n      arrayValue: {\n        values: []\n      }\n    };\n    for (var n = 0; n < (t.arrayValue.values || []).length; ++n) {\n      _e10.arrayValue.values[n] = Bt(t.arrayValue.values[n]);\n    }\n    return _e10;\n  }\n  return Object.assign({}, t);\n}\nvar Qt = /*#__PURE__*/_createClass(function Qt(t, e) {\n  _classCallCheck(this, Qt);\n  this.position = t, this.inclusive = e;\n});\nfunction zt(t, e) {\n  if (null === t) return null === e;\n  if (null === e) return !1;\n  if (t.inclusive !== e.inclusive || t.position.length !== e.position.length) return !1;\n  for (var n = 0; n < t.position.length; n++) {\n    if (!St(t.position[n], e.position[n])) return !1;\n  }\n  return !0;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Wt = /*#__PURE__*/_createClass(function Wt() {\n  _classCallCheck(this, Wt);\n});\nvar Gt = /*#__PURE__*/function (_Wt) {\n  _inherits(Gt, _Wt);\n  var _super5 = _createSuper(Gt);\n  function Gt(t, e, n) {\n    var _this9;\n    _classCallCheck(this, Gt);\n    _this9 = _super5.call(this), _this9.field = t, _this9.op = e, _this9.value = n;\n    return _this9;\n  }\n  /**\n   * Creates a filter based on the provided arguments.\n   */\n  _createClass(Gt, [{\n    key: \"matches\",\n    value: function matches(t) {\n      var e = t.data.field(this.field);\n      // Types do not have to match in NOT_EQUAL filters.\n      return \"!=\" /* Operator.NOT_EQUAL */ === this.op ? null !== e && this.matchesComparison(Ot(e, this.value)) : null !== e && xt(this.value) === xt(e) && this.matchesComparison(Ot(e, this.value));\n      // Only compare types with matching backend order (such as double and int).\n    }\n  }, {\n    key: \"matchesComparison\",\n    value: function matchesComparison(t) {\n      switch (this.op) {\n        case \"<\" /* Operator.LESS_THAN */:\n          return t < 0;\n        case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n          return t <= 0;\n        case \"==\" /* Operator.EQUAL */:\n          return 0 === t;\n        case \"!=\" /* Operator.NOT_EQUAL */:\n          return 0 !== t;\n        case \">\" /* Operator.GREATER_THAN */:\n          return t > 0;\n        case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n          return t >= 0;\n        default:\n          return b();\n      }\n    }\n  }, {\n    key: \"isInequality\",\n    value: function isInequality() {\n      return [\"<\" /* Operator.LESS_THAN */, \"<=\" /* Operator.LESS_THAN_OR_EQUAL */, \">\" /* Operator.GREATER_THAN */, \">=\" /* Operator.GREATER_THAN_OR_EQUAL */, \"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */].indexOf(this.op) >= 0;\n    }\n  }, {\n    key: \"getFlattenedFilters\",\n    value: function getFlattenedFilters() {\n      return [this];\n    }\n  }, {\n    key: \"getFilters\",\n    value: function getFilters() {\n      return [this];\n    }\n  }, {\n    key: \"getFirstInequalityField\",\n    value: function getFirstInequalityField() {\n      return this.isInequality() ? this.field : null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(t, e, n) {\n      return t.isKeyField() ? \"in\" /* Operator.IN */ === e || \"not-in\" /* Operator.NOT_IN */ === e ? this.createKeyFieldInFilter(t, e, n) : new Ht(t, e, n) : \"array-contains\" /* Operator.ARRAY_CONTAINS */ === e ? new te(t, n) : \"in\" /* Operator.IN */ === e ? new ee(t, n) : \"not-in\" /* Operator.NOT_IN */ === e ? new ne(t, n) : \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ === e ? new re(t, n) : new Gt(t, e, n);\n    }\n  }, {\n    key: \"createKeyFieldInFilter\",\n    value: function createKeyFieldInFilter(t, e, n) {\n      return \"in\" /* Operator.IN */ === e ? new Jt(t, n) : new Xt(t, n);\n    }\n  }]);\n  return Gt;\n}(Wt);\nvar Kt = /*#__PURE__*/function (_Wt2) {\n  _inherits(Kt, _Wt2);\n  var _super6 = _createSuper(Kt);\n  function Kt(t, e) {\n    var _this10;\n    _classCallCheck(this, Kt);\n    _this10 = _super6.call(this), _this10.filters = t, _this10.op = e, _this10.D = null;\n    return _this10;\n  }\n  /**\n   * Creates a filter based on the provided arguments.\n   */\n  _createClass(Kt, [{\n    key: \"matches\",\n    value: function matches(t) {\n      return \"and\" /* CompositeOperator.AND */ === this.op ? void 0 === this.filters.find(function (e) {\n        return !e.matches(t);\n      }) : void 0 !== this.filters.find(function (e) {\n        return e.matches(t);\n      });\n    }\n  }, {\n    key: \"getFlattenedFilters\",\n    value: function getFlattenedFilters() {\n      return null !== this.D || (this.D = this.filters.reduce(function (t, e) {\n        return t.concat(e.getFlattenedFilters());\n      }, [])), this.D;\n    }\n    // Returns a mutable copy of `this.filters`\n  }, {\n    key: \"getFilters\",\n    value: function getFilters() {\n      return Object.assign([], this.filters);\n    }\n  }, {\n    key: \"getFirstInequalityField\",\n    value: function getFirstInequalityField() {\n      var t = this.F(function (t) {\n        return t.isInequality();\n      });\n      return null !== t ? t.field : null;\n    }\n    // Performs a depth-first search to find and return the first FieldFilter in the composite filter\n    // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the\n    // predicate.\n  }, {\n    key: \"F\",\n    value: function F(t) {\n      var _iterator = _createForOfIteratorHelper(this.getFlattenedFilters()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var e = _step.value;\n          if (t(e)) return e;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(t, e) {\n      return new Kt(t, e);\n    }\n  }]);\n  return Kt;\n}(Wt);\nfunction Yt(t, e) {\n  return t instanceof Gt ? function (t, e) {\n    return e instanceof Gt && t.op === e.op && t.field.isEqual(e.field) && St(t.value, e.value);\n  }(t, e) : t instanceof Kt ? function (t, e) {\n    if (e instanceof Kt && t.op === e.op && t.filters.length === e.filters.length) {\n      return t.filters.reduce(function (t, n, r) {\n        return t && Yt(n, e.filters[r]);\n      }, !0);\n    }\n    return !1;\n  }\n  /** Filter that matches on key fields (i.e. '__name__'). */(t, e) : void b();\n}\nvar Ht = /*#__PURE__*/function (_Gt) {\n  _inherits(Ht, _Gt);\n  var _super7 = _createSuper(Ht);\n  function Ht(t, e, n) {\n    var _this11;\n    _classCallCheck(this, Ht);\n    _this11 = _super7.call(this, t, e, n), _this11.key = rt.fromName(n.referenceValue);\n    return _this11;\n  }\n  _createClass(Ht, [{\n    key: \"matches\",\n    value: function matches(t) {\n      var e = rt.comparator(t.key, this.key);\n      return this.matchesComparison(e);\n    }\n  }]);\n  return Ht;\n}(Gt);\n/** Filter that matches on key fields within an array. */\nvar Jt = /*#__PURE__*/function (_Gt2) {\n  _inherits(Jt, _Gt2);\n  var _super8 = _createSuper(Jt);\n  function Jt(t, e) {\n    var _this12;\n    _classCallCheck(this, Jt);\n    _this12 = _super8.call(this, t, \"in\" /* Operator.IN */, e), _this12.keys = Zt(\"in\" /* Operator.IN */, e);\n    return _this12;\n  }\n  _createClass(Jt, [{\n    key: \"matches\",\n    value: function matches(t) {\n      return this.keys.some(function (e) {\n        return e.isEqual(t.key);\n      });\n    }\n  }]);\n  return Jt;\n}(Gt);\n/** Filter that matches on key fields not present within an array. */\nvar Xt = /*#__PURE__*/function (_Gt3) {\n  _inherits(Xt, _Gt3);\n  var _super9 = _createSuper(Xt);\n  function Xt(t, e) {\n    var _this13;\n    _classCallCheck(this, Xt);\n    _this13 = _super9.call(this, t, \"not-in\" /* Operator.NOT_IN */, e), _this13.keys = Zt(\"not-in\" /* Operator.NOT_IN */, e);\n    return _this13;\n  }\n  _createClass(Xt, [{\n    key: \"matches\",\n    value: function matches(t) {\n      return !this.keys.some(function (e) {\n        return e.isEqual(t.key);\n      });\n    }\n  }]);\n  return Xt;\n}(Gt);\nfunction Zt(t, e) {\n  var n;\n  return ((null === (n = e.arrayValue) || void 0 === n ? void 0 : n.values) || []).map(function (t) {\n    return rt.fromName(t.referenceValue);\n  });\n}\n\n/** A Filter that implements the array-contains operator. */\nvar te = /*#__PURE__*/function (_Gt4) {\n  _inherits(te, _Gt4);\n  var _super10 = _createSuper(te);\n  function te(t, e) {\n    _classCallCheck(this, te);\n    return _super10.call(this, t, \"array-contains\" /* Operator.ARRAY_CONTAINS */, e);\n  }\n  _createClass(te, [{\n    key: \"matches\",\n    value: function matches(t) {\n      var e = t.data.field(this.field);\n      return Lt(e) && qt(e.arrayValue, this.value);\n    }\n  }]);\n  return te;\n}(Gt);\n/** A Filter that implements the IN operator. */\nvar ee = /*#__PURE__*/function (_Gt5) {\n  _inherits(ee, _Gt5);\n  var _super11 = _createSuper(ee);\n  function ee(t, e) {\n    _classCallCheck(this, ee);\n    return _super11.call(this, t, \"in\" /* Operator.IN */, e);\n  }\n  _createClass(ee, [{\n    key: \"matches\",\n    value: function matches(t) {\n      var e = t.data.field(this.field);\n      return null !== e && qt(this.value.arrayValue, e);\n    }\n  }]);\n  return ee;\n}(Gt);\n/** A Filter that implements the not-in operator. */\nvar ne = /*#__PURE__*/function (_Gt6) {\n  _inherits(ne, _Gt6);\n  var _super12 = _createSuper(ne);\n  function ne(t, e) {\n    _classCallCheck(this, ne);\n    return _super12.call(this, t, \"not-in\" /* Operator.NOT_IN */, e);\n  }\n  _createClass(ne, [{\n    key: \"matches\",\n    value: function matches(t) {\n      if (qt(this.value.arrayValue, {\n        nullValue: \"NULL_VALUE\"\n      })) return !1;\n      var e = t.data.field(this.field);\n      return null !== e && !qt(this.value.arrayValue, e);\n    }\n  }]);\n  return ne;\n}(Gt);\n/** A Filter that implements the array-contains-any operator. */\nvar re = /*#__PURE__*/function (_Gt7) {\n  _inherits(re, _Gt7);\n  var _super13 = _createSuper(re);\n  function re(t, e) {\n    _classCallCheck(this, re);\n    return _super13.call(this, t, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, e);\n  }\n  _createClass(re, [{\n    key: \"matches\",\n    value: function matches(t) {\n      var _this14 = this;\n      var e = t.data.field(this.field);\n      return !(!Lt(e) || !e.arrayValue.values) && e.arrayValue.values.some(function (t) {\n        return qt(_this14.value.arrayValue, t);\n      });\n    }\n  }]);\n  return re;\n}(Gt);\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nvar se = /*#__PURE__*/_createClass(function se(t) {\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"asc\";\n  _classCallCheck(this, se);\n  this.field = t, this.dir = e;\n});\nfunction ie(t, e) {\n  return t.dir === e.dir && t.field.isEqual(e.field);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nvar oe = /*#__PURE__*/function () {\n  function oe(t) {\n    _classCallCheck(this, oe);\n    this.timestamp = t;\n  }\n  _createClass(oe, [{\n    key: \"compareTo\",\n    value: function compareTo(t) {\n      return this.timestamp._compareTo(t.timestamp);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this.timestamp.isEqual(t.timestamp);\n    }\n    /** Returns a number representation of the version for use in spec tests. */\n  }, {\n    key: \"toMicroseconds\",\n    value: function toMicroseconds() {\n      // Convert to microseconds.\n      return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"SnapshotVersion(\" + this.timestamp.toString() + \")\";\n    }\n  }, {\n    key: \"toTimestamp\",\n    value: function toTimestamp() {\n      return this.timestamp;\n    }\n  }], [{\n    key: \"fromTimestamp\",\n    value: function fromTimestamp(t) {\n      return new oe(t);\n    }\n  }, {\n    key: \"min\",\n    value: function min() {\n      return new oe(new Vt(0, 0));\n    }\n  }, {\n    key: \"max\",\n    value: function max() {\n      return new oe(new Vt(253402300799, 999999999));\n    }\n  }]);\n  return oe;\n}();\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nvar ue = /*#__PURE__*/function () {\n  function ue(t, e) {\n    _classCallCheck(this, ue);\n    this.comparator = t, this.root = e || ae.EMPTY;\n  }\n  // Returns a copy of the map, with the specified key/value added or replaced.\n  _createClass(ue, [{\n    key: \"insert\",\n    value: function insert(t, e) {\n      return new ue(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, ae.BLACK, null, null));\n    }\n    // Returns a copy of the map, with the specified key removed.\n  }, {\n    key: \"remove\",\n    value: function remove(t) {\n      return new ue(this.comparator, this.root.remove(t, this.comparator).copy(null, null, ae.BLACK, null, null));\n    }\n    // Returns the value of the node with the given key, or null.\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      var e = this.root;\n      for (; !e.isEmpty();) {\n        var n = this.comparator(t, e.key);\n        if (0 === n) return e.value;\n        n < 0 ? e = e.left : n > 0 && (e = e.right);\n      }\n      return null;\n    }\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(t) {\n      // Number of nodes that were pruned when descending right\n      var e = 0,\n        n = this.root;\n      for (; !n.isEmpty();) {\n        var r = this.comparator(t, n.key);\n        if (0 === r) return e + n.left.size;\n        r < 0 ? n = n.left : (\n        // Count all nodes left of the node plus the node itself\n        e += n.left.size + 1, n = n.right);\n      }\n      // Node not found\n      return -1;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.root.isEmpty();\n    }\n    // Returns the total number of nodes in the map.\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.root.size;\n    }\n    // Returns the minimum key in the map.\n  }, {\n    key: \"minKey\",\n    value: function minKey() {\n      return this.root.minKey();\n    }\n    // Returns the maximum key in the map.\n  }, {\n    key: \"maxKey\",\n    value: function maxKey() {\n      return this.root.maxKey();\n    }\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n  }, {\n    key: \"inorderTraversal\",\n    value: function inorderTraversal(t) {\n      return this.root.inorderTraversal(t);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(t) {\n      this.inorderTraversal(function (e, n) {\n        return t(e, n), !1;\n      });\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var t = [];\n      return this.inorderTraversal(function (e, n) {\n        return t.push(\"\".concat(e, \":\").concat(n)), !1;\n      }), \"{\".concat(t.join(\", \"), \"}\");\n    }\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n  }, {\n    key: \"reverseTraversal\",\n    value: function reverseTraversal(t) {\n      return this.root.reverseTraversal(t);\n    }\n    // Returns an iterator over the SortedMap.\n  }, {\n    key: \"getIterator\",\n    value: function getIterator() {\n      return new ce(this.root, null, this.comparator, !1);\n    }\n  }, {\n    key: \"getIteratorFrom\",\n    value: function getIteratorFrom(t) {\n      return new ce(this.root, t, this.comparator, !1);\n    }\n  }, {\n    key: \"getReverseIterator\",\n    value: function getReverseIterator() {\n      return new ce(this.root, null, this.comparator, !0);\n    }\n  }, {\n    key: \"getReverseIteratorFrom\",\n    value: function getReverseIteratorFrom(t) {\n      return new ce(this.root, t, this.comparator, !0);\n    }\n  }]);\n  return ue;\n}(); // end SortedMap\n// An iterator over an LLRBNode.\nvar ce = /*#__PURE__*/function () {\n  function ce(t, e, n, r) {\n    _classCallCheck(this, ce);\n    this.isReverse = r, this.nodeStack = [];\n    var s = 1;\n    for (; !t.isEmpty();) {\n      if (s = e ? n(t.key, e) : 1,\n      // flip the comparison if we're going in reverse\n      e && r && (s *= -1), s < 0)\n        // This node is less than our start key. ignore it\n        t = this.isReverse ? t.left : t.right;else {\n        if (0 === s) {\n          // This node is exactly equal to our start key. Push it on the stack,\n          // but stop iterating;\n          this.nodeStack.push(t);\n          break;\n        }\n        // This node is greater than our start key, add it to the stack and move\n        // to the next one\n        this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;\n      }\n    }\n  }\n  _createClass(ce, [{\n    key: \"getNext\",\n    value: function getNext() {\n      var t = this.nodeStack.pop();\n      var e = {\n        key: t.key,\n        value: t.value\n      };\n      if (this.isReverse) for (t = t.left; !t.isEmpty();) {\n        this.nodeStack.push(t), t = t.right;\n      } else for (t = t.right; !t.isEmpty();) {\n        this.nodeStack.push(t), t = t.left;\n      }\n      return e;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      return this.nodeStack.length > 0;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      if (0 === this.nodeStack.length) return null;\n      var t = this.nodeStack[this.nodeStack.length - 1];\n      return {\n        key: t.key,\n        value: t.value\n      };\n    }\n  }]);\n  return ce;\n}(); // end SortedMapIterator\n// Represents a node in a Left-leaning Red-Black tree.\nvar ae = /*#__PURE__*/function () {\n  function ae(t, e, n, r, s) {\n    _classCallCheck(this, ae);\n    this.key = t, this.value = e, this.color = null != n ? n : ae.RED, this.left = null != r ? r : ae.EMPTY, this.right = null != s ? s : ae.EMPTY, this.size = this.left.size + 1 + this.right.size;\n  }\n  // Returns a copy of the current node, optionally replacing pieces of it.\n  _createClass(ae, [{\n    key: \"copy\",\n    value: function copy(t, e, n, r, s) {\n      return new ae(null != t ? t : this.key, null != e ? e : this.value, null != n ? n : this.color, null != r ? r : this.left, null != s ? s : this.right);\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return !1;\n    }\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n  }, {\n    key: \"inorderTraversal\",\n    value: function inorderTraversal(t) {\n      return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);\n    }\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n  }, {\n    key: \"reverseTraversal\",\n    value: function reverseTraversal(t) {\n      return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);\n    }\n    // Returns the minimum node in the tree.\n  }, {\n    key: \"min\",\n    value: function min() {\n      return this.left.isEmpty() ? this : this.left.min();\n    }\n    // Returns the maximum key in the tree.\n  }, {\n    key: \"minKey\",\n    value: function minKey() {\n      return this.min().key;\n    }\n    // Returns the maximum key in the tree.\n  }, {\n    key: \"maxKey\",\n    value: function maxKey() {\n      return this.right.isEmpty() ? this.key : this.right.maxKey();\n    }\n    // Returns new tree, with the key/value added.\n  }, {\n    key: \"insert\",\n    value: function insert(t, e, n) {\n      var r = this;\n      var s = n(t, r.key);\n      return r = s < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : 0 === s ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n)), r.fixUp();\n    }\n  }, {\n    key: \"removeMin\",\n    value: function removeMin() {\n      if (this.left.isEmpty()) return ae.EMPTY;\n      var t = this;\n      return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp();\n    }\n    // Returns new tree, with the specified item removed.\n  }, {\n    key: \"remove\",\n    value: function remove(t, e) {\n      var n,\n        r = this;\n      if (e(t, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);else {\n        if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === e(t, r.key)) {\n          if (r.right.isEmpty()) return ae.EMPTY;\n          n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());\n        }\n        r = r.copy(null, null, null, null, r.right.remove(t, e));\n      }\n      return r.fixUp();\n    }\n  }, {\n    key: \"isRed\",\n    value: function isRed() {\n      return this.color;\n    }\n    // Returns new tree after performing any needed rotations.\n  }, {\n    key: \"fixUp\",\n    value: function fixUp() {\n      var t = this;\n      return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;\n    }\n  }, {\n    key: \"moveRedLeft\",\n    value: function moveRedLeft() {\n      var t = this.colorFlip();\n      return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t;\n    }\n  }, {\n    key: \"moveRedRight\",\n    value: function moveRedRight() {\n      var t = this.colorFlip();\n      return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t;\n    }\n  }, {\n    key: \"rotateLeft\",\n    value: function rotateLeft() {\n      var t = this.copy(null, null, ae.RED, null, this.right.left);\n      return this.right.copy(null, null, this.color, t, null);\n    }\n  }, {\n    key: \"rotateRight\",\n    value: function rotateRight() {\n      var t = this.copy(null, null, ae.RED, this.left.right, null);\n      return this.left.copy(null, null, this.color, null, t);\n    }\n  }, {\n    key: \"colorFlip\",\n    value: function colorFlip() {\n      var t = this.left.copy(null, null, !this.left.color, null, null),\n        e = this.right.copy(null, null, !this.right.color, null, null);\n      return this.copy(null, null, !this.color, t, e);\n    }\n    // For testing.\n  }, {\n    key: \"checkMaxDepth\",\n    value: function checkMaxDepth() {\n      var t = this.check();\n      return Math.pow(2, t) <= this.size + 1;\n    }\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n  }, {\n    key: \"check\",\n    value: function check() {\n      if (this.isRed() && this.left.isRed()) throw b();\n      if (this.right.isRed()) throw b();\n      var t = this.left.check();\n      if (t !== this.right.check()) throw b();\n      return t + (this.isRed() ? 0 : 1);\n    }\n  }]);\n  return ae;\n}(); // end LLRBNode\n// Empty node is shared between all LLRB trees.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nae.EMPTY = null, ae.RED = !0, ae.BLACK = !1;\n\n// end LLRBEmptyNode\nae.EMPTY = new (\n/*#__PURE__*/\n// Represents an empty node (a leaf node in the Red-Black Tree).\nfunction () {\n  function _class2() {\n    _classCallCheck(this, _class2);\n    this.size = 0;\n  }\n  _createClass(_class2, [{\n    key: \"key\",\n    get: function get() {\n      throw b();\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      throw b();\n    }\n  }, {\n    key: \"color\",\n    get: function get() {\n      throw b();\n    }\n  }, {\n    key: \"left\",\n    get: function get() {\n      throw b();\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      throw b();\n    }\n    // Returns a copy of the current node.\n  }, {\n    key: \"copy\",\n    value: function copy(t, e, n, r, s) {\n      return this;\n    }\n    // Returns a copy of the tree, with the specified key/value added.\n  }, {\n    key: \"insert\",\n    value: function insert(t, e, n) {\n      return new ae(t, e);\n    }\n    // Returns a copy of the tree, with the specified key removed.\n  }, {\n    key: \"remove\",\n    value: function remove(t, e) {\n      return this;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return !0;\n    }\n  }, {\n    key: \"inorderTraversal\",\n    value: function inorderTraversal(t) {\n      return !1;\n    }\n  }, {\n    key: \"reverseTraversal\",\n    value: function reverseTraversal(t) {\n      return !1;\n    }\n  }, {\n    key: \"minKey\",\n    value: function minKey() {\n      return null;\n    }\n  }, {\n    key: \"maxKey\",\n    value: function maxKey() {\n      return null;\n    }\n  }, {\n    key: \"isRed\",\n    value: function isRed() {\n      return !1;\n    }\n    // For testing.\n  }, {\n    key: \"checkMaxDepth\",\n    value: function checkMaxDepth() {\n      return !0;\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      return 0;\n    }\n  }]);\n  return _class2;\n}())();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nvar he = /*#__PURE__*/function () {\n  function he(t) {\n    _classCallCheck(this, he);\n    this.comparator = t, this.data = new ue(this.comparator);\n  }\n  _createClass(he, [{\n    key: \"has\",\n    value: function has(t) {\n      return null !== this.data.get(t);\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.data.minKey();\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.data.maxKey();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.data.size;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(t) {\n      return this.data.indexOf(t);\n    }\n    /** Iterates elements in order defined by \"comparator\" */\n  }, {\n    key: \"forEach\",\n    value: function forEach(t) {\n      this.data.inorderTraversal(function (e, n) {\n        return t(e), !1;\n      });\n    }\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\n  }, {\n    key: \"forEachInRange\",\n    value: function forEachInRange(t, e) {\n      var n = this.data.getIteratorFrom(t[0]);\n      for (; n.hasNext();) {\n        var r = n.getNext();\n        if (this.comparator(r.key, t[1]) >= 0) return;\n        e(r.key);\n      }\n    }\n    /**\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\n     */\n  }, {\n    key: \"forEachWhile\",\n    value: function forEachWhile(t, e) {\n      var n;\n      for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext();) {\n        if (!t(n.getNext().key)) return;\n      }\n    }\n    /** Finds the least element greater than or equal to `elem`. */\n  }, {\n    key: \"firstAfterOrEqual\",\n    value: function firstAfterOrEqual(t) {\n      var e = this.data.getIteratorFrom(t);\n      return e.hasNext() ? e.getNext().key : null;\n    }\n  }, {\n    key: \"getIterator\",\n    value: function getIterator() {\n      return new le(this.data.getIterator());\n    }\n  }, {\n    key: \"getIteratorFrom\",\n    value: function getIteratorFrom(t) {\n      return new le(this.data.getIteratorFrom(t));\n    }\n    /** Inserts or updates an element */\n  }, {\n    key: \"add\",\n    value: function add(t) {\n      return this.copy(this.data.remove(t).insert(t, !0));\n    }\n    /** Deletes an element */\n  }, {\n    key: \"delete\",\n    value: function _delete(t) {\n      return this.has(t) ? this.copy(this.data.remove(t)) : this;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.data.isEmpty();\n    }\n  }, {\n    key: \"unionWith\",\n    value: function unionWith(t) {\n      var e = this;\n      // Make sure `result` always refers to the larger one of the two sets.\n      return e.size < t.size && (e = t, t = this), t.forEach(function (t) {\n        e = e.add(t);\n      }), e;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      if (!(t instanceof he)) return !1;\n      if (this.size !== t.size) return !1;\n      var e = this.data.getIterator(),\n        n = t.data.getIterator();\n      for (; e.hasNext();) {\n        var _t9 = e.getNext().key,\n          r = n.getNext().key;\n        if (0 !== this.comparator(_t9, r)) return !1;\n      }\n      return !0;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var t = [];\n      return this.forEach(function (e) {\n        t.push(e);\n      }), t;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var t = [];\n      return this.forEach(function (e) {\n        return t.push(e);\n      }), \"SortedSet(\" + t.toString() + \")\";\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(t) {\n      var e = new he(this.comparator);\n      return e.data = t, e;\n    }\n  }]);\n  return he;\n}();\nvar le = /*#__PURE__*/function () {\n  function le(t) {\n    _classCallCheck(this, le);\n    this.iter = t;\n  }\n  _createClass(le, [{\n    key: \"getNext\",\n    value: function getNext() {\n      return this.iter.getNext().key;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      return this.iter.hasNext();\n    }\n  }]);\n  return le;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nvar fe = /*#__PURE__*/function () {\n  function fe(t) {\n    _classCallCheck(this, fe);\n    this.fields = t,\n    // TODO(dimond): validation of FieldMask\n    // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n    t.sort(nt.comparator);\n  }\n  _createClass(fe, [{\n    key: \"unionWith\",\n    value:\n    /**\n     * Returns a new FieldMask object that is the result of adding all the given\n     * fields paths to this field mask.\n     */\n    function unionWith(t) {\n      var e = new he(nt.comparator);\n      var _iterator2 = _createForOfIteratorHelper(this.fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _t10 = _step2.value;\n          e = e.add(_t10);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(t),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var n = _step3.value;\n          e = e.add(n);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return new fe(e.toArray());\n    }\n    /**\n     * Verifies that `fieldPath` is included by at least one field in this field\n     * mask.\n     *\n     * This is an O(n) operation, where `n` is the size of the field mask.\n     */\n  }, {\n    key: \"covers\",\n    value: function covers(t) {\n      var _iterator4 = _createForOfIteratorHelper(this.fields),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var e = _step4.value;\n          if (e.isPrefixOf(t)) return !0;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return !1;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return vt(this.fields, t.fields, function (t, e) {\n        return t.isEqual(e);\n      });\n    }\n  }], [{\n    key: \"empty\",\n    value: function empty() {\n      return new fe([]);\n    }\n  }]);\n  return fe;\n}();\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nvar de = /*#__PURE__*/function () {\n  function de(t) {\n    _classCallCheck(this, de);\n    this.value = t;\n  }\n  _createClass(de, [{\n    key: \"field\",\n    value:\n    /**\n     * Returns the value at the given path or null.\n     *\n     * @param path - the path to search\n     * @returns The value at the path or null if the path is not set.\n     */\n    function field(t) {\n      if (t.isEmpty()) return this.value;\n      {\n        var e = this.value;\n        for (var n = 0; n < t.length - 1; ++n) {\n          if (e = (e.mapValue.fields || {})[t.get(n)], !jt(e)) return null;\n        }\n        return e = (e.mapValue.fields || {})[t.lastSegment()], e || null;\n      }\n    }\n    /**\n     * Sets the field to the provided value.\n     *\n     * @param path - The field path to set.\n     * @param value - The value to set.\n     */\n  }, {\n    key: \"set\",\n    value: function set(t, e) {\n      this.getFieldsMap(t.popLast())[t.lastSegment()] = Bt(e);\n    }\n    /**\n     * Sets the provided fields to the provided values.\n     *\n     * @param data - A map of fields to values (or null for deletes).\n     */\n  }, {\n    key: \"setAll\",\n    value: function setAll(t) {\n      var _this15 = this;\n      var e = nt.emptyPath(),\n        n = {},\n        r = [];\n      t.forEach(function (t, s) {\n        if (!e.isImmediateParentOf(s)) {\n          // Insert the accumulated changes at this parent location\n          var _t11 = _this15.getFieldsMap(e);\n          _this15.applyChanges(_t11, n, r), n = {}, r = [], e = s.popLast();\n        }\n        t ? n[s.lastSegment()] = Bt(t) : r.push(s.lastSegment());\n      });\n      var s = this.getFieldsMap(e);\n      this.applyChanges(s, n, r);\n    }\n    /**\n     * Removes the field at the specified path. If there is no field at the\n     * specified path, nothing is changed.\n     *\n     * @param path - The field path to remove.\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(t) {\n      var e = this.field(t.popLast());\n      jt(e) && e.mapValue.fields && delete e.mapValue.fields[t.lastSegment()];\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return St(this.value, t.value);\n    }\n    /**\n     * Returns the map that contains the leaf element of `path`. If the parent\n     * entry does not yet exist, or if it is not a map, a new map will be created.\n     */\n  }, {\n    key: \"getFieldsMap\",\n    value: function getFieldsMap(t) {\n      var e = this.value;\n      e.mapValue.fields || (e.mapValue = {\n        fields: {}\n      });\n      for (var n = 0; n < t.length; ++n) {\n        var r = e.mapValue.fields[t.get(n)];\n        jt(r) && r.mapValue.fields || (r = {\n          mapValue: {\n            fields: {}\n          }\n        }, e.mapValue.fields[t.get(n)] = r), e = r;\n      }\n      return e.mapValue.fields;\n    }\n    /**\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\n     * entries.\n     */\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(t, e, n) {\n      Et(e, function (e, n) {\n        return t[e] = n;\n      });\n      var _iterator5 = _createForOfIteratorHelper(n),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _e11 = _step5.value;\n          delete t[_e11];\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new de(Bt(this.value));\n    }\n  }], [{\n    key: \"empty\",\n    value: function empty() {\n      return new de({\n        mapValue: {}\n      });\n    }\n  }]);\n  return de;\n}();\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a document in Firestore with a key, version, data and whether it\n * has local mutations applied to it.\n *\n * Documents can transition between states via `convertToFoundDocument()`,\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\n * not transition to one of these states even after all mutations have been\n * applied, `isValidDocument()` returns false and the document should be removed\n * from all views.\n */\nvar we = /*#__PURE__*/function () {\n  function we(t, e, n, r, s, i, o) {\n    _classCallCheck(this, we);\n    this.key = t, this.documentType = e, this.version = n, this.readTime = r, this.createTime = s, this.data = i, this.documentState = o;\n  }\n  /**\n   * Creates a document with no known version or data, but which can serve as\n   * base document for mutations.\n   */\n  _createClass(we, [{\n    key: \"convertToFoundDocument\",\n    value:\n    /**\n     * Changes the document type to indicate that it exists and that its version\n     * and data are known.\n     */\n    function convertToFoundDocument(t, e) {\n      // If a document is switching state from being an invalid or deleted\n      // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n      // update from Watch or due to applying a local set mutation on top\n      // of a deleted document, our best guess about its createTime would be the\n      // version at which the document transitioned to a FOUND_DOCUMENT.\n      return !this.createTime.isEqual(oe.min()) || 2 /* DocumentType.NO_DOCUMENT */ !== this.documentType && 0 /* DocumentType.INVALID */ !== this.documentType || (this.createTime = t), this.version = t, this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */, this.data = e, this.documentState = 0 /* DocumentState.SYNCED */, this;\n    }\n    /**\n     * Changes the document type to indicate that it doesn't exist at the given\n     * version.\n     */\n  }, {\n    key: \"convertToNoDocument\",\n    value: function convertToNoDocument(t) {\n      return this.version = t, this.documentType = 2 /* DocumentType.NO_DOCUMENT */, this.data = de.empty(), this.documentState = 0 /* DocumentState.SYNCED */, this;\n    }\n    /**\n     * Changes the document type to indicate that it exists at a given version but\n     * that its data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n  }, {\n    key: \"convertToUnknownDocument\",\n    value: function convertToUnknownDocument(t) {\n      return this.version = t, this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */, this.data = de.empty(), this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */, this;\n    }\n  }, {\n    key: \"setHasCommittedMutations\",\n    value: function setHasCommittedMutations() {\n      return this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */, this;\n    }\n  }, {\n    key: \"setHasLocalMutations\",\n    value: function setHasLocalMutations() {\n      return this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */, this.version = oe.min(), this;\n    }\n  }, {\n    key: \"setReadTime\",\n    value: function setReadTime(t) {\n      return this.readTime = t, this;\n    }\n  }, {\n    key: \"hasLocalMutations\",\n    get: function get() {\n      return 1 /* DocumentState.HAS_LOCAL_MUTATIONS */ === this.documentState;\n    }\n  }, {\n    key: \"hasCommittedMutations\",\n    get: function get() {\n      return 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */ === this.documentState;\n    }\n  }, {\n    key: \"hasPendingWrites\",\n    get: function get() {\n      return this.hasLocalMutations || this.hasCommittedMutations;\n    }\n  }, {\n    key: \"isValidDocument\",\n    value: function isValidDocument() {\n      return 0 /* DocumentType.INVALID */ !== this.documentType;\n    }\n  }, {\n    key: \"isFoundDocument\",\n    value: function isFoundDocument() {\n      return 1 /* DocumentType.FOUND_DOCUMENT */ === this.documentType;\n    }\n  }, {\n    key: \"isNoDocument\",\n    value: function isNoDocument() {\n      return 2 /* DocumentType.NO_DOCUMENT */ === this.documentType;\n    }\n  }, {\n    key: \"isUnknownDocument\",\n    value: function isUnknownDocument() {\n      return 3 /* DocumentType.UNKNOWN_DOCUMENT */ === this.documentType;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return t instanceof we && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data);\n    }\n  }, {\n    key: \"mutableCopy\",\n    value: function mutableCopy() {\n      return new we(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Document(\".concat(this.key, \", \").concat(this.version, \", \").concat(JSON.stringify(this.data.value), \", {createTime: \").concat(this.createTime, \"}), {documentType: \").concat(this.documentType, \"}), {documentState: \").concat(this.documentState, \"})\");\n    }\n  }], [{\n    key: \"newInvalidDocument\",\n    value: function newInvalidDocument(t) {\n      return new we(t, 0 /* DocumentType.INVALID */, /* version */oe.min(), /* readTime */oe.min(), /* createTime */oe.min(), de.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist with the given data at the\n     * given version.\n     */\n  }, {\n    key: \"newFoundDocument\",\n    value: function newFoundDocument(t, e, n, r) {\n      return new we(t, 1 /* DocumentType.FOUND_DOCUMENT */, /* version */e, /* readTime */oe.min(), /* createTime */n, r, 0 /* DocumentState.SYNCED */);\n    }\n    /** Creates a new document that is known to not exist at the given version. */\n  }, {\n    key: \"newNoDocument\",\n    value: function newNoDocument(t, e) {\n      return new we(t, 2 /* DocumentType.NO_DOCUMENT */, /* version */e, /* readTime */oe.min(), /* createTime */oe.min(), de.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist at the given version but\n     * whose data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n  }, {\n    key: \"newUnknownDocument\",\n    value: function newUnknownDocument(t, e) {\n      return new we(t, 3 /* DocumentType.UNKNOWN_DOCUMENT */, /* version */e, /* readTime */oe.min(), /* createTime */oe.min(), de.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\n    }\n  }]);\n  return we;\n}();\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Visible for testing\nvar me = /*#__PURE__*/_createClass(function me(t) {\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var i = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  _classCallCheck(this, me);\n  this.path = t, this.collectionGroup = e, this.orderBy = n, this.filters = r, this.limit = s, this.startAt = i, this.endAt = o, this.S = null;\n});\n/**\n * Initializes a Target with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n *\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n * using this factory method, because `Query` provides an implicit `orderBy`\n * property.\n */\nfunction pe(t) {\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var i = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  return new me(t, e, n, r, s, i, o);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Query encapsulates all the query attributes we support in the SDK. It can\n * be run against the LocalStore, as well as be converted to a `Target` to\n * query the RemoteStore results.\n *\n * Visible for testing.\n */\nvar ye = /*#__PURE__*/_createClass(\n/**\n * Initializes a Query with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n */\nfunction ye(t) {\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var i = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"F\";\n  var o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var u = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  _classCallCheck(this, ye);\n  this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = r, this.limit = s, this.limitType = i, this.startAt = o, this.endAt = u, this.q = null,\n  // The corresponding `Target` of this `Query` instance.\n  this.O = null, this.startAt, this.endAt;\n});\n/** Creates a new Query for a query that matches all documents at `path` */\nfunction ge(t) {\n  return t.explicitOrderBy.length > 0 ? t.explicitOrderBy[0].field : null;\n}\nfunction _e(t) {\n  var _iterator6 = _createForOfIteratorHelper(t.filters),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var e = _step6.value;\n      var _t12 = e.getFirstInequalityField();\n      if (null !== _t12) return _t12;\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return null;\n}\n\n/**\n * Creates a new Query for a collection group query that matches all documents\n * within the provided collection group.\n */\n/**\n * Returns whether the query matches a collection group rather than a specific\n * collection.\n */\nfunction ve(t) {\n  return null !== t.collectionGroup;\n}\n\n/**\n * Returns the implicit order by constraint that is used to execute the Query,\n * which can be different from the order by constraints the user provided (e.g.\n * the SDK and backend always orders by `__name__`).\n */\nfunction be(t) {\n  var e = I(t);\n  if (null === e.q) {\n    e.q = [];\n    var _t13 = _e(e),\n      n = ge(e);\n    if (null !== _t13 && null === n)\n      // In order to implicitly add key ordering, we must also add the\n      // inequality filter field for it to be a valid query.\n      // Note that the default inequality field and key ordering is ascending.\n      _t13.isKeyField() || e.q.push(new se(_t13)), e.q.push(new se(nt.keyField(), \"asc\" /* Direction.ASCENDING */));else {\n      var _t14 = !1;\n      var _iterator7 = _createForOfIteratorHelper(e.explicitOrderBy),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _n4 = _step7.value;\n          e.q.push(_n4), _n4.field.isKeyField() && (_t14 = !0);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      if (!_t14) {\n        // The order of the implicit key ordering always matches the last\n        // explicit order by\n        var _t15 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : \"asc\" /* Direction.ASCENDING */;\n        e.q.push(new se(nt.keyField(), _t15));\n      }\n    }\n  }\n  return e.q;\n}\n\n/**\n * Converts this `Query` instance to it's corresponding `Target` representation.\n */\nfunction Ee(t) {\n  var e = I(t);\n  if (!e.O) if (\"F\" /* LimitType.First */ === e.limitType) e.O = pe(e.path, e.collectionGroup, be(e), e.filters, e.limit, e.startAt, e.endAt);else {\n    // Flip the orderBy directions since we want the last results\n    var _t16 = [];\n    var _iterator8 = _createForOfIteratorHelper(be(e)),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _n5 = _step8.value;\n        var _e12 = \"desc\" /* Direction.DESCENDING */ === _n5.dir ? \"asc\" /* Direction.ASCENDING */ : \"desc\" /* Direction.DESCENDING */;\n        _t16.push(new se(_n5.field, _e12));\n      }\n      // We need to swap the cursors to match the now-flipped query ordering.\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    var n = e.endAt ? new Qt(e.endAt.position, e.endAt.inclusive) : null,\n      r = e.startAt ? new Qt(e.startAt.position, e.startAt.inclusive) : null;\n    // Now return as a LimitType.First query.\n    e.O = pe(e.path, e.collectionGroup, _t16, e.filters, e.limit, n, r);\n  }\n  return e.O;\n}\nfunction Ie(t, e) {\n  e.getFirstInequalityField(), _e(t);\n  var n = t.filters.concat([e]);\n  return new ye(t.path, t.collectionGroup, t.explicitOrderBy.slice(), n, t.limit, t.limitType, t.startAt, t.endAt);\n}\nfunction Te(t, e) {\n  return function (t, e) {\n    if (t.limit !== e.limit) return !1;\n    if (t.orderBy.length !== e.orderBy.length) return !1;\n    for (var n = 0; n < t.orderBy.length; n++) {\n      if (!ie(t.orderBy[n], e.orderBy[n])) return !1;\n    }\n    if (t.filters.length !== e.filters.length) return !1;\n    for (var _n6 = 0; _n6 < t.filters.length; _n6++) {\n      if (!Yt(t.filters[_n6], e.filters[_n6])) return !1;\n    }\n    return t.collectionGroup === e.collectionGroup && !!t.path.isEqual(e.path) && !!zt(t.startAt, e.startAt) && zt(t.endAt, e.endAt);\n  }(Ee(t), Ee(e)) && t.limitType === e.limitType;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns an DoubleValue for `value` that is encoded based the serializer's\n * `useProto3Json` setting.\n */\n/**\n * Returns a value for a number that's appropriate to put into a proto.\n * The return value is an IntegerValue if it can safely represent the value,\n * otherwise a DoubleValue is returned.\n */\nfunction Ae(t, e) {\n  return function (t) {\n    return \"number\" == typeof t && Number.isInteger(t) && !lt(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;\n  }(e) ?\n  /**\n  * Returns an IntegerValue for `value`.\n  */\n  function (t) {\n    return {\n      integerValue: \"\" + t\n    };\n  }(e) : function (t, e) {\n    if (t.k) {\n      if (isNaN(e)) return {\n        doubleValue: \"NaN\"\n      };\n      if (e === 1 / 0) return {\n        doubleValue: \"Infinity\"\n      };\n      if (e === -1 / 0) return {\n        doubleValue: \"-Infinity\"\n      };\n    }\n    return {\n      doubleValue: lt(e) ? \"-0\" : e\n    };\n  }(t, e);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used to represent a field transform on a mutation. */\nvar Re = /*#__PURE__*/_createClass(function Re() {\n  _classCallCheck(this, Re);\n  // Make sure that the structural type of `TransformOperation` is unique.\n  // See https://github.com/microsoft/TypeScript/issues/5451\n  this._ = void 0;\n});\n/** Transforms a value into a server-generated timestamp. */\nvar Pe = /*#__PURE__*/function (_Re) {\n  _inherits(Pe, _Re);\n  var _super14 = _createSuper(Pe);\n  function Pe() {\n    _classCallCheck(this, Pe);\n    return _super14.apply(this, arguments);\n  }\n  return _createClass(Pe);\n}(Re);\n/** Transforms an array value via a union operation. */\nvar Ve = /*#__PURE__*/function (_Re2) {\n  _inherits(Ve, _Re2);\n  var _super15 = _createSuper(Ve);\n  function Ve(t) {\n    var _this16;\n    _classCallCheck(this, Ve);\n    _this16 = _super15.call(this), _this16.elements = t;\n    return _this16;\n  }\n  return _createClass(Ve);\n}(Re);\n/** Transforms an array value via a remove operation. */\nvar $e = /*#__PURE__*/function (_Re3) {\n  _inherits($e, _Re3);\n  var _super16 = _createSuper($e);\n  function $e(t) {\n    var _this17;\n    _classCallCheck(this, $e);\n    _this17 = _super16.call(this), _this17.elements = t;\n    return _this17;\n  }\n  return _createClass($e);\n}(Re);\n/**\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\n * transforms. Converts all field values to integers or doubles, but unlike the\n * backend does not cap integer values at 2^63. Instead, JavaScript number\n * arithmetic is used and precision loss can occur for values greater than 2^53.\n */\nvar Ne = /*#__PURE__*/function (_Re4) {\n  _inherits(Ne, _Re4);\n  var _super17 = _createSuper(Ne);\n  function Ne(t, e) {\n    var _this18;\n    _classCallCheck(this, Ne);\n    _this18 = _super17.call(this), _this18.C = t, _this18.L = e;\n    return _this18;\n  }\n  return _createClass(Ne);\n}(Re);\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A field path and the TransformOperation to perform upon it. */\nvar De = /*#__PURE__*/_createClass(function De(t, e) {\n  _classCallCheck(this, De);\n  this.field = t, this.transform = e;\n});\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nvar Fe = /*#__PURE__*/function () {\n  function Fe(t, e) {\n    _classCallCheck(this, Fe);\n    this.updateTime = t, this.exists = e;\n  }\n  /** Creates a new empty Precondition. */\n  _createClass(Fe, [{\n    key: \"isNone\",\n    get: /** Returns whether this Precondition is empty. */function get() {\n      return void 0 === this.updateTime && void 0 === this.exists;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime);\n    }\n  }], [{\n    key: \"none\",\n    value: function none() {\n      return new Fe();\n    }\n    /** Creates a new Precondition with an exists flag. */\n  }, {\n    key: \"exists\",\n    value: function exists(t) {\n      return new Fe(void 0, t);\n    }\n    /** Creates a new Precondition based on a version a document exists at. */\n  }, {\n    key: \"updateTime\",\n    value: function updateTime(t) {\n      return new Fe(t);\n    }\n  }]);\n  return Fe;\n}();\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also its version.\n *\n * For local mutations (mutations that haven't been committed yet), we preserve\n * the existing version for Set and Patch mutations. For Delete mutations, we\n * reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        InvalidDocument(v0)   Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\n *\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\n * the resulting version for Set and Patch mutations. As deletes have no\n * explicit update time, we use the commitTime of the WriteResponse for\n * Delete mutations.\n *\n * If a mutation is acknowledged by the backend but fails the precondition check\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\n * the updated version.\n *\n * Field transforms are used only with Patch and Set Mutations. We use the\n * `updateTransforms` message to store transforms, rather than the `transforms`s\n * messages.\n *\n * ## Subclassing Notes\n *\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\n * example).\n */\nvar xe = /*#__PURE__*/_createClass(function xe() {\n  _classCallCheck(this, xe);\n});\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nvar Se = /*#__PURE__*/function (_xe) {\n  _inherits(Se, _xe);\n  var _super18 = _createSuper(Se);\n  function Se(t, e, n) {\n    var _this19;\n    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    _classCallCheck(this, Se);\n    _this19 = _super18.call(this), _this19.key = t, _this19.value = e, _this19.precondition = n, _this19.fieldTransforms = r, _this19.type = 0 /* MutationType.Set */;\n    return _this19;\n  }\n  _createClass(Se, [{\n    key: \"getFieldMask\",\n    value: function getFieldMask() {\n      return null;\n    }\n  }]);\n  return Se;\n}(xe);\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nvar qe = /*#__PURE__*/function (_xe2) {\n  _inherits(qe, _xe2);\n  var _super19 = _createSuper(qe);\n  function qe(t, e, n, r) {\n    var _this20;\n    var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    _classCallCheck(this, qe);\n    _this20 = _super19.call(this), _this20.key = t, _this20.data = e, _this20.fieldMask = n, _this20.precondition = r, _this20.fieldTransforms = s, _this20.type = 1 /* MutationType.Patch */;\n    return _this20;\n  }\n  _createClass(qe, [{\n    key: \"getFieldMask\",\n    value: function getFieldMask() {\n      return this.fieldMask;\n    }\n  }]);\n  return qe;\n}(xe);\n/** A mutation that deletes the document at the given key. */\nvar Oe = /*#__PURE__*/function (_xe3) {\n  _inherits(Oe, _xe3);\n  var _super20 = _createSuper(Oe);\n  function Oe(t, e) {\n    var _this21;\n    _classCallCheck(this, Oe);\n    _this21 = _super20.call(this), _this21.key = t, _this21.precondition = e, _this21.type = 2 /* MutationType.Delete */, _this21.fieldTransforms = [];\n    return _this21;\n  }\n  _createClass(Oe, [{\n    key: \"getFieldMask\",\n    value: function getFieldMask() {\n      return null;\n    }\n  }]);\n  return Oe;\n}(xe);\n/**\n * A mutation that verifies the existence of the document at the given key with\n * the provided precondition.\n *\n * The `verify` operation is only used in Transactions, and this class serves\n * primarily to facilitate serialization into protos.\n */\nvar ke = /*#__PURE__*/function (_xe4) {\n  _inherits(ke, _xe4);\n  var _super21 = _createSuper(ke);\n  function ke(t, e) {\n    var _this22;\n    _classCallCheck(this, ke);\n    _this22 = _super21.call(this), _this22.key = t, _this22.precondition = e, _this22.type = 3 /* MutationType.Verify */, _this22.fieldTransforms = [];\n    return _this22;\n  }\n  _createClass(ke, [{\n    key: \"getFieldMask\",\n    value: function getFieldMask() {\n      return null;\n    }\n  }]);\n  return ke;\n}(xe);\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Ce = function () {\n    var t = {\n      asc: \"ASCENDING\",\n      desc: \"DESCENDING\"\n    };\n    return t;\n  }(),\n  Le = function () {\n    var t = {\n      \"<\": \"LESS_THAN\",\n      \"<=\": \"LESS_THAN_OR_EQUAL\",\n      \">\": \"GREATER_THAN\",\n      \">=\": \"GREATER_THAN_OR_EQUAL\",\n      \"==\": \"EQUAL\",\n      \"!=\": \"NOT_EQUAL\",\n      \"array-contains\": \"ARRAY_CONTAINS\",\n      \"in\": \"IN\",\n      \"not-in\": \"NOT_IN\",\n      \"array-contains-any\": \"ARRAY_CONTAINS_ANY\"\n    };\n    return t;\n  }(),\n  Me = function () {\n    var t = {\n      and: \"AND\",\n      or: \"OR\"\n    };\n    return t;\n  }();\n\n/**\n * This class generates JsonObject values for the Datastore API suitable for\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\n *\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\n * format.\n *\n * For a description of the Proto3 JSON format check\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n *\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nvar Ue = /*#__PURE__*/_createClass(function Ue(t, e) {\n  _classCallCheck(this, Ue);\n  this.databaseId = t, this.k = e;\n});\n/**\n * Returns a value for a number (or null) that's appropriate to put into\n * a google.protobuf.Int32Value proto.\n * DO NOT USE THIS FOR ANYTHING ELSE.\n * This method cheats. It's typed as returning \"number\" because that's what\n * our generated proto interfaces say Int32Value must be. But GRPC actually\n * expects a { value: <number> } struct.\n */\n/**\n * Returns a value for a Date that's appropriate to put into a proto.\n */\nfunction je(t, e) {\n  if (t.k) {\n    return \"\".concat(new Date(1e3 * e.seconds).toISOString().replace(/\\.\\d*/, \"\").replace(\"Z\", \"\"), \".\").concat((\"000000000\" + e.nanoseconds).slice(-9), \"Z\");\n  }\n  return {\n    seconds: \"\" + e.seconds,\n    nanos: e.nanoseconds\n  };\n}\n\n/**\n * Returns a value for bytes that's appropriate to put in a proto.\n *\n * Visible for testing.\n */\nfunction Be(t, e) {\n  return t.k ? e.toBase64() : e.toUint8Array();\n}\nfunction Qe(t, e) {\n  return je(t, e.toTimestamp());\n}\nfunction ze(t) {\n  return E(!!t), oe.fromTimestamp(function (t) {\n    var e = At(t);\n    return new Vt(e.seconds, e.nanos);\n  }(t));\n}\nfunction We(t, e) {\n  return function (t) {\n    return new tt([\"projects\", t.projectId, \"databases\", t.database]);\n  }(t).child(\"documents\").child(e).canonicalString();\n}\nfunction Ge(t, e) {\n  return We(t.databaseId, e.path);\n}\nfunction Ke(t, e) {\n  var n = function (t) {\n    var e = tt.fromString(t);\n    return E(cn(e)), e;\n  }(e);\n  if (n.get(1) !== t.databaseId.projectId) throw new U(P, \"Tried to deserialize key from different project: \" + n.get(1) + \" vs \" + t.databaseId.projectId);\n  if (n.get(3) !== t.databaseId.database) throw new U(P, \"Tried to deserialize key from different database: \" + n.get(3) + \" vs \" + t.databaseId.database);\n  return new rt((E((r = n).length > 4 && \"documents\" === r.get(4)), r.popFirst(5)));\n  var r;\n  /** Creates a Document proto from key and fields (but no create/update time) */\n}\n\nfunction Ye(t, e) {\n  return We(t.databaseId, e);\n}\nfunction He(t) {\n  return new tt([\"projects\", t.databaseId.projectId, \"databases\", t.databaseId.database]).canonicalString();\n}\nfunction Je(t, e, n) {\n  return {\n    name: Ge(t, e),\n    fields: n.value.mapValue.fields\n  };\n}\nfunction Xe(t, e) {\n  return \"found\" in e ? function (t, e) {\n    E(!!e.found), e.found.name, e.found.updateTime;\n    var n = Ke(t, e.found.name),\n      r = ze(e.found.updateTime),\n      s = e.found.createTime ? ze(e.found.createTime) : oe.min(),\n      i = new de({\n        mapValue: {\n          fields: e.found.fields\n        }\n      });\n    return we.newFoundDocument(n, r, s, i);\n  }(t, e) : \"missing\" in e ? function (t, e) {\n    E(!!e.missing), E(!!e.readTime);\n    var n = Ke(t, e.missing),\n      r = ze(e.readTime);\n    return we.newNoDocument(n, r);\n  }(t, e) : b();\n}\nfunction Ze(t, e) {\n  var n;\n  if (e instanceof Se) n = {\n    update: Je(t, e.key, e.value)\n  };else if (e instanceof Oe) n = {\n    \"delete\": Ge(t, e.key)\n  };else if (e instanceof qe) n = {\n    update: Je(t, e.key, e.data),\n    updateMask: un(e.fieldMask)\n  };else {\n    if (!(e instanceof ke)) return b();\n    n = {\n      verify: Ge(t, e.key)\n    };\n  }\n  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map(function (t) {\n    return function (t, e) {\n      var n = e.transform;\n      if (n instanceof Pe) return {\n        fieldPath: e.field.canonicalString(),\n        setToServerValue: \"REQUEST_TIME\"\n      };\n      if (n instanceof Ve) return {\n        fieldPath: e.field.canonicalString(),\n        appendMissingElements: {\n          values: n.elements\n        }\n      };\n      if (n instanceof $e) return {\n        fieldPath: e.field.canonicalString(),\n        removeAllFromArray: {\n          values: n.elements\n        }\n      };\n      if (n instanceof Ne) return {\n        fieldPath: e.field.canonicalString(),\n        increment: n.L\n      };\n      throw b();\n    }(0, t);\n  })), e.precondition.isNone || (n.currentDocument = function (t, e) {\n    return void 0 !== e.updateTime ? {\n      updateTime: Qe(t, e.updateTime)\n    } : void 0 !== e.exists ? {\n      exists: e.exists\n    } : b();\n  }(t, e.precondition)), n;\n}\nfunction tn(t, e) {\n  // Dissect the path into parent, collectionId, and optional key filter.\n  var n = {\n      structuredQuery: {}\n    },\n    r = e.path;\n  null !== e.collectionGroup ? (n.parent = Ye(t, r), n.structuredQuery.from = [{\n    collectionId: e.collectionGroup,\n    allDescendants: !0\n  }]) : (n.parent = Ye(t, r.popLast()), n.structuredQuery.from = [{\n    collectionId: r.lastSegment()\n  }]);\n  var s = function (t) {\n    if (0 === t.length) return;\n    return on(Kt.create(t, \"and\" /* CompositeOperator.AND */));\n  }(e.filters);\n  s && (n.structuredQuery.where = s);\n  var i = function (t) {\n    if (0 === t.length) return;\n    return t.map(function (t) {\n      return (\n        // visible for testing\n        function (t) {\n          return {\n            field: sn(t.field),\n            direction: en(t.dir)\n          };\n        }\n        // visible for testing\n        (t)\n      );\n    });\n  }(e.orderBy);\n  i && (n.structuredQuery.orderBy = i);\n  var o = function (t, e) {\n    return t.k || ht(e) ? e : {\n      value: e\n    };\n  }(t, e.limit);\n  var u;\n  return null !== o && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {\n    before: (u = e.startAt).inclusive,\n    values: u.position\n  }), e.endAt && (n.structuredQuery.endAt = function (t) {\n    return {\n      before: !t.inclusive,\n      values: t.position\n    };\n  }\n  // visible for testing\n  (e.endAt)), n;\n}\nfunction en(t) {\n  return Ce[t];\n}\n\n// visible for testing\nfunction nn(t) {\n  return Le[t];\n}\nfunction rn(t) {\n  return Me[t];\n}\nfunction sn(t) {\n  return {\n    fieldPath: t.canonicalString()\n  };\n}\nfunction on(t) {\n  return t instanceof Gt ? function (t) {\n    if (\"==\" /* Operator.EQUAL */ === t.op) {\n      if (Ut(t.value)) return {\n        unaryFilter: {\n          field: sn(t.field),\n          op: \"IS_NAN\"\n        }\n      };\n      if (Mt(t.value)) return {\n        unaryFilter: {\n          field: sn(t.field),\n          op: \"IS_NULL\"\n        }\n      };\n    } else if (\"!=\" /* Operator.NOT_EQUAL */ === t.op) {\n      if (Ut(t.value)) return {\n        unaryFilter: {\n          field: sn(t.field),\n          op: \"IS_NOT_NAN\"\n        }\n      };\n      if (Mt(t.value)) return {\n        unaryFilter: {\n          field: sn(t.field),\n          op: \"IS_NOT_NULL\"\n        }\n      };\n    }\n    return {\n      fieldFilter: {\n        field: sn(t.field),\n        op: nn(t.op),\n        value: t.value\n      }\n    };\n  }(t) : t instanceof Kt ? function (t) {\n    var e = t.getFilters().map(function (t) {\n      return on(t);\n    });\n    if (1 === e.length) return e[0];\n    return {\n      compositeFilter: {\n        op: rn(t.op),\n        filters: e\n      }\n    };\n  }(t) : b();\n}\nfunction un(t) {\n  var e = [];\n  return t.fields.forEach(function (t) {\n    return e.push(t.canonicalString());\n  }), {\n    fieldPaths: e\n  };\n}\nfunction cn(t) {\n  // Resource names have at least 4 components (project ID, database ID)\n  return t.length >= 4 && \"projects\" === t.get(0) && \"databases\" === t.get(2);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction an(t) {\n  return new Ue(t, /* useProto3Json= */!0);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nvar hn = /*#__PURE__*/function () {\n  function hn(\n  /**\n   * The AsyncQueue to run backoff operations on.\n   */\n  t,\n  /**\n   * The ID to use when scheduling backoff operations on the AsyncQueue.\n   */\n  e) {\n    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e3;\n    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.5;\n    var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 6e4;\n    _classCallCheck(this, hn);\n    this.M = t, this.timerId = e, this.U = n, this.j = r, this.B = s, this.W = 0, this.G = null, /** The last backoff attempt, as epoch milliseconds. */\n    this.K = Date.now(), this.reset();\n  }\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n  _createClass(hn, [{\n    key: \"reset\",\n    value: function reset() {\n      this.W = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n  }, {\n    key: \"Y\",\n    value: function Y() {\n      this.W = this.B;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n  }, {\n    key: \"H\",\n    value: function H(t) {\n      var _this23 = this;\n      // Cancel any pending backoff operation.\n      this.cancel();\n      // First schedule using the current base (which may be 0 and should be\n      // honored as such).\n      var e = Math.floor(this.W + this.J()),\n        n = Math.max(0, Date.now() - this.K),\n        r = Math.max(0, e - n);\n      // Guard against lastAttemptTime being in the future due to a clock change.\n      r > 0 && y(\"ExponentialBackoff\", \"Backing off for \".concat(r, \" ms (base delay: \").concat(this.W, \" ms, delay with jitter: \").concat(e, \" ms, last attempt: \").concat(n, \" ms ago)\")), this.G = this.M.enqueueAfterDelay(this.timerId, r, function () {\n        return _this23.K = Date.now(), t();\n      }),\n      // Apply backoff factor to determine next delay and ensure it is within\n      // bounds.\n      this.W *= this.j, this.W < this.U && (this.W = this.U), this.W > this.B && (this.W = this.B);\n    }\n  }, {\n    key: \"X\",\n    value: function X() {\n      null !== this.G && (this.G.skipDelay(), this.G = null);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      null !== this.G && (this.G.cancel(), this.G = null);\n    }\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n  }, {\n    key: \"J\",\n    value: function J() {\n      return (Math.random() - .5) * this.W;\n    }\n  }]);\n  return hn;\n}();\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Datastore and its related methods are a wrapper around the external Google\n * Cloud Datastore grpc API, which provides an interface that is more convenient\n * for the rest of the client SDK architecture to consume.\n */\n/**\n * An implementation of Datastore that exposes additional state for internal\n * consumption.\n */\nvar ln = /*#__PURE__*/function (_ref2) {\n  _inherits(ln, _ref2);\n  var _super22 = _createSuper(ln);\n  function ln(t, e, n, r) {\n    var _this24;\n    _classCallCheck(this, ln);\n    _this24 = _super22.call(this), _this24.authCredentials = t, _this24.appCheckCredentials = e, _this24.connection = n, _this24.C = r, _this24.Z = !1;\n    return _this24;\n  }\n  _createClass(ln, [{\n    key: \"tt\",\n    value: function tt() {\n      if (this.Z) throw new U(S, \"The client has already been terminated.\");\n    }\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\n  }, {\n    key: \"I\",\n    value: function I(t, e, n) {\n      var _this25 = this;\n      return this.tt(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          r = _ref4[0],\n          s = _ref4[1];\n        return _this25.connection.I(t, e, n, r, s);\n      })[\"catch\"](function (t) {\n        throw \"FirebaseError\" === t.name ? (t.code === F && (_this25.authCredentials.invalidateToken(), _this25.appCheckCredentials.invalidateToken()), t) : new U(R, t.toString());\n      });\n    }\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\n  }, {\n    key: \"P\",\n    value: function P(t, e, n, r) {\n      var _this26 = this;\n      return this.tt(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          s = _ref6[0],\n          i = _ref6[1];\n        return _this26.connection.P(t, e, n, s, i, r);\n      })[\"catch\"](function (t) {\n        throw \"FirebaseError\" === t.name ? (t.code === F && (_this26.authCredentials.invalidateToken(), _this26.appCheckCredentials.invalidateToken()), t) : new U(R, t.toString());\n      });\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      this.Z = !0;\n    }\n  }]);\n  return ln;\n}( /*#__PURE__*/function () {\n  function _class3() {\n    _classCallCheck(this, _class3);\n  }\n  return _createClass(_class3);\n}()); // TODO(firestorexp): Make sure there is only one Datastore instance per\n// firestore-exp client.\nfunction fn(_x5, _x6) {\n  return _fn.apply(this, arguments);\n}\nfunction _fn() {\n  _fn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(t, e) {\n    var n, r, s;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            n = I(t), r = He(n.C) + \"/documents\", s = {\n              writes: e.map(function (t) {\n                return Ze(n.C, t);\n              })\n            };\n            _context7.next = 3;\n            return n.I(\"Commit\", r, s);\n          case 3:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _fn.apply(this, arguments);\n}\nfunction dn(_x7, _x8) {\n  return _dn.apply(this, arguments);\n}\nfunction _dn() {\n  _dn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(t, e) {\n    var n, r, s, i, o, u;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            n = I(t);\n            r = He(n.C) + \"/documents\";\n            s = {\n              documents: e.map(function (t) {\n                return Ge(n.C, t);\n              })\n            };\n            _context8.next = 5;\n            return n.P(\"BatchGetDocuments\", r, s, e.length);\n          case 5:\n            i = _context8.sent;\n            o = new Map();\n            i.forEach(function (t) {\n              var e = Xe(n.C, t);\n              o.set(e.key.toString(), e);\n            });\n            u = [];\n            return _context8.abrupt(\"return\", (e.forEach(function (t) {\n              var e = o.get(t.toString());\n              E(!!e), u.push(e);\n            }), u));\n          case 10:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _dn.apply(this, arguments);\n}\nfunction wn(_x9, _x10) {\n  return _wn.apply(this, arguments);\n}\nfunction _wn() {\n  _wn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(t, e) {\n    var n, r;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            n = I(t), r = tn(n.C, Ee(e));\n            _context9.next = 3;\n            return n.P(\"RunQuery\", r.parent, {\n              structuredQuery: r.structuredQuery\n            });\n          case 3:\n            return _context9.abrupt(\"return\", _context9.sent.filter(function (t) {\n              return !!t.document;\n            }).map(function (t) {\n              return function (t, e, n) {\n                var r = Ke(t, e.name),\n                  s = ze(e.updateTime),\n                  i = e.createTime ? ze(e.createTime) : oe.min(),\n                  o = new de({\n                    mapValue: {\n                      fields: e.fields\n                    }\n                  }),\n                  u = we.newFoundDocument(r, s, i, o);\n                return n && u.setHasCommittedMutations(), n ? u.setHasCommittedMutations() : u;\n              }(n.C, t.document, void 0);\n            }));\n          case 4:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _wn.apply(this, arguments);\n}\nfunction mn(_x11, _x12) {\n  return _mn.apply(this, arguments);\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _mn() {\n  _mn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(t, e) {\n    var n, r, s;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            n = I(t), r = function (t, e) {\n              var n = tn(t, e);\n              return {\n                structuredAggregationQuery: {\n                  aggregations: [{\n                    count: {},\n                    alias: \"count_alias\"\n                  }],\n                  structuredQuery: n.structuredQuery\n                },\n                parent: n.parent\n              };\n            }(n.C, Ee(e)), s = r.parent;\n            n.connection.v || delete r.parent;\n            _context10.next = 4;\n            return n.P(\"RunAggregationQuery\", s, r, /*expectedResponseCount=*/1);\n          case 4:\n            return _context10.abrupt(\"return\", _context10.sent.filter(function (t) {\n              return !!t.result;\n            }).map(function (t) {\n              return t.result.aggregateFields;\n            }));\n          case 5:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  return _mn.apply(this, arguments);\n}\nvar pn = new Map();\n\n/**\n * An instance map that ensures only one Datastore exists per Firestore\n * instance.\n */\n/**\n * Returns an initialized and started Datastore for the given Firestore\n * instance. Callers must invoke removeComponents() when the Firestore\n * instance is terminated.\n */\nfunction yn(t) {\n  if (t._terminated) throw new U(S, \"The client has already been terminated.\");\n  if (!pn.has(t)) {\n    y(\"ComponentProvider\", \"Initializing Datastore\");\n    var i = function (t) {\n        return new pt(t, fetch.bind(null));\n      }((e = t._databaseId, n = t.app.options.appId || \"\", r = t._persistenceKey, s = t._freezeSettings(), new J(e, n, r, s.host, s.ssl, s.experimentalForceLongPolling, s.experimentalAutoDetectLongPolling, s.useFetchStreams))),\n      o = an(t._databaseId),\n      u = function (t, e, n, r) {\n        return new ln(t, e, n, r);\n      }(t._authCredentials, t._appCheckCredentials, i, o);\n    pn.set(t, u);\n  }\n  var e, n, r, s;\n  /**\n  * @license\n  * Copyright 2018 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n  return pn.get(t);\n}\n\n/**\n * Removes all components associated with the provided instance. Must be called\n * when the `Firestore` instance is terminated.\n */\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied `FirestoreSettings` object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nvar gn = /*#__PURE__*/function () {\n  function gn(t) {\n    _classCallCheck(this, gn);\n    var e;\n    if (void 0 === t.host) {\n      if (void 0 !== t.ssl) throw new U(P, \"Can't provide ssl option if host option is not set\");\n      this.host = \"firestore.googleapis.com\", this.ssl = true;\n    } else this.host = t.host, this.ssl = null === (e = t.ssl) || void 0 === e || e;\n    if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, void 0 === t.cacheSizeBytes) this.cacheSizeBytes = 41943040;else {\n      if (-1 !== t.cacheSizeBytes && t.cacheSizeBytes < 1048576) throw new U(P, \"cacheSizeBytes must be at least 1048576\");\n      this.cacheSizeBytes = t.cacheSizeBytes;\n    }\n    this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t.useFetchStreams, function (t, e, n, r) {\n      if (!0 === e && !0 === r) throw new U(P, \"\".concat(t, \" and \").concat(n, \" cannot be used together.\"));\n    }(\"experimentalForceLongPolling\", t.experimentalForceLongPolling, \"experimentalAutoDetectLongPolling\", t.experimentalAutoDetectLongPolling);\n  }\n  _createClass(gn, [{\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams;\n    }\n  }]);\n  return gn;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nvar _n = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function _n(t, e, n, r) {\n    _classCallCheck(this, _n);\n    this._authCredentials = t, this._appCheckCredentials = e, this._databaseId = n, this._app = r,\n    /**\n     * Whether it's a Firestore or Firestore Lite instance.\n     */\n    this.type = \"firestore-lite\", this._persistenceKey = \"(lite)\", this._settings = new gn({}), this._settingsFrozen = !1;\n  }\n  /**\n   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\n   * instance.\n   */\n  _createClass(_n, [{\n    key: \"app\",\n    get: function get() {\n      if (!this._app) throw new U(S, \"Firestore was not initialized using the Firebase SDK. 'app' is not available\");\n      return this._app;\n    }\n  }, {\n    key: \"_initialized\",\n    get: function get() {\n      return this._settingsFrozen;\n    }\n  }, {\n    key: \"_terminated\",\n    get: function get() {\n      return void 0 !== this._terminateTask;\n    }\n  }, {\n    key: \"_setSettings\",\n    value: function _setSettings(t) {\n      if (this._settingsFrozen) throw new U(S, \"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.\");\n      this._settings = new gn(t), void 0 !== t.credentials && (this._authCredentials = function (t) {\n        if (!t) return new Q();\n        switch (t.type) {\n          case \"gapi\":\n            var e = t.client;\n            return new K(e, t.sessionIndex || \"0\", t.iamToken || null, t.authTokenFactory || null);\n          case \"provider\":\n            return t.client;\n          default:\n            throw new U(P, \"makeAuthCredentialsProvider failed due to invalid credential type\");\n        }\n      }(t.credentials));\n    }\n  }, {\n    key: \"_getSettings\",\n    value: function _getSettings() {\n      return this._settings;\n    }\n  }, {\n    key: \"_freezeSettings\",\n    value: function _freezeSettings() {\n      return this._settingsFrozen = !0, this._settings;\n    }\n  }, {\n    key: \"_delete\",\n    value: function _delete() {\n      return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;\n    }\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        app: this._app,\n        databaseId: this._databaseId,\n        settings: this._settings\n      };\n    }\n    /**\n     * Terminates all components used by this client. Subclasses can override\n     * this method to clean up their own dependencies, but must also call this\n     * method.\n     *\n     * Only ever called once.\n     */\n  }, {\n    key: \"_terminate\",\n    value: function _terminate() {\n      return function (t) {\n        var e = pn.get(t);\n        e && (y(\"ComponentProvider\", \"Removing Datastore\"), pn[\"delete\"](t), e.terminate());\n      }(this), Promise.resolve();\n    }\n  }]);\n  return _n;\n}();\nfunction vn(t, e, n) {\n  n || (n = \"(default)\");\n  var r = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(t, \"firestore/lite\");\n  if (r.isInitialized(n)) throw new U(S, \"Firestore can only be initialized once per app.\");\n  return r.initialize({\n    options: e,\n    instanceIdentifier: n\n  });\n}\nfunction bn(e, n) {\n  var r = \"object\" == _typeof(e) ? e : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(),\n    s = \"string\" == typeof e ? e : n || \"(default)\",\n    i = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(r, \"firestore/lite\").getImmediate({\n      identifier: s\n    });\n  if (!i._initialized) {\n    var t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getDefaultEmulatorHostnameAndPort)(\"firestore\");\n    t && En.apply(void 0, [i].concat(_toConsumableArray(t)));\n  }\n  return i;\n}\n\n/**\n * Modify this instance to communicate with the Cloud Firestore emulator.\n *\n * Note: This must be called before this instance has been used to do any\n * operations.\n *\n * @param firestore - The `Firestore` instance to configure to connect to the\n * emulator.\n * @param host - the emulator host (ex: localhost).\n * @param port - the emulator port (ex: 9000).\n * @param options.mockUserToken - the mock auth token to use for unit testing\n * Security Rules.\n */\nfunction En(t, e, n) {\n  var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var s;\n  var i = (t = ct(t, _n))._getSettings();\n  if (\"firestore.googleapis.com\" !== i.host && i.host !== e && _(\"Host has been set in both settings() and useEmulator(), emulator host will be used\"), t._setSettings(Object.assign(Object.assign({}, i), {\n    host: \"\".concat(e, \":\").concat(n),\n    ssl: !1\n  })), r.mockUserToken) {\n    var _e13, _n7;\n    if (\"string\" == typeof r.mockUserToken) _e13 = r.mockUserToken, _n7 = d.MOCK_USER;else {\n      // Let createMockUserToken validate first (catches common mistakes like\n      // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\n      _e13 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.createMockUserToken)(r.mockUserToken, null === (s = t._app) || void 0 === s ? void 0 : s.options.projectId);\n      var _i2 = r.mockUserToken.sub || r.mockUserToken.user_id;\n      if (!_i2) throw new U(P, \"mockUserToken must contain 'sub' or 'user_id' field!\");\n      _n7 = new d(_i2);\n    }\n    t._authCredentials = new z(new B(_e13, _n7));\n  }\n}\n\n/**\n * Terminates the provided `Firestore` instance.\n *\n * After calling `terminate()` only the `clearIndexedDbPersistence()` functions\n * may be used. Any other function will throw a `FirestoreError`. Termination\n * does not cancel any pending writes, and any promises that are awaiting a\n * response from the server will not be resolved.\n *\n * To restart after termination, create a new instance of `Firestore` with\n * {@link (getFirestore:1)}.\n *\n * Note: Under normal circumstances, calling `terminate()` is not required. This\n * function is useful only when you want to force this instance to release all of\n * its resources or in combination with {@link clearIndexedDbPersistence} to\n * ensure that all local state is destroyed between test runs.\n *\n * @param firestore - The `Firestore` instance to terminate.\n * @returns A `Promise` that is resolved when the instance has been successfully\n * terminated.\n */\nfunction In(t) {\n  return t = ct(t, _n), (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(t.app, \"firestore/lite\"), t._delete();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar Tn = /*#__PURE__*/_createClass(function Tn() {\n  _classCallCheck(this, Tn);\n  /** A type string to uniquely identify instances of this class. */\n  this.type = \"AggregateField\";\n});\n/**\n * The results of executing an aggregation query.\n */\nvar An = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function An(t, e) {\n    _classCallCheck(this, An);\n    this._data = e, /** A type string to uniquely identify instances of this class. */\n    this.type = \"AggregateQuerySnapshot\", this.query = t;\n  }\n  /**\n   * Returns the results of the aggregations performed over the underlying\n   * query.\n   *\n   * The keys of the returned object will be the same as those of the\n   * `AggregateSpec` object specified to the aggregation method, and the values\n   * will be the corresponding aggregation result.\n   *\n   * @returns The results of the aggregations performed over the underlying\n   * query.\n   */\n  _createClass(An, [{\n    key: \"data\",\n    value: function data() {\n      return this._data;\n    }\n  }]);\n  return An;\n}();\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * CountQueryRunner encapsulates the logic needed to run the count aggregation\n * queries.\n */\nvar Rn = /*#__PURE__*/function () {\n  function Rn(t, e, n) {\n    _classCallCheck(this, Rn);\n    this.query = t, this.datastore = e, this.userDataWriter = n;\n  }\n  _createClass(Rn, [{\n    key: \"run\",\n    value: function run() {\n      var _this27 = this;\n      return mn(this.datastore, this.query._query).then(function (t) {\n        E(void 0 !== t[0]);\n        var e = Object.entries(t[0]).filter(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n            t = _ref8[0],\n            e = _ref8[1];\n          return \"count_alias\" === t;\n        }).map(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 2),\n            t = _ref10[0],\n            e = _ref10[1];\n          return _this27.userDataWriter.convertValue(e);\n        })[0];\n        return E(\"number\" == typeof e), Promise.resolve(new An(_this27.query, {\n          count: e\n        }));\n      });\n    }\n  }]);\n  return Rn;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentReference` refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist.\n */\nvar Pn = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function Pn(t,\n  /**\n   * If provided, the `FirestoreDataConverter` associated with this instance.\n   */\n  e, n) {\n    _classCallCheck(this, Pn);\n    this.converter = e, this._key = n, /** The type of this Firestore reference. */\n    this.type = \"document\", this.firestore = t;\n  }\n  _createClass(Pn, [{\n    key: \"_path\",\n    get: function get() {\n      return this._key.path;\n    }\n    /**\n     * The document's identifier within its collection.\n     */\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._key.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     */\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this._key.path.canonicalString();\n    }\n    /**\n     * The collection this `DocumentReference` belongs to.\n     */\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return new $n(this.firestore, this.converter, this._key.path.popLast());\n    }\n  }, {\n    key: \"withConverter\",\n    value: function withConverter(t) {\n      return new Pn(this.firestore, t, this._key);\n    }\n  }]);\n  return Pn;\n}();\n/**\n * A `Query` refers to a query which you can read or listen to. You can also\n * construct refined `Query` objects by adding filters and ordering.\n */\nvar Vn = /*#__PURE__*/function () {\n  // This is the lite version of the Query class in the main SDK.\n  /** @hideconstructor protected */\n  function Vn(t,\n  /**\n   * If provided, the `FirestoreDataConverter` associated with this instance.\n   */\n  e, n) {\n    _classCallCheck(this, Vn);\n    this.converter = e, this._query = n, /** The type of this Firestore reference. */\n    this.type = \"query\", this.firestore = t;\n  }\n  _createClass(Vn, [{\n    key: \"withConverter\",\n    value: function withConverter(t) {\n      return new Vn(this.firestore, t, this._query);\n    }\n  }]);\n  return Vn;\n}();\n/**\n * A `CollectionReference` object can be used for adding documents, getting\n * document references, and querying for documents (using {@link query}).\n */\nvar $n = /*#__PURE__*/function (_Vn) {\n  _inherits($n, _Vn);\n  var _super23 = _createSuper($n);\n  /** @hideconstructor */\n  function $n(t, e, n) {\n    var _this28;\n    _classCallCheck(this, $n);\n    _this28 = _super23.call(this, t, e, new ye(n)), _this28._path = n, /** The type of this Firestore reference. */\n    _this28.type = \"collection\";\n    return _this28;\n  }\n  /** The collection's identifier. */\n  _createClass($n, [{\n    key: \"id\",\n    get: function get() {\n      return this._query.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     */\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this._query.path.canonicalString();\n    }\n    /**\n     * A reference to the containing `DocumentReference` if this is a\n     * subcollection. If this isn't a subcollection, the reference is null.\n     */\n  }, {\n    key: \"parent\",\n    get: function get() {\n      var t = this._path.popLast();\n      return t.isEmpty() ? null : new Pn(this.firestore, /* converter= */null, new rt(t));\n    }\n  }, {\n    key: \"withConverter\",\n    value: function withConverter(t) {\n      return new $n(this.firestore, t, this._path);\n    }\n  }]);\n  return $n;\n}(Vn);\nfunction Nn(t, e) {\n  for (var _len5 = arguments.length, n = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    n[_key5 - 2] = arguments[_key5];\n  }\n  if (t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t), st(\"collection\", \"path\", e), t instanceof _n) {\n    var r = tt.fromString.apply(tt, [e].concat(n));\n    return ot(r), new $n(t, /* converter= */null, r);\n  }\n  {\n    if (!(t instanceof Pn || t instanceof $n)) throw new U(P, \"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore\");\n    var _r2 = t._path.child(tt.fromString.apply(tt, [e].concat(n)));\n    return ot(_r2), new $n(t.firestore, /* converter= */null, _r2);\n  }\n}\n\n// TODO(firestorelite): Consider using ErrorFactory -\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\n/**\n * Creates and returns a new `Query` instance that includes all documents in the\n * database that are contained in a collection or subcollection with the\n * given `collectionId`.\n *\n * @param firestore - A reference to the root `Firestore` instance.\n * @param collectionId - Identifies the collections to query over. Every\n * collection or subcollection with this ID as the last segment of its path\n * will be included. Cannot contain a slash.\n * @returns The created `Query`.\n */\nfunction Dn(t, e) {\n  if (t = ct(t, _n), st(\"collectionGroup\", \"collection id\", e), e.indexOf(\"/\") >= 0) throw new U(P, \"Invalid collection ID '\".concat(e, \"' passed to function collectionGroup(). Collection IDs must not contain '/'.\"));\n  return new Vn(t, /* converter= */null, function (t) {\n    return new ye(tt.emptyPath(), t);\n  }(e));\n}\nfunction Fn(t, e) {\n  for (var _len6 = arguments.length, n = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {\n    n[_key6 - 2] = arguments[_key6];\n  }\n  if (t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t),\n  // We allow omission of 'pathString' but explicitly prohibit passing in both\n  // 'undefined' and 'null'.\n  1 === arguments.length && (e = gt.N()), st(\"doc\", \"path\", e), t instanceof _n) {\n    var r = tt.fromString.apply(tt, [e].concat(n));\n    return it(r), new Pn(t, /* converter= */null, new rt(r));\n  }\n  {\n    if (!(t instanceof Pn || t instanceof $n)) throw new U(P, \"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore\");\n    var _r3 = t._path.child(tt.fromString.apply(tt, [e].concat(n)));\n    return it(_r3), new Pn(t.firestore, t instanceof $n ? t.converter : null, new rt(_r3));\n  }\n}\n\n/**\n * Returns true if the provided references are equal.\n *\n * @param left - A reference to compare.\n * @param right - A reference to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction xn(t, e) {\n  return t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t), e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e), (t instanceof Pn || t instanceof $n) && (e instanceof Pn || e instanceof $n) && t.firestore === e.firestore && t.path === e.path && t.converter === e.converter;\n}\n\n/**\n * Returns true if the provided queries point to the same collection and apply\n * the same constraints.\n *\n * @param left - A `Query` to compare.\n * @param right - A `Query` to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction Sn(t, e) {\n  return t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t), e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e), t instanceof Vn && e instanceof Vn && t.firestore === e.firestore && Te(t._query, e._query) && t.converter === e.converter;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing an array of bytes.\n */\nvar qn = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function qn(t) {\n    _classCallCheck(this, qn);\n    this._byteString = t;\n  }\n  /**\n   * Creates a new `Bytes` object from the given Base64 string, converting it to\n   * bytes.\n   *\n   * @param base64 - The Base64 string used to create the `Bytes` object.\n   */\n  _createClass(qn, [{\n    key: \"toBase64\",\n    value:\n    /**\n     * Returns the underlying bytes as a Base64-encoded string.\n     *\n     * @returns The Base64-encoded string created from the `Bytes` object.\n     */\n    function toBase64() {\n      return this._byteString.toBase64();\n    }\n    /**\n     * Returns the underlying bytes in a new `Uint8Array`.\n     *\n     * @returns The Uint8Array created from the `Bytes` object.\n     */\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      return this._byteString.toUint8Array();\n    }\n    /**\n     * Returns a string representation of the `Bytes` object.\n     *\n     * @returns A string representation of the `Bytes` object.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Bytes(base64: \" + this.toBase64() + \")\";\n    }\n    /**\n     * Returns true if this `Bytes` object is equal to the provided one.\n     *\n     * @param other - The `Bytes` object to compare against.\n     * @returns true if this `Bytes` object is equal to the provided one.\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this._byteString.isEqual(t._byteString);\n    }\n  }], [{\n    key: \"fromBase64String\",\n    value: function fromBase64String(t) {\n      try {\n        return new qn(It.fromBase64String(t));\n      } catch (t) {\n        throw new U(P, \"Failed to construct data from Base64 string: \" + t);\n      }\n    }\n    /**\n     * Creates a new `Bytes` object from the given Uint8Array.\n     *\n     * @param array - The Uint8Array used to create the `Bytes` object.\n     */\n  }, {\n    key: \"fromUint8Array\",\n    value: function fromUint8Array(t) {\n      return new qn(It.fromUint8Array(t));\n    }\n  }]);\n  return qn;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `FieldPath` refers to a field in a document. The path may consist of a\n * single field name (referring to a top-level field in the document), or a\n * list of field names (referring to a nested field in the document).\n *\n * Create a `FieldPath` by providing field names. If more than one field\n * name is provided, the path will point to a nested field in a document.\n */\nvar On = /*#__PURE__*/function () {\n  /**\n   * Creates a `FieldPath` from the provided field names. If more than one field\n   * name is provided, the path will point to a nested field in a document.\n   *\n   * @param fieldNames - A list of field names.\n   */\n  function On() {\n    _classCallCheck(this, On);\n    for (var _len7 = arguments.length, t = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      t[_key7] = arguments[_key7];\n    }\n    for (var e = 0; e < t.length; ++e) {\n      if (0 === t[e].length) throw new U(P, \"Invalid field name at argument $(i + 1). Field names must not be empty.\");\n    }\n    this._internalPath = new nt(t);\n  }\n  /**\n   * Returns true if this `FieldPath` is equal to the provided one.\n   *\n   * @param other - The `FieldPath` to compare against.\n   * @returns true if this `FieldPath` is equal to the provided one.\n   */\n  _createClass(On, [{\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this._internalPath.isEqual(t._internalPath);\n    }\n  }]);\n  return On;\n}();\n/**\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\n * It can be used in queries to sort or filter by the document ID.\n */\nfunction kn() {\n  return new On(\"__name__\");\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sentinel values that can be used when writing document fields with `set()`\n * or `update()`.\n */\nvar Cn = /*#__PURE__*/_createClass(\n/**\n * @param _methodName - The public API endpoint that returns this class.\n * @hideconstructor\n */\nfunction Cn(t) {\n  _classCallCheck(this, Cn);\n  this._methodName = t;\n});\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing a geographic location in Firestore. The\n * location is represented as latitude/longitude pair.\n *\n * Latitude values are in the range of [-90, 90].\n * Longitude values are in the range of [-180, 180].\n */\nvar Ln = /*#__PURE__*/function () {\n  /**\n   * Creates a new immutable `GeoPoint` object with the provided latitude and\n   * longitude values.\n   * @param latitude - The latitude as number between -90 and 90.\n   * @param longitude - The longitude as number between -180 and 180.\n   */\n  function Ln(t, e) {\n    _classCallCheck(this, Ln);\n    if (!isFinite(t) || t < -90 || t > 90) throw new U(P, \"Latitude must be a number between -90 and 90, but was: \" + t);\n    if (!isFinite(e) || e < -180 || e > 180) throw new U(P, \"Longitude must be a number between -180 and 180, but was: \" + e);\n    this._lat = t, this._long = e;\n  }\n  /**\n   * The latitude of this `GeoPoint` instance.\n   */\n  _createClass(Ln, [{\n    key: \"latitude\",\n    get: function get() {\n      return this._lat;\n    }\n    /**\n     * The longitude of this `GeoPoint` instance.\n     */\n  }, {\n    key: \"longitude\",\n    get: function get() {\n      return this._long;\n    }\n    /**\n     * Returns true if this `GeoPoint` is equal to the provided one.\n     *\n     * @param other - The `GeoPoint` to compare against.\n     * @returns true if this `GeoPoint` is equal to the provided one.\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return this._lat === t._lat && this._long === t._long;\n    }\n    /** Returns a JSON-serializable representation of this GeoPoint. */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        latitude: this._lat,\n        longitude: this._long\n      };\n    }\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n  }, {\n    key: \"_compareTo\",\n    value: function _compareTo(t) {\n      return _t(this._lat, t._lat) || _t(this._long, t._long);\n    }\n  }]);\n  return Ln;\n}();\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Mn = /^__.*__$/;\n\n/** The result of parsing document data (e.g. for a setData call). */\nvar Un = /*#__PURE__*/function () {\n  function Un(t, e, n) {\n    _classCallCheck(this, Un);\n    this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n  }\n  _createClass(Un, [{\n    key: \"toMutation\",\n    value: function toMutation(t, e) {\n      return null !== this.fieldMask ? new qe(t, this.data, this.fieldMask, e, this.fieldTransforms) : new Se(t, this.data, e, this.fieldTransforms);\n    }\n  }]);\n  return Un;\n}();\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nvar jn = /*#__PURE__*/function () {\n  function jn(t,\n  // The fieldMask does not include document transforms.\n  e, n) {\n    _classCallCheck(this, jn);\n    this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n  }\n  _createClass(jn, [{\n    key: \"toMutation\",\n    value: function toMutation(t, e) {\n      return new qe(t, this.data, this.fieldMask, e, this.fieldTransforms);\n    }\n  }]);\n  return jn;\n}();\nfunction Bn(t) {\n  switch (t) {\n    case 0 /* UserDataSource.Set */:\n    // fall through\n    case 2 /* UserDataSource.MergeSet */:\n    // fall through\n    case 1 /* UserDataSource.Update */:\n      return !0;\n    case 3 /* UserDataSource.Argument */:\n    case 4 /* UserDataSource.ArrayArgument */:\n      return !1;\n    default:\n      throw b();\n  }\n}\n\n/** A \"context\" object passed around while parsing user data. */\nvar Qn = /*#__PURE__*/function () {\n  /**\n   * Initializes a ParseContext with the given source and path.\n   *\n   * @param settings - The settings for the parser.\n   * @param databaseId - The database ID of the Firestore instance.\n   * @param serializer - The serializer to use to generate the Value proto.\n   * @param ignoreUndefinedProperties - Whether to ignore undefined properties\n   * rather than throw.\n   * @param fieldTransforms - A mutable list of field transforms encountered\n   * while parsing the data.\n   * @param fieldMask - A mutable list of field paths encountered while parsing\n   * the data.\n   *\n   * TODO(b/34871131): We don't support array paths right now, so path can be\n   * null to indicate the context represents any location within an array (in\n   * which case certain features will not work and errors will be somewhat\n   * compromised).\n   */\n  function Qn(t, e, n, r, s, i) {\n    _classCallCheck(this, Qn);\n    this.settings = t, this.databaseId = e, this.C = n, this.ignoreUndefinedProperties = r,\n    // Minor hack: If fieldTransforms is undefined, we assume this is an\n    // external call and we need to validate the entire path.\n    void 0 === s && this.et(), this.fieldTransforms = s || [], this.fieldMask = i || [];\n  }\n  _createClass(Qn, [{\n    key: \"path\",\n    get: function get() {\n      return this.settings.path;\n    }\n  }, {\n    key: \"nt\",\n    get: function get() {\n      return this.settings.nt;\n    }\n    /** Returns a new context with the specified settings overwritten. */\n  }, {\n    key: \"rt\",\n    value: function rt(t) {\n      return new Qn(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.C, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\n    }\n  }, {\n    key: \"st\",\n    value: function st(t) {\n      var e;\n      var n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t),\n        r = this.rt({\n          path: n,\n          it: !1\n        });\n      return r.ot(t), r;\n    }\n  }, {\n    key: \"ut\",\n    value: function ut(t) {\n      var e;\n      var n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t),\n        r = this.rt({\n          path: n,\n          it: !1\n        });\n      return r.et(), r;\n    }\n  }, {\n    key: \"ct\",\n    value: function ct(t) {\n      // TODO(b/34871131): We don't support array paths right now; so make path\n      // undefined.\n      return this.rt({\n        path: void 0,\n        it: !0\n      });\n    }\n  }, {\n    key: \"at\",\n    value: function at(t) {\n      return hr(t, this.settings.methodName, this.settings.ht || !1, this.path, this.settings.lt);\n    }\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\n  }, {\n    key: \"contains\",\n    value: function contains(t) {\n      return void 0 !== this.fieldMask.find(function (e) {\n        return t.isPrefixOf(e);\n      }) || void 0 !== this.fieldTransforms.find(function (e) {\n        return t.isPrefixOf(e.field);\n      });\n    }\n  }, {\n    key: \"et\",\n    value: function et() {\n      // TODO(b/34871131): Remove null check once we have proper paths for fields\n      // within arrays.\n      if (this.path) for (var t = 0; t < this.path.length; t++) {\n        this.ot(this.path.get(t));\n      }\n    }\n  }, {\n    key: \"ot\",\n    value: function ot(t) {\n      if (0 === t.length) throw this.at(\"Document fields must not be empty\");\n      if (Bn(this.nt) && Mn.test(t)) throw this.at('Document fields cannot begin and end with \"__\"');\n    }\n  }]);\n  return Qn;\n}();\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nvar zn = /*#__PURE__*/function () {\n  function zn(t, e, n) {\n    _classCallCheck(this, zn);\n    this.databaseId = t, this.ignoreUndefinedProperties = e, this.C = n || an(t);\n  }\n  /** Creates a new top-level parse context. */\n  _createClass(zn, [{\n    key: \"ft\",\n    value: function ft(t, e, n) {\n      var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n      return new Qn({\n        nt: t,\n        methodName: e,\n        lt: n,\n        path: nt.emptyPath(),\n        it: !1,\n        ht: r\n      }, this.databaseId, this.C, this.ignoreUndefinedProperties);\n    }\n  }]);\n  return zn;\n}();\nfunction Wn(t) {\n  var e = t._freezeSettings(),\n    n = an(t._databaseId);\n  return new zn(t._databaseId, !!e.ignoreUndefinedProperties, n);\n}\n\n/** Parse document data from a set() call. */\nfunction Gn(t, e, n, r, s) {\n  var i = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var o = t.ft(i.merge || i.mergeFields ? 2 /* UserDataSource.MergeSet */ : 0 /* UserDataSource.Set */, e, n, s);\n  or(\"Data must be an object, but it was:\", o, r);\n  var u = sr(r, o);\n  var c, a;\n  if (i.merge) c = new fe(o.fieldMask), a = o.fieldTransforms;else if (i.mergeFields) {\n    var _t17 = [];\n    var _iterator9 = _createForOfIteratorHelper(i.mergeFields),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _r4 = _step9.value;\n        var _s2 = ur(e, _r4, n);\n        if (!o.contains(_s2)) throw new U(P, \"Field '\".concat(_s2, \"' is specified in your field mask but missing from your input data.\"));\n        lr(_t17, _s2) || _t17.push(_s2);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    c = new fe(_t17), a = o.fieldTransforms.filter(function (t) {\n      return c.covers(t.field);\n    });\n  } else c = null, a = o.fieldTransforms;\n  return new Un(new de(u), c, a);\n}\nvar Kn = /*#__PURE__*/function (_Cn) {\n  _inherits(Kn, _Cn);\n  var _super24 = _createSuper(Kn);\n  function Kn() {\n    _classCallCheck(this, Kn);\n    return _super24.apply(this, arguments);\n  }\n  _createClass(Kn, [{\n    key: \"_toFieldTransform\",\n    value: function _toFieldTransform(t) {\n      if (2 /* UserDataSource.MergeSet */ !== t.nt) throw 1 /* UserDataSource.Update */ === t.nt ? t.at(\"\".concat(this._methodName, \"() can only appear at the top level of your update data\")) : t.at(\"\".concat(this._methodName, \"() cannot be used with set() unless you pass {merge:true}\"));\n      // No transform to add for a delete, but we need to add it to our\n      // fieldMask so it gets deleted.\n      return t.fieldMask.push(t.path), null;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return t instanceof Kn;\n    }\n  }]);\n  return Kn;\n}(Cn);\n/**\n * Creates a child context for parsing SerializableFieldValues.\n *\n * This is different than calling `ParseContext.contextWith` because it keeps\n * the fieldTransforms and fieldMask separate.\n *\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\n * Although these values are used with writes, any elements in these FieldValues\n * are not considered writes since they cannot contain any FieldValue sentinels,\n * etc.\n *\n * @param fieldValue - The sentinel FieldValue for which to create a child\n *     context.\n * @param context - The parent context.\n * @param arrayElement - Whether or not the FieldValue has an array.\n */\nfunction Yn(t, e, n) {\n  return new Qn({\n    nt: 3 /* UserDataSource.Argument */,\n    lt: e.settings.lt,\n    methodName: t._methodName,\n    it: n\n  }, e.databaseId, e.C, e.ignoreUndefinedProperties);\n}\nvar Hn = /*#__PURE__*/function (_Cn2) {\n  _inherits(Hn, _Cn2);\n  var _super25 = _createSuper(Hn);\n  function Hn() {\n    _classCallCheck(this, Hn);\n    return _super25.apply(this, arguments);\n  }\n  _createClass(Hn, [{\n    key: \"_toFieldTransform\",\n    value: function _toFieldTransform(t) {\n      return new De(t.path, new Pe());\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      return t instanceof Hn;\n    }\n  }]);\n  return Hn;\n}(Cn);\nvar Jn = /*#__PURE__*/function (_Cn3) {\n  _inherits(Jn, _Cn3);\n  var _super26 = _createSuper(Jn);\n  function Jn(t, e) {\n    var _this29;\n    _classCallCheck(this, Jn);\n    _this29 = _super26.call(this, t), _this29.dt = e;\n    return _this29;\n  }\n  _createClass(Jn, [{\n    key: \"_toFieldTransform\",\n    value: function _toFieldTransform(t) {\n      var e = Yn(this, t, /*array=*/!0),\n        n = this.dt.map(function (t) {\n          return rr(t, e);\n        }),\n        r = new Ve(n);\n      return new De(t.path, r);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      // TODO(mrschmidt): Implement isEquals\n      return this === t;\n    }\n  }]);\n  return Jn;\n}(Cn);\nvar Xn = /*#__PURE__*/function (_Cn4) {\n  _inherits(Xn, _Cn4);\n  var _super27 = _createSuper(Xn);\n  function Xn(t, e) {\n    var _this30;\n    _classCallCheck(this, Xn);\n    _this30 = _super27.call(this, t), _this30.dt = e;\n    return _this30;\n  }\n  _createClass(Xn, [{\n    key: \"_toFieldTransform\",\n    value: function _toFieldTransform(t) {\n      var e = Yn(this, t, /*array=*/!0),\n        n = this.dt.map(function (t) {\n          return rr(t, e);\n        }),\n        r = new $e(n);\n      return new De(t.path, r);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      // TODO(mrschmidt): Implement isEquals\n      return this === t;\n    }\n  }]);\n  return Xn;\n}(Cn);\nvar Zn = /*#__PURE__*/function (_Cn5) {\n  _inherits(Zn, _Cn5);\n  var _super28 = _createSuper(Zn);\n  function Zn(t, e) {\n    var _this31;\n    _classCallCheck(this, Zn);\n    _this31 = _super28.call(this, t), _this31.wt = e;\n    return _this31;\n  }\n  _createClass(Zn, [{\n    key: \"_toFieldTransform\",\n    value: function _toFieldTransform(t) {\n      var e = new Ne(t.C, Ae(t.C, this.wt));\n      return new De(t.path, e);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(t) {\n      // TODO(mrschmidt): Implement isEquals\n      return this === t;\n    }\n  }]);\n  return Zn;\n}(Cn);\n/** Parse update data from an update() call. */\nfunction tr(t, e, n, r) {\n  var s = t.ft(1 /* UserDataSource.Update */, e, n);\n  or(\"Data must be an object, but it was:\", s, r);\n  var i = [],\n    o = de.empty();\n  Et(r, function (t, r) {\n    var u = ar(e, t, n);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    r = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(r);\n    var c = s.ut(u);\n    if (r instanceof Kn)\n      // Add it to the field mask, but don't add anything to updateData.\n      i.push(u);else {\n      var _t18 = rr(r, c);\n      null != _t18 && (i.push(u), o.set(u, _t18));\n    }\n  });\n  var u = new fe(i);\n  return new jn(o, u, s.fieldTransforms);\n}\n\n/** Parse update data from a list of field/value arguments. */\nfunction er(t, e, n, r, s, i) {\n  var o = t.ft(1 /* UserDataSource.Update */, e, n),\n    u = [ur(e, r, n)],\n    c = [s];\n  if (i.length % 2 != 0) throw new U(P, \"Function \".concat(e, \"() needs to be called with an even number of arguments that alternate between field names and values.\"));\n  for (var _t19 = 0; _t19 < i.length; _t19 += 2) {\n    u.push(ur(e, i[_t19])), c.push(i[_t19 + 1]);\n  }\n  var a = [],\n    h = de.empty();\n  // We iterate in reverse order to pick the last value for a field if the\n  // user specified the field multiple times.\n  for (var _t20 = u.length - 1; _t20 >= 0; --_t20) {\n    if (!lr(a, u[_t20])) {\n      var _e14 = u[_t20];\n      var _n8 = c[_t20];\n      // For Compat types, we have to \"extract\" the underlying types before\n      // performing validation.\n      _n8 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(_n8);\n      var _r5 = o.ut(_e14);\n      if (_n8 instanceof Kn)\n        // Add it to the field mask, but don't add anything to updateData.\n        a.push(_e14);else {\n        var _t21 = rr(_n8, _r5);\n        null != _t21 && (a.push(_e14), h.set(_e14, _t21));\n      }\n    }\n  }\n  var f = new fe(a);\n  return new jn(h, f, o.fieldTransforms);\n}\n\n/**\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n * bound).\n *\n * @param allowArrays - Whether the query value is an array that may directly\n * contain additional arrays (e.g. the operand of an `in` query).\n */\nfunction nr(t, e, n) {\n  var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n  return rr(n, t.ft(r ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, e));\n}\n\n/**\n * Parses user data to Protobuf Values.\n *\n * @param input - Data to be parsed.\n * @param context - A context object representing the current path being parsed,\n * the source of the data being parsed, etc.\n * @returns The parsed value, or null if the value was a FieldValue sentinel\n * that should not be included in the resulting parsed data.\n */\nfunction rr(t, e) {\n  if (ir(\n  // Unwrap the API type from the Compat SDK. This will return the API type\n  // from firestore-exp.\n  t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t))) return or(\"Unsupported field value:\", e, t), sr(t, e);\n  if (t instanceof Cn)\n    // FieldValues usually parse into transforms (except deleteField())\n    // in which case we do not want to include this field in our parsed data\n    // (as doing so will overwrite the field directly prior to the transform\n    // trying to transform it). So we don't add this location to\n    // context.fieldMask and we return null as our parsing result.\n    /**\n    * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\n    * context.fieldTransforms.\n    */\n    return function (t, e) {\n      // Sentinels are only supported with writes, and not within arrays.\n      if (!Bn(e.nt)) throw e.at(\"\".concat(t._methodName, \"() can only be used with update() and set()\"));\n      if (!e.path) throw e.at(\"\".concat(t._methodName, \"() is not currently supported inside arrays\"));\n      var n = t._toFieldTransform(e);\n      n && e.fieldTransforms.push(n);\n    }\n    /**\n    * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\n    *\n    * @returns The parsed value\n    */(t, e), null;\n  if (void 0 === t && e.ignoreUndefinedProperties)\n    // If the input is undefined it can never participate in the fieldMask, so\n    // don't handle this below. If `ignoreUndefinedProperties` is false,\n    // `parseScalarValue` will reject an undefined value.\n    return null;\n  if (\n  // If context.path is null we are inside an array and we don't support\n  // field mask paths more granular than the top-level array.\n  e.path && e.fieldMask.push(e.path), t instanceof Array) {\n    // TODO(b/34871131): Include the path containing the array in the error\n    // message.\n    // In the case of IN queries, the parsed data is an array (representing\n    // the set of values to be included for the IN query) that may directly\n    // contain additional arrays (each representing an individual field\n    // value), so we disable this validation.\n    if (e.settings.it && 4 /* UserDataSource.ArrayArgument */ !== e.nt) throw e.at(\"Nested arrays are not supported\");\n    return function (t, e) {\n      var n = [];\n      var r = 0;\n      var _iterator10 = _createForOfIteratorHelper(t),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var s = _step10.value;\n          var _t22 = rr(s, e.ct(r));\n          null == _t22 && (\n          // Just include nulls in the array for fields being replaced with a\n          // sentinel.\n          _t22 = {\n            nullValue: \"NULL_VALUE\"\n          }), n.push(_t22), r++;\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      return {\n        arrayValue: {\n          values: n\n        }\n      };\n    }(t, e);\n  }\n  return function (t, e) {\n    if (null === (t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t))) return {\n      nullValue: \"NULL_VALUE\"\n    };\n    if (\"number\" == typeof t) return Ae(e.C, t);\n    if (\"boolean\" == typeof t) return {\n      booleanValue: t\n    };\n    if (\"string\" == typeof t) return {\n      stringValue: t\n    };\n    if (t instanceof Date) {\n      var n = Vt.fromDate(t);\n      return {\n        timestampValue: je(e.C, n)\n      };\n    }\n    if (t instanceof Vt) {\n      // Firestore backend truncates precision down to microseconds. To ensure\n      // offline mode works the same with regards to truncation, perform the\n      // truncation immediately without waiting for the backend to do that.\n      var _n9 = new Vt(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3));\n      return {\n        timestampValue: je(e.C, _n9)\n      };\n    }\n    if (t instanceof Ln) return {\n      geoPointValue: {\n        latitude: t.latitude,\n        longitude: t.longitude\n      }\n    };\n    if (t instanceof qn) return {\n      bytesValue: Be(e.C, t._byteString)\n    };\n    if (t instanceof Pn) {\n      var _n10 = e.databaseId,\n        r = t.firestore._databaseId;\n      if (!r.isEqual(_n10)) throw e.at(\"Document reference is for database \".concat(r.projectId, \"/\").concat(r.database, \" but should be for database \").concat(_n10.projectId, \"/\").concat(_n10.database));\n      return {\n        referenceValue: We(t.firestore._databaseId || e.databaseId, t._key.path)\n      };\n    }\n    throw e.at(\"Unsupported field value: \".concat(ut(t)));\n  }\n  /**\n  * Checks whether an object looks like a JSON object that should be converted\n  * into a struct. Normal class/prototype instances are considered to look like\n  * JSON objects since they should be converted to a struct value. Arrays, Dates,\n  * GeoPoints, etc. are not considered to look like JSON objects since they map\n  * to specific FieldValue types other than ObjectValue.\n  */(t, e);\n}\nfunction sr(t, e) {\n  var n = {};\n  return !function (t) {\n    for (var _e15 in t) {\n      if (Object.prototype.hasOwnProperty.call(t, _e15)) return !1;\n    }\n    return !0;\n  }\n  /**\n  * @license\n  * Copyright 2020 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n  /** Converts a Base64 encoded string to a binary string. */(t) ? Et(t, function (t, r) {\n    var s = rr(r, e.st(t));\n    null != s && (n[t] = s);\n  }) :\n  // If we encounter an empty object, we explicitly add it to the update\n  // mask to ensure that the server creates a map entry.\n  e.path && e.path.length > 0 && e.fieldMask.push(e.path), {\n    mapValue: {\n      fields: n\n    }\n  };\n}\nfunction ir(t) {\n  return !(\"object\" != _typeof(t) || null === t || t instanceof Array || t instanceof Date || t instanceof Vt || t instanceof Ln || t instanceof qn || t instanceof Pn || t instanceof Cn);\n}\nfunction or(t, e, n) {\n  if (!ir(n) || !function (t) {\n    return \"object\" == _typeof(t) && null !== t && (Object.getPrototypeOf(t) === Object.prototype || null === Object.getPrototypeOf(t));\n  }(n)) {\n    var r = ut(n);\n    throw \"an object\" === r ? e.at(t + \" a custom object\") : e.at(t + \" \" + r);\n  }\n}\n\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction ur(t, e, n) {\n  if ((\n  // If required, replace the FieldPath Compat class with with the firestore-exp\n  // FieldPath.\n  e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e)) instanceof On) return e._internalPath;\n  if (\"string\" == typeof e) return ar(t, e);\n  throw hr(\"Field path arguments must be of type string or \", t, /* hasConverter= */!1, /* path= */void 0, n);\n}\n\n/**\n * Matches any characters in a field path string that are reserved.\n */\nvar cr = new RegExp(\"[~\\\\*/\\\\[\\\\]]\");\n\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName - The publicly visible method name\n * @param path - The dot-separated string form of a field path which will be\n * split on dots.\n * @param targetDoc - The document against which the field path will be\n * evaluated.\n */\nfunction ar(t, e, n) {\n  if (e.search(cr) >= 0) throw hr(\"Invalid field path (\".concat(e, \"). Paths must not contain '~', '*', '/', '[', or ']'\"), t, /* hasConverter= */!1, /* path= */void 0, n);\n  try {\n    return _construct(On, _toConsumableArray(e.split(\".\")))._internalPath;\n  } catch (r) {\n    throw hr(\"Invalid field path (\".concat(e, \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\"), t, /* hasConverter= */!1, /* path= */void 0, n);\n  }\n}\nfunction hr(t, e, n, r, s) {\n  var i = r && !r.isEmpty(),\n    o = void 0 !== s;\n  var u = \"Function \".concat(e, \"() called with invalid data\");\n  n && (u += \" (via `toFirestore()`)\"), u += \". \";\n  var c = \"\";\n  return (i || o) && (c += \" (found\", i && (c += \" in field \".concat(r)), o && (c += \" in document \".concat(s)), c += \")\"), new U(P, u + t + c);\n}\n\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\nfunction lr(t, e) {\n  return t.some(function (t) {\n    return t.isEqual(e);\n  });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nvar fr = /*#__PURE__*/function () {\n  // Note: This class is stripped down version of the DocumentSnapshot in\n  // the legacy SDK. The changes are:\n  // - No support for SnapshotMetadata.\n  // - No support for SnapshotOptions.\n  /** @hideconstructor protected */\n  function fr(t, e, n, r, s) {\n    _classCallCheck(this, fr);\n    this._firestore = t, this._userDataWriter = e, this._key = n, this._document = r, this._converter = s;\n  }\n  /** Property of the `DocumentSnapshot` that provides the document's ID. */\n  _createClass(fr, [{\n    key: \"id\",\n    get: function get() {\n      return this._key.path.lastSegment();\n    }\n    /**\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n     */\n  }, {\n    key: \"ref\",\n    get: function get() {\n      return new Pn(this._firestore, this._converter, this._key);\n    }\n    /**\n     * Signals whether or not the document at the snapshot's location exists.\n     *\n     * @returns true if the document exists.\n     */\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      return null !== this._document;\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * @returns An `Object` containing all fields in the document or `undefined`\n     * if the document doesn't exist.\n     */\n  }, {\n    key: \"data\",\n    value: function data() {\n      if (this._document) {\n        if (this._converter) {\n          // We only want to use the converter and create a new DocumentSnapshot\n          // if a converter has been provided.\n          var t = new dr(this._firestore, this._userDataWriter, this._key, this._document, /* converter= */null);\n          return this._converter.fromFirestore(t);\n        }\n        return this._userDataWriter.convertValue(this._document.data.value);\n      }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      if (this._document) {\n        var e = this._document.data.field(pr(\"DocumentSnapshot.get\", t));\n        if (null !== e) return this._userDataWriter.convertValue(e);\n      }\n    }\n  }]);\n  return fr;\n}();\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nvar dr = /*#__PURE__*/function (_fr) {\n  _inherits(dr, _fr);\n  var _super29 = _createSuper(dr);\n  function dr() {\n    _classCallCheck(this, dr);\n    return _super29.apply(this, arguments);\n  }\n  _createClass(dr, [{\n    key: \"data\",\n    value:\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * @override\n     * @returns An `Object` containing all fields in the document.\n     */\n    function data() {\n      return _get(_getPrototypeOf(dr.prototype), \"data\", this).call(this);\n    }\n  }]);\n  return dr;\n}(fr);\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nvar wr = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function wr(t, e) {\n    _classCallCheck(this, wr);\n    this._docs = e, this.query = t;\n  }\n  /** An array of all the documents in the `QuerySnapshot`. */\n  _createClass(wr, [{\n    key: \"docs\",\n    get: function get() {\n      return _toConsumableArray(this._docs);\n    }\n    /** The number of documents in the `QuerySnapshot`. */\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.docs.length;\n    }\n    /** True if there are no documents in the `QuerySnapshot`. */\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return 0 === this.docs.length;\n    }\n    /**\n     * Enumerates all of the documents in the `QuerySnapshot`.\n     *\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n     * each document in the snapshot.\n     * @param thisArg - The `this` binding for the callback.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(t, e) {\n      this._docs.forEach(t, e);\n    }\n  }]);\n  return wr;\n}();\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nfunction mr(t, e) {\n  return t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t), e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e), t instanceof fr && e instanceof fr ? t._firestore === e._firestore && t._key.isEqual(e._key) && (null === t._document ? null === e._document : t._document.isEqual(e._document)) && t._converter === e._converter : t instanceof wr && e instanceof wr && Sn(t.query, e.query) && vt(t.docs, e.docs, mr);\n}\n\n/**\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\n */\nfunction pr(t, e) {\n  return \"string\" == typeof e ? ar(t, e) : e instanceof On ? e._internalPath : e._delegate._internalPath;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nvar yr = /*#__PURE__*/_createClass(function yr() {\n  _classCallCheck(this, yr);\n});\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link startAt}, {@link startAfter}, {@link\n * endBefore}, {@link endAt}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link query} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nvar gr = /*#__PURE__*/function (_yr) {\n  _inherits(gr, _yr);\n  var _super30 = _createSuper(gr);\n  function gr() {\n    _classCallCheck(this, gr);\n    return _super30.apply(this, arguments);\n  }\n  return _createClass(gr);\n}(yr);\nfunction _r(t, e) {\n  var r = [];\n  for (var _len8 = arguments.length, n = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n    n[_key8 - 2] = arguments[_key8];\n  }\n  e instanceof yr && r.push(e), r = r.concat(n), function (t) {\n    var e = t.filter(function (t) {\n        return t instanceof Er;\n      }).length,\n      n = t.filter(function (t) {\n        return t instanceof vr;\n      }).length;\n    if (e > 1 || e > 0 && n > 0) throw new U(P, \"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.\");\n  }\n  /**\n  * @license\n  * Copyright 2020 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n  /**\n  * Converts Firestore's internal types to the JavaScript types that we expose\n  * to the user.\n  *\n  * @internal\n  */(r);\n  var _iterator11 = _createForOfIteratorHelper(r),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _e16 = _step11.value;\n      t = _e16._apply(t);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  return t;\n}\n\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link query} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nvar vr = /*#__PURE__*/function (_gr) {\n  _inherits(vr, _gr);\n  var _super31 = _createSuper(vr);\n  /**\n   * @internal\n   */\n  function vr(t, e, n) {\n    var _this32;\n    _classCallCheck(this, vr);\n    _this32 = _super31.call(this), _this32._field = t, _this32._op = e, _this32._value = n, /** The type of this query constraint */\n    _this32.type = \"where\";\n    return _this32;\n  }\n  _createClass(vr, [{\n    key: \"_apply\",\n    value: function _apply(t) {\n      var e = this._parse(t);\n      return Lr(t._query, e), new Vn(t.firestore, t.converter, Ie(t._query, e));\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(t) {\n      var e = Wn(t.firestore),\n        n = function (t, e, n, r, s, i, o) {\n          var u;\n          if (s.isKeyField()) {\n            if (\"array-contains\" /* Operator.ARRAY_CONTAINS */ === i || \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ === i) throw new U(P, \"Invalid Query. You can't perform '\".concat(i, \"' queries on documentId().\"));\n            if (\"in\" /* Operator.IN */ === i || \"not-in\" /* Operator.NOT_IN */ === i) {\n              Cr(o, i);\n              var _e17 = [];\n              var _iterator12 = _createForOfIteratorHelper(o),\n                _step12;\n              try {\n                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                  var _n11 = _step12.value;\n                  _e17.push(kr(r, t, _n11));\n                }\n              } catch (err) {\n                _iterator12.e(err);\n              } finally {\n                _iterator12.f();\n              }\n              u = {\n                arrayValue: {\n                  values: _e17\n                }\n              };\n            } else u = kr(r, t, o);\n          } else \"in\" /* Operator.IN */ !== i && \"not-in\" /* Operator.NOT_IN */ !== i && \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ !== i || Cr(o, i), u = nr(n, e, o, /* allowArrays= */\"in\" /* Operator.IN */ === i || \"not-in\" /* Operator.NOT_IN */ === i);\n          return Gt.create(s, i, u);\n        }(t._query, \"where\", e, t.firestore._databaseId, this._field, this._op, this._value);\n      return n;\n    }\n  }], [{\n    key: \"_create\",\n    value: function _create(t, e, n) {\n      return new vr(t, e, n);\n    }\n  }]);\n  return vr;\n}(gr);\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nfunction br(t, e, n) {\n  var r = e,\n    s = pr(\"where\", t);\n  return vr._create(s, r, n);\n}\n\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link query} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n * @internal TODO remove this internal tag with OR Query support in the server\n */\nvar Er = /*#__PURE__*/function (_yr2) {\n  _inherits(Er, _yr2);\n  var _super32 = _createSuper(Er);\n  /**\n   * @internal\n   */\n  function Er( /** The type of this query constraint */\n  t, e) {\n    var _this33;\n    _classCallCheck(this, Er);\n    _this33 = _super32.call(this), _this33.type = t, _this33._queryConstraints = e;\n    return _this33;\n  }\n  _createClass(Er, [{\n    key: \"_parse\",\n    value: function _parse(t) {\n      var e = this._queryConstraints.map(function (e) {\n        return e._parse(t);\n      }).filter(function (t) {\n        return t.getFilters().length > 0;\n      });\n      return 1 === e.length ? e[0] : Kt.create(e, this._getOperator());\n    }\n  }, {\n    key: \"_apply\",\n    value: function _apply(t) {\n      var e = this._parse(t);\n      return 0 === e.getFilters().length ? t : (function (t, e) {\n        var n = t;\n        var r = e.getFlattenedFilters();\n        var _iterator13 = _createForOfIteratorHelper(r),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var _t23 = _step13.value;\n            Lr(n, _t23), n = Ie(n, _t23);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n      // Checks if any of the provided filter operators are included in the given list of filters and\n      // returns the first one that is, or null if none are.\n      (t._query, e), new Vn(t.firestore, t.converter, Ie(t._query, e)));\n    }\n  }, {\n    key: \"_getQueryConstraints\",\n    value: function _getQueryConstraints() {\n      return this._queryConstraints;\n    }\n  }, {\n    key: \"_getOperator\",\n    value: function _getOperator() {\n      return \"and\" === this.type ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\n    }\n  }], [{\n    key: \"_create\",\n    value: function _create(t, e) {\n      return new Er(t, e);\n    }\n  }]);\n  return Er;\n}(yr);\n/**\n * Creates a {@link QueryCompositeFilterConstraint} that performs a logical OR\n * of all the provided {@link QueryFilterConstraint}s.\n *\n * @param queryConstraints - Optional. The {@link QueryFilterConstraint}s\n * for OR operation. These must be created with calls to {@link where},\n * {@link or}, or {@link and}.\n * @returns The created {@link QueryCompositeFilterConstraint}.\n * @internal TODO remove this internal tag with OR Query support in the server\n */\nfunction Ir() {\n  for (var _len9 = arguments.length, t = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    t[_key9] = arguments[_key9];\n  }\n  // Only support QueryFilterConstraints\n  return t.forEach(function (t) {\n    return Ur(\"or\", t);\n  }), Er._create(\"or\" /* CompositeOperator.OR */, t);\n}\n\n/**\n * Creates a {@link QueryCompositeFilterConstraint} that performs a logical AND\n * of all the provided {@link QueryFilterConstraint}s.\n *\n * @param queryConstraints - Optional. The {@link QueryFilterConstraint}s\n * for AND operation. These must be created with calls to {@link where},\n * {@link or}, or {@link and}.\n * @returns The created {@link QueryCompositeFilterConstraint}.\n * @internal TODO remove this internal tag with OR Query support in the server\n */\nfunction Tr() {\n  for (var _len10 = arguments.length, t = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    t[_key10] = arguments[_key10];\n  }\n  // Only support QueryFilterConstraints\n  return t.forEach(function (t) {\n    return Ur(\"and\", t);\n  }), Er._create(\"and\" /* CompositeOperator.AND */, t);\n}\n\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link query} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nvar Ar = /*#__PURE__*/function (_gr2) {\n  _inherits(Ar, _gr2);\n  var _super33 = _createSuper(Ar);\n  /**\n   * @internal\n   */\n  function Ar(t, e) {\n    var _this34;\n    _classCallCheck(this, Ar);\n    _this34 = _super33.call(this), _this34._field = t, _this34._direction = e, /** The type of this query constraint */\n    _this34.type = \"orderBy\";\n    return _this34;\n  }\n  _createClass(Ar, [{\n    key: \"_apply\",\n    value: function _apply(t) {\n      var e = function (t, e, n) {\n        if (null !== t.startAt) throw new U(P, \"Invalid query. You must not call startAt() or startAfter() before calling orderBy().\");\n        if (null !== t.endAt) throw new U(P, \"Invalid query. You must not call endAt() or endBefore() before calling orderBy().\");\n        var r = new se(e, n);\n        return function (t, e) {\n          if (null === ge(t)) {\n            // This is the first order by. It must match any inequality.\n            var _n12 = _e(t);\n            null !== _n12 && Mr(t, _n12, e.field);\n          }\n        }(t, r), r;\n      }\n      /**\n      * Create a `Bound` from a query and a document.\n      *\n      * Note that the `Bound` will always include the key of the document\n      * and so only the provided document will compare equal to the returned\n      * position.\n      *\n      * Will throw if the document does not contain all fields of the order by\n      * of the query or if any of the fields in the order by are an uncommitted\n      * server timestamp.\n      */(t._query, this._field, this._direction);\n      return new Vn(t.firestore, t.converter, function (t, e) {\n        // TODO(dimond): validate that orderBy does not list the same key twice.\n        var n = t.explicitOrderBy.concat([e]);\n        return new ye(t.path, t.collectionGroup, n, t.filters.slice(), t.limit, t.limitType, t.startAt, t.endAt);\n      }(t._query, e));\n    }\n  }], [{\n    key: \"_create\",\n    value: function _create(t, e) {\n      return new Ar(t, e);\n    }\n  }]);\n  return Ar;\n}(gr);\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nfunction Rr(t) {\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"asc\";\n  var n = e,\n    r = pr(\"orderBy\", t);\n  return Ar._create(r, n);\n}\n\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link query} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nvar Pr = /*#__PURE__*/function (_gr3) {\n  _inherits(Pr, _gr3);\n  var _super34 = _createSuper(Pr);\n  /**\n   * @internal\n   */\n  function Pr( /** The type of this query constraint */\n  t, e, n) {\n    var _this35;\n    _classCallCheck(this, Pr);\n    _this35 = _super34.call(this), _this35.type = t, _this35._limit = e, _this35._limitType = n;\n    return _this35;\n  }\n  _createClass(Pr, [{\n    key: \"_apply\",\n    value: function _apply(t) {\n      return new Vn(t.firestore, t.converter, function (t, e, n) {\n        return new ye(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), e, n, t.startAt, t.endAt);\n      }(t._query, this._limit, this._limitType));\n    }\n  }], [{\n    key: \"_create\",\n    value: function _create(t, e, n) {\n      return new Pr(t, e, n);\n    }\n  }]);\n  return Pr;\n}(gr);\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction Vr(t) {\n  return at(\"limit\", t), Pr._create(\"limit\", t, \"F\" /* LimitType.First */);\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction $r(t) {\n  return at(\"limitToLast\", t), Pr._create(\"limitToLast\", t, \"L\" /* LimitType.Last */);\n}\n\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link query} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nvar Nr = /*#__PURE__*/function (_gr4) {\n  _inherits(Nr, _gr4);\n  var _super35 = _createSuper(Nr);\n  /**\n   * @internal\n   */\n  function Nr( /** The type of this query constraint */\n  t, e, n) {\n    var _this36;\n    _classCallCheck(this, Nr);\n    _this36 = _super35.call(this), _this36.type = t, _this36._docOrFields = e, _this36._inclusive = n;\n    return _this36;\n  }\n  _createClass(Nr, [{\n    key: \"_apply\",\n    value: function _apply(t) {\n      var e = Or(t, this.type, this._docOrFields, this._inclusive);\n      return new Vn(t.firestore, t.converter, function (t, e) {\n        return new ye(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), t.limit, t.limitType, e, t.endAt);\n      }(t._query, e));\n    }\n  }], [{\n    key: \"_create\",\n    value: function _create(t, e, n) {\n      return new Nr(t, e, n);\n    }\n  }]);\n  return Nr;\n}(gr);\nfunction Dr() {\n  for (var _len11 = arguments.length, t = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n    t[_key11] = arguments[_key11];\n  }\n  return Nr._create(\"startAt\", t, /*inclusive=*/!0);\n}\nfunction Fr() {\n  for (var _len12 = arguments.length, t = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    t[_key12] = arguments[_key12];\n  }\n  return Nr._create(\"startAfter\", t, /*inclusive=*/!1);\n}\n\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link query} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nvar xr = /*#__PURE__*/function (_gr5) {\n  _inherits(xr, _gr5);\n  var _super36 = _createSuper(xr);\n  /**\n   * @internal\n   */\n  function xr( /** The type of this query constraint */\n  t, e, n) {\n    var _this37;\n    _classCallCheck(this, xr);\n    _this37 = _super36.call(this), _this37.type = t, _this37._docOrFields = e, _this37._inclusive = n;\n    return _this37;\n  }\n  _createClass(xr, [{\n    key: \"_apply\",\n    value: function _apply(t) {\n      var e = Or(t, this.type, this._docOrFields, this._inclusive);\n      return new Vn(t.firestore, t.converter, function (t, e) {\n        return new ye(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), t.limit, t.limitType, t.startAt, e);\n      }(t._query, e));\n    }\n  }], [{\n    key: \"_create\",\n    value: function _create(t, e, n) {\n      return new xr(t, e, n);\n    }\n  }]);\n  return xr;\n}(gr);\nfunction Sr() {\n  for (var _len13 = arguments.length, t = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n    t[_key13] = arguments[_key13];\n  }\n  return xr._create(\"endBefore\", t, /*inclusive=*/!1);\n}\nfunction qr() {\n  for (var _len14 = arguments.length, t = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n    t[_key14] = arguments[_key14];\n  }\n  return xr._create(\"endAt\", t, /*inclusive=*/!0);\n}\n\n/** Helper function to create a bound from a document or fields */\nfunction Or(t, e, n, r) {\n  if (n[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(n[0]), n[0] instanceof fr) return function (t, e, n, r, s) {\n    if (!r) throw new U($, \"Can't use a DocumentSnapshot that doesn't exist for \".concat(n, \"().\"));\n    var i = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    var _iterator14 = _createForOfIteratorHelper(be(t)),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var _n13 = _step14.value;\n        if (_n13.field.isKeyField()) i.push(Ct(e, r.key));else {\n          var _t24 = r.data.field(_n13.field);\n          if ($t(_t24)) throw new U(P, 'Invalid query. You are trying to start or end a query using a document for which the field \"' + _n13.field + '\" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');\n          if (null === _t24) {\n            var _t25 = _n13.field.canonicalString();\n            throw new U(P, \"Invalid query. You are trying to start or end a query using a document for which the field '\".concat(_t25, \"' (used as the orderBy) does not exist.\"));\n          }\n          i.push(_t24);\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    return new Qt(i, s);\n  }\n  /**\n  * Converts a list of field values to a `Bound` for the given query.\n  */(t._query, t.firestore._databaseId, e, n[0]._document, r);\n  {\n    var s = Wn(t.firestore);\n    return function (t, e, n, r, s, i) {\n      // Use explicit order by's because it has to match the query the user made\n      var o = t.explicitOrderBy;\n      if (s.length > o.length) throw new U(P, \"Too many arguments provided to \".concat(r, \"(). The number of arguments must be less than or equal to the number of orderBy() clauses\"));\n      var u = [];\n      for (var _i3 = 0; _i3 < s.length; _i3++) {\n        var c = s[_i3];\n        if (o[_i3].field.isKeyField()) {\n          if (\"string\" != typeof c) throw new U(P, \"Invalid query. Expected a string for document ID in \".concat(r, \"(), but got a \").concat(_typeof(c)));\n          if (!ve(t) && -1 !== c.indexOf(\"/\")) throw new U(P, \"Invalid query. When querying a collection and ordering by documentId(), the value passed to \".concat(r, \"() must be a plain document ID, but '\").concat(c, \"' contains a slash.\"));\n          var _n14 = t.path.child(tt.fromString(c));\n          if (!rt.isDocumentKey(_n14)) throw new U(P, \"Invalid query. When querying a collection group and ordering by documentId(), the value passed to \".concat(r, \"() must result in a valid document path, but '\").concat(_n14, \"' is not because it contains an odd number of segments.\"));\n          var _s3 = new rt(_n14);\n          u.push(Ct(e, _s3));\n        } else {\n          var _t26 = nr(n, r, c);\n          u.push(_t26);\n        }\n      }\n      return new Qt(u, i);\n    }\n    /**\n    * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n    * appropriate errors if the value is anything other than a `DocumentReference`\n    * or `string`, or if the string is malformed.\n    */(t._query, t.firestore._databaseId, s, e, n, r);\n  }\n}\nfunction kr(t, e, n) {\n  if (\"string\" == typeof (n = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(n))) {\n    if (\"\" === n) throw new U(P, \"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.\");\n    if (!ve(e) && -1 !== n.indexOf(\"/\")) throw new U(P, \"Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '\".concat(n, \"' contains a '/' character.\"));\n    var r = e.path.child(tt.fromString(n));\n    if (!rt.isDocumentKey(r)) throw new U(P, \"Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '\".concat(r, \"' is not because it has an odd number of segments (\").concat(r.length, \").\"));\n    return Ct(t, new rt(r));\n  }\n  if (n instanceof Pn) return Ct(t, n._key);\n  throw new U(P, \"Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: \".concat(ut(n), \".\"));\n}\n\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction Cr(t, e) {\n  if (!Array.isArray(t) || 0 === t.length) throw new U(P, \"Invalid Query. A non-empty array is required for '\".concat(e.toString(), \"' filters.\"));\n  if (t.length > 10) throw new U(P, \"Invalid Query. '\".concat(e.toString(), \"' filters support a maximum of 10 elements in the value array.\"));\n}\n\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one array operator is allowed.\n * 2. Only one disjunctive operator is allowed.\n * 3. `NOT_EQUAL` cannot be used with another `NOT_EQUAL` operator.\n * 4. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n *\n * Array operators: `ARRAY_CONTAINS`, `ARRAY_CONTAINS_ANY`\n * Disjunctive operators: `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`\n */\nfunction Lr(t, e) {\n  if (e.isInequality()) {\n    var _n15 = _e(t),\n      r = e.field;\n    if (null !== _n15 && !_n15.isEqual(r)) throw new U(P, \"Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '\".concat(_n15.toString(), \"' and '\").concat(r.toString(), \"'\"));\n    var s = ge(t);\n    null !== s && Mr(t, r, s);\n  }\n  var n = function (t, e) {\n    var _iterator15 = _createForOfIteratorHelper(t),\n      _step15;\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var _n16 = _step15.value;\n        var _iterator16 = _createForOfIteratorHelper(_n16.getFlattenedFilters()),\n          _step16;\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var _t27 = _step16.value;\n            if (e.indexOf(_t27.op) >= 0) return _t27.op;\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n    return null;\n  }(t.filters, function (t) {\n    switch (t) {\n      case \"!=\" /* Operator.NOT_EQUAL */:\n        return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\n\n      case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\n        return [\"array-contains\" /* Operator.ARRAY_CONTAINS */, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, \"not-in\" /* Operator.NOT_IN */];\n\n      case \"in\" /* Operator.IN */:\n        return [\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, \"in\" /* Operator.IN */, \"not-in\" /* Operator.NOT_IN */];\n\n      case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n        return [\"array-contains\" /* Operator.ARRAY_CONTAINS */, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, \"in\" /* Operator.IN */, \"not-in\" /* Operator.NOT_IN */];\n\n      case \"not-in\" /* Operator.NOT_IN */:\n        return [\"array-contains\" /* Operator.ARRAY_CONTAINS */, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, \"in\" /* Operator.IN */, \"not-in\" /* Operator.NOT_IN */, \"!=\" /* Operator.NOT_EQUAL */];\n\n      default:\n        return [];\n    }\n  }(e.op));\n  if (null !== n)\n    // Special case when it's a duplicate op to give a slightly clearer error message.\n    throw n === e.op ? new U(P, \"Invalid query. You cannot use more than one '\".concat(e.op.toString(), \"' filter.\")) : new U(P, \"Invalid query. You cannot use '\".concat(e.op.toString(), \"' filters with '\").concat(n.toString(), \"' filters.\"));\n}\nfunction Mr(t, e, n) {\n  if (!n.isEqual(e)) throw new U(P, \"Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '\".concat(e.toString(), \"' and so you must also use '\").concat(e.toString(), \"' as your first argument to orderBy(), but your first orderBy() is on field '\").concat(n.toString(), \"' instead.\"));\n}\nfunction Ur(t, e) {\n  if (!(e instanceof vr || e instanceof Er)) throw new U(P, \"Function \".concat(t, \"() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.\"));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nfunction jr(t, e, n) {\n  var r;\n  // Cast to `any` in order to satisfy the union type constraint on\n  // toFirestore().\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return r = t ? n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e) : e, r;\n}\nvar Br = /*#__PURE__*/function (_ref11) {\n  _inherits(Br, _ref11);\n  var _super37 = _createSuper(Br);\n  function Br(t) {\n    var _this38;\n    _classCallCheck(this, Br);\n    _this38 = _super37.call(this), _this38.firestore = t;\n    return _this38;\n  }\n  _createClass(Br, [{\n    key: \"convertBytes\",\n    value: function convertBytes(t) {\n      return new qn(t);\n    }\n  }, {\n    key: \"convertReference\",\n    value: function convertReference(t) {\n      var e = this.convertDocumentKey(t, this.firestore._databaseId);\n      return new Pn(this.firestore, /* converter= */null, e);\n    }\n  }]);\n  return Br;\n}( /*#__PURE__*/function () {\n  function _class4() {\n    _classCallCheck(this, _class4);\n  }\n  _createClass(_class4, [{\n    key: \"convertValue\",\n    value: function convertValue(t) {\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"none\";\n      switch (xt(t)) {\n        case 0 /* TypeOrder.NullValue */:\n          return null;\n        case 1 /* TypeOrder.BooleanValue */:\n          return t.booleanValue;\n        case 2 /* TypeOrder.NumberValue */:\n          return Rt(t.integerValue || t.doubleValue);\n        case 3 /* TypeOrder.TimestampValue */:\n          return this.convertTimestamp(t.timestampValue);\n        case 4 /* TypeOrder.ServerTimestampValue */:\n          return this.convertServerTimestamp(t, e);\n        case 5 /* TypeOrder.StringValue */:\n          return t.stringValue;\n        case 6 /* TypeOrder.BlobValue */:\n          return this.convertBytes(Pt(t.bytesValue));\n        case 7 /* TypeOrder.RefValue */:\n          return this.convertReference(t.referenceValue);\n        case 8 /* TypeOrder.GeoPointValue */:\n          return this.convertGeoPoint(t.geoPointValue);\n        case 9 /* TypeOrder.ArrayValue */:\n          return this.convertArray(t.arrayValue, e);\n        case 10 /* TypeOrder.ObjectValue */:\n          return this.convertObject(t.mapValue, e);\n        default:\n          throw b();\n      }\n    }\n  }, {\n    key: \"convertObject\",\n    value: function convertObject(t, e) {\n      var _this39 = this;\n      var n = {};\n      return Et(t.fields, function (t, r) {\n        n[t] = _this39.convertValue(r, e);\n      }), n;\n    }\n  }, {\n    key: \"convertGeoPoint\",\n    value: function convertGeoPoint(t) {\n      return new Ln(Rt(t.latitude), Rt(t.longitude));\n    }\n  }, {\n    key: \"convertArray\",\n    value: function convertArray(t, e) {\n      var _this40 = this;\n      return (t.values || []).map(function (t) {\n        return _this40.convertValue(t, e);\n      });\n    }\n  }, {\n    key: \"convertServerTimestamp\",\n    value: function convertServerTimestamp(t, e) {\n      switch (e) {\n        case \"previous\":\n          var n = Nt(t);\n          return null == n ? null : this.convertValue(n, e);\n        case \"estimate\":\n          return this.convertTimestamp(Dt(t));\n        default:\n          return null;\n      }\n    }\n  }, {\n    key: \"convertTimestamp\",\n    value: function convertTimestamp(t) {\n      var e = At(t);\n      return new Vt(e.seconds, e.nanos);\n    }\n  }, {\n    key: \"convertDocumentKey\",\n    value: function convertDocumentKey(t, e) {\n      var n = tt.fromString(t);\n      E(cn(n));\n      var r = new X(n.get(1), n.get(3)),\n        s = new rt(n.popFirst(5));\n      return r.isEqual(e) ||\n      // TODO(b/64130202): Somehow support foreign references.\n      g(\"Document \".concat(s, \" contains a document reference within a different database (\").concat(r.projectId, \"/\").concat(r.database, \") which is not supported. It will be treated as a reference in the current database (\").concat(e.projectId, \"/\").concat(e.database, \") instead.\")), s;\n    }\n  }]);\n  return _class4;\n}());\n/**\n * Reads the document referred to by the specified document reference.\n *\n * All documents are directly fetched from the server, even if the document was\n * previously read or modified. Recent modifications are only reflected in the\n * retrieved `DocumentSnapshot` if they have already been applied by the\n * backend. If the client is offline, the read fails. If you like to use\n * caching or see local modifications, please use the full Firestore SDK.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the current\n * document contents.\n */\nfunction Qr(t) {\n  var e = yn((t = ct(t, Pn)).firestore),\n    n = new Br(t.firestore);\n  return dn(e, [t._key]).then(function (e) {\n    E(1 === e.length);\n    var r = e[0];\n    return new fr(t.firestore, n, t._key, r.isFoundDocument() ? r : null, t.converter);\n  });\n}\n\n/**\n * Executes the query and returns the results as a {@link QuerySnapshot}.\n *\n * All queries are executed directly by the server, even if the the query was\n * previously executed. Recent modifications are only reflected in the retrieved\n * results if they have already been applied by the backend. If the client is\n * offline, the operation fails. To see previously cached result and local\n * modifications, use the full Firestore SDK.\n *\n * @param query - The `Query` to execute.\n * @returns A Promise that will be resolved with the results of the query.\n */\nfunction zr(t) {\n  !function (t) {\n    if (\"L\" /* LimitType.Last */ === t.limitType && 0 === t.explicitOrderBy.length) throw new U(k, \"limitToLast() queries require specifying at least one orderBy() clause\");\n  }((t = ct(t, Vn))._query);\n  var e = yn(t.firestore),\n    n = new Br(t.firestore);\n  return wn(e, t._query).then(function (e) {\n    var r = e.map(function (e) {\n      return new dr(t.firestore, n, e.key, e, t.converter);\n    });\n    return \"L\" /* LimitType.Last */ === t._query.limitType &&\n    // Limit to last queries reverse the orderBy constraint that was\n    // specified by the user. As such, we need to reverse the order of the\n    // results to return the documents in the expected order.\n    r.reverse(), new wr(t, r);\n  });\n}\nfunction Wr(t, e, n) {\n  var r = jr((t = ct(t, Pn)).converter, e, n),\n    s = Gn(Wn(t.firestore), \"setDoc\", t._key, r, null !== t.converter, n);\n  return fn(yn(t.firestore), [s.toMutation(t._key, Fe.none())]);\n}\nfunction Gr(t, e, n) {\n  var s = Wn((t = ct(t, Pn)).firestore);\n  // For Compat types, we have to \"extract\" the underlying types before\n  // performing validation.\n  var i;\n  for (var _len15 = arguments.length, r = new Array(_len15 > 3 ? _len15 - 3 : 0), _key15 = 3; _key15 < _len15; _key15++) {\n    r[_key15 - 3] = arguments[_key15];\n  }\n  i = \"string\" == typeof (e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e)) || e instanceof On ? er(s, \"updateDoc\", t._key, e, n, r) : tr(s, \"updateDoc\", t._key, e);\n  return fn(yn(t.firestore), [i.toMutation(t._key, Fe.exists(!0))]);\n}\n\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * The deletion will only be reflected in document reads that occur after the\n * returned promise resolves. If the client is offline, the\n * delete fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to delete.\n * @returns A `Promise` resolved once the document has been successfully\n * deleted from the backend.\n */\nfunction Kr(t) {\n  return fn(yn((t = ct(t, Pn)).firestore), [new Oe(t._key, Fe.none())]);\n}\n\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend.\n */\nfunction Yr(t, e) {\n  var n = Fn(t = ct(t, $n)),\n    r = jr(t.converter, e),\n    s = Gn(Wn(t.firestore), \"addDoc\", n._key, r, null !== n.converter, {});\n  return fn(yn(t.firestore), [s.toMutation(n._key, Fe.exists(!1))]).then(function () {\n    return n;\n  });\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculates the number of documents in the result set of the given query,\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can even\n * count the documents if the result set would be prohibitively large to\n * download entirely (e.g. thousands of documents).\n *\n * @param query - The query whose result set size to calculate.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nfunction Hr(t) {\n  var e = ct(t.firestore, _n),\n    n = yn(e),\n    r = new Br(e);\n  return new Rn(t, n, r).run();\n}\n\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nfunction Jr(t, e) {\n  return Sn(t.query, e.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(t.data(), e.data());\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\n */\nfunction Xr() {\n  return new Kn(\"deleteField\");\n}\n\n/**\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\n * include a server-generated timestamp in the written data.\n */\nfunction Zr() {\n  return new Hn(\"serverTimestamp\");\n}\n\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\n * value that already exists on the server. Each specified element that doesn't\n * already exist in the array will be added to the end. If the field being\n * modified is not already an array it will be overwritten with an array\n * containing exactly the specified elements.\n *\n * @param elements - The elements to union into the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`.\n */\nfunction ts() {\n  for (var _len16 = arguments.length, t = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n    t[_key16] = arguments[_key16];\n  }\n  // NOTE: We don't actually parse the data until it's used in set() or\n  // update() since we'd need the Firestore instance to do this.\n  return new Jn(\"arrayUnion\", t);\n}\n\n/**\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\n * updateDoc:1} that tells the server to remove the given elements from any\n * array value that already exists on the server. All instances of each element\n * specified will be removed from the array. If the field being modified is not\n * already an array it will be overwritten with an empty array.\n *\n * @param elements - The elements to remove from the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction es() {\n  for (var _len17 = arguments.length, t = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n    t[_key17] = arguments[_key17];\n  }\n  // NOTE: We don't actually parse the data until it's used in set() or\n  // update() since we'd need the Firestore instance to do this.\n  return new Xn(\"arrayRemove\", t);\n}\n\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\n * the given value.\n *\n * If either the operand or the current field value uses floating point\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\n * integers, values outside of JavaScript's safe number range\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\n * precision loss. Furthermore, once processed by the Firestore backend, all\n * integer operations are capped between -2^63 and 2^63-1.\n *\n * If the current field value is not of type `number`, or if the field does not\n * yet exist, the transformation sets the field to the given value.\n *\n * @param n - The value to increment by.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction ns(t) {\n  return new Zn(\"increment\", t);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nvar rs = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function rs(t, e) {\n    _classCallCheck(this, rs);\n    this._firestore = t, this._commitHandler = e, this._mutations = [], this._committed = !1, this._dataReader = Wn(t);\n  }\n  _createClass(rs, [{\n    key: \"set\",\n    value: function set(t, e, n) {\n      this._verifyNotCommitted();\n      var r = ss(t, this._firestore),\n        s = jr(r.converter, e, n),\n        i = Gn(this._dataReader, \"WriteBatch.set\", r._key, s, null !== r.converter, n);\n      return this._mutations.push(i.toMutation(r._key, Fe.none())), this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, n) {\n      this._verifyNotCommitted();\n      var s = ss(t, this._firestore);\n      // For Compat types, we have to \"extract\" the underlying types before\n      // performing validation.\n      var i;\n      for (var _len18 = arguments.length, r = new Array(_len18 > 3 ? _len18 - 3 : 0), _key18 = 3; _key18 < _len18; _key18++) {\n        r[_key18 - 3] = arguments[_key18];\n      }\n      return i = \"string\" == typeof (e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e)) || e instanceof On ? er(this._dataReader, \"WriteBatch.update\", s._key, e, n, r) : tr(this._dataReader, \"WriteBatch.update\", s._key, e), this._mutations.push(i.toMutation(s._key, Fe.exists(!0))), this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(t) {\n      this._verifyNotCommitted();\n      var e = ss(t, this._firestore);\n      return this._mutations = this._mutations.concat(new Oe(e._key, Fe.none())), this;\n    }\n    /**\n     * Commits all of the writes in this write batch as a single atomic unit.\n     *\n     * The result of these writes will only be reflected in document reads that\n     * occur after the returned promise resolves. If the client is offline, the\n     * write fails. If you would like to see local modifications or buffer writes\n     * until the client is online, use the full Firestore SDK.\n     *\n     * @returns A `Promise` resolved once all of the writes in the batch have been\n     * successfully written to the backend as an atomic unit (note that it won't\n     * resolve while you're offline).\n     */\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();\n    }\n  }, {\n    key: \"_verifyNotCommitted\",\n    value: function _verifyNotCommitted() {\n      if (this._committed) throw new U(S, \"A write batch can no longer be used after commit() has been called.\");\n    }\n  }]);\n  return rs;\n}();\nfunction ss(t, e) {\n  if ((t = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(t)).firestore !== e) throw new U(P, \"Provided document reference is from a different Firestore instance.\");\n  return t;\n}\n\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single WriteBatch\n * is 500.\n *\n * The result of these writes will only be reflected in document reads that\n * occur after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @returns A `WriteBatch` that can be used to atomically execute multiple\n * writes.\n */\nfunction is(t) {\n  var e = yn(t = ct(t, _n));\n  return new rs(t, function (t) {\n    return fn(e, t);\n  });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nvar os = /*#__PURE__*/function () {\n  function os(t) {\n    _classCallCheck(this, os);\n    this.datastore = t,\n    // The version of each document that was read during this transaction.\n    this.readVersions = new Map(), this.mutations = [], this.committed = !1,\n    /**\n     * A deferred usage error that occurred previously in this transaction that\n     * will cause the transaction to fail once it actually commits.\n     */\n    this.lastWriteError = null,\n    /**\n     * Set of documents that have been written in the transaction.\n     *\n     * When there's more than one write to the same key in a transaction, any\n     * writes after the first are handled differently.\n     */\n    this.writtenDocs = new Set();\n  }\n  _createClass(os, [{\n    key: \"lookup\",\n    value: function () {\n      var _lookup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(t) {\n        var _this41 = this;\n        var e;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.ensureCommitNotCalled(), this.mutations.length > 0)) {\n                  _context2.next = 2;\n                  break;\n                }\n                throw new U(P, \"Firestore transactions require all reads to be executed before all writes.\");\n              case 2:\n                _context2.next = 4;\n                return dn(this.datastore, t);\n              case 4:\n                e = _context2.sent;\n                return _context2.abrupt(\"return\", (e.forEach(function (t) {\n                  return _this41.recordVersion(t);\n                }), e));\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function lookup(_x13) {\n        return _lookup.apply(this, arguments);\n      }\n      return lookup;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(t, e) {\n      this.write(e.toMutation(t, this.precondition(t))), this.writtenDocs.add(t.toString());\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      try {\n        this.write(e.toMutation(t, this.preconditionForUpdate(t)));\n      } catch (t) {\n        this.lastWriteError = t;\n      }\n      this.writtenDocs.add(t.toString());\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(t) {\n      this.write(new Oe(t, this.precondition(t))), this.writtenDocs.add(t.toString());\n    }\n  }, {\n    key: \"commit\",\n    value: function () {\n      var _commit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this42 = this;\n        var t;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.ensureCommitNotCalled(), this.lastWriteError)) {\n                  _context3.next = 2;\n                  break;\n                }\n                throw this.lastWriteError;\n              case 2:\n                t = this.readVersions; // For each mutation, note that the doc was written.\n                this.mutations.forEach(function (e) {\n                  t[\"delete\"](e.key.toString());\n                });\n                // For each document that was read but not written to, we want to perform\n                // a `verify` operation.\n                t.forEach(function (t, e) {\n                  var n = rt.fromPath(e);\n                  _this42.mutations.push(new ke(n, _this42.precondition(n)));\n                });\n                _context3.next = 7;\n                return fn(this.datastore, this.mutations);\n              case 7:\n                this.committed = !0;\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function commit() {\n        return _commit.apply(this, arguments);\n      }\n      return commit;\n    }()\n  }, {\n    key: \"recordVersion\",\n    value: function recordVersion(t) {\n      var e;\n      if (t.isFoundDocument()) e = t.version;else {\n        if (!t.isNoDocument()) throw b();\n        // Represent a deleted doc using SnapshotVersion.min().\n        e = oe.min();\n      }\n      var n = this.readVersions.get(t.key.toString());\n      if (n) {\n        if (!e.isEqual(n))\n          // This transaction will fail no matter what.\n          throw new U(q, \"Document version changed between two reads.\");\n      } else this.readVersions.set(t.key.toString(), e);\n    }\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n  }, {\n    key: \"precondition\",\n    value: function precondition(t) {\n      var e = this.readVersions.get(t.toString());\n      return !this.writtenDocs.has(t.toString()) && e ? e.isEqual(oe.min()) ? Fe.exists(!1) : Fe.updateTime(e) : Fe.none();\n    }\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n  }, {\n    key: \"preconditionForUpdate\",\n    value: function preconditionForUpdate(t) {\n      var e = this.readVersions.get(t.toString());\n      // The first time a document is written, we want to take into account the\n      // read time and existence\n      if (!this.writtenDocs.has(t.toString()) && e) {\n        if (e.isEqual(oe.min()))\n          // The document doesn't exist, so fail the transaction.\n          // This has to be validated locally because you can't send a\n          // precondition that a document does not exist without changing the\n          // semantics of the backend write to be an insert. This is the reverse\n          // of what we want, since we want to assert that the document doesn't\n          // exist but then send the update and have it fail. Since we can't\n          // express that to the backend, we have to validate locally.\n          // Note: this can change once we can send separate verify writes in the\n          // transaction.\n          throw new U(P, \"Can't update a document that doesn't exist.\");\n        // Document exists, base precondition on document update time.\n        return Fe.updateTime(e);\n      }\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Fe.exists(!0);\n    }\n  }, {\n    key: \"write\",\n    value: function write(t) {\n      this.ensureCommitNotCalled(), this.mutations.push(t);\n    }\n  }, {\n    key: \"ensureCommitNotCalled\",\n    value: function ensureCommitNotCalled() {}\n  }]);\n  return os;\n}();\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar us = {\n  maxAttempts: 5\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * TransactionRunner encapsulates the logic needed to run and retry transactions\n * with backoff.\n */\nvar cs = /*#__PURE__*/function () {\n  function cs(t, e, n, r, s) {\n    _classCallCheck(this, cs);\n    this.asyncQueue = t, this.datastore = e, this.options = n, this.updateFunction = r, this.deferred = s, this.yt = n.maxAttempts, this.gt = new hn(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\n  }\n  /** Runs the transaction and sets the result on deferred. */\n  _createClass(cs, [{\n    key: \"run\",\n    value: function run() {\n      this.yt -= 1, this._t();\n    }\n  }, {\n    key: \"_t\",\n    value: function _t() {\n      var _this43 = this;\n      this.gt.H( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var t, e;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                t = new os(_this43.datastore), e = _this43.vt(t);\n                e && e.then(function (e) {\n                  _this43.asyncQueue.enqueueAndForget(function () {\n                    return t.commit().then(function () {\n                      _this43.deferred.resolve(e);\n                    })[\"catch\"](function (t) {\n                      _this43.bt(t);\n                    });\n                  });\n                })[\"catch\"](function (t) {\n                  _this43.bt(t);\n                });\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      })));\n    }\n  }, {\n    key: \"vt\",\n    value: function vt(t) {\n      try {\n        var e = this.updateFunction(t);\n        return !ht(e) && e[\"catch\"] && e.then ? e : (this.deferred.reject(Error(\"Transaction callback must return a Promise\")), null);\n      } catch (t) {\n        // Do not retry errors thrown by user provided updateFunction.\n        return this.deferred.reject(t), null;\n      }\n    }\n  }, {\n    key: \"bt\",\n    value: function bt(t) {\n      var _this44 = this;\n      this.yt > 0 && this.Et(t) ? (this.yt -= 1, this.asyncQueue.enqueueAndForget(function () {\n        return _this44._t(), Promise.resolve();\n      })) : this.deferred.reject(t);\n    }\n  }, {\n    key: \"Et\",\n    value: function Et(t) {\n      if (\"FirebaseError\" === t.name) {\n        // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n        // non-matching document versions with ABORTED. These errors should be retried.\n        var e = t.code;\n        return \"aborted\" === e || \"failed-precondition\" === e || \"already-exists\" === e || !\n        /**\n        * Determines whether an error code represents a permanent error when received\n        * in response to a non-write operation.\n        *\n        * See isPermanentWriteError for classifying write errors.\n        */\n        function (t) {\n          switch (t) {\n            default:\n              return b();\n            case A:\n            case R:\n            case V:\n            case x:\n            case C:\n            case L:\n            // Unauthenticated means something went wrong with our token and we need\n            // to retry with new credentials which will happen automatically.\n            case F:\n              return !1;\n            case P:\n            case $:\n            case N:\n            case D:\n            case S:\n            // Aborted might be retried in some scenarios, but that is dependant on\n            // the context and should handled individually by the calling code.\n            // See https://cloud.google.com/apis/design/errors.\n            case q:\n            case O:\n            case k:\n            case M:\n              return !0;\n          }\n        }(e);\n      }\n      return !1;\n    }\n  }]);\n  return cs;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** The Platform's 'document' implementation or null if not available. */\nfunction as() {\n  // `document` is not always available, e.g. in ReactNative and WebWorkers.\n  // eslint-disable-next-line no-restricted-globals\n  return \"undefined\" != typeof document ? document : null;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n *\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\n * in newer versions of TypeScript defines `finally`, which is not available in\n * IE.\n */\nvar hs = /*#__PURE__*/function () {\n  function hs(t, e, n, r, s) {\n    _classCallCheck(this, hs);\n    this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = s, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise),\n    // It's normal for the deferred promise to be canceled (due to cancellation)\n    // and so we attach a dummy catch callback to avoid\n    // 'UnhandledPromiseRejectionWarning' log spam.\n    this.deferred.promise[\"catch\"](function (t) {});\n  }\n  /**\n   * Creates and returns a DelayedOperation that has been scheduled to be\n   * executed on the provided asyncQueue after the provided delayMs.\n   *\n   * @param asyncQueue - The queue to schedule the operation on.\n   * @param id - A Timer ID identifying the type of operation this is.\n   * @param delayMs - The delay (ms) before the operation should be scheduled.\n   * @param op - The operation to run.\n   * @param removalCallback - A callback to be called synchronously once the\n   *   operation is executed or canceled, notifying the AsyncQueue to remove it\n   *   from its delayedOperations list.\n   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n   *   the DelayedOperation class public.\n   */\n  _createClass(hs, [{\n    key: \"start\",\n    value:\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    function start(t) {\n      var _this45 = this;\n      this.timerHandle = setTimeout(function () {\n        return _this45.handleDelayElapsed();\n      }, t);\n    }\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n  }, {\n    key: \"skipDelay\",\n    value: function skipDelay() {\n      return this.handleDelayElapsed();\n    }\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(t) {\n      null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new U(A, \"Operation cancelled\" + (t ? \": \" + t : \"\"))));\n    }\n  }, {\n    key: \"handleDelayElapsed\",\n    value: function handleDelayElapsed() {\n      var _this46 = this;\n      this.asyncQueue.enqueueAndForget(function () {\n        return null !== _this46.timerHandle ? (_this46.clearTimeout(), _this46.op().then(function (t) {\n          return _this46.deferred.resolve(t);\n        })) : Promise.resolve();\n      });\n    }\n  }, {\n    key: \"clearTimeout\",\n    value: function (_clearTimeout) {\n      function clearTimeout() {\n        return _clearTimeout.apply(this, arguments);\n      }\n      clearTimeout.toString = function () {\n        return _clearTimeout.toString();\n      };\n      return clearTimeout;\n    }(function () {\n      null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);\n    })\n  }], [{\n    key: \"createAndSchedule\",\n    value: function createAndSchedule(t, e, n, r, s) {\n      var i = Date.now() + n,\n        o = new hs(t, e, i, r, s);\n      return o.start(n), o;\n    }\n  }]);\n  return hs;\n}();\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ls = /*#__PURE__*/function () {\n  function ls() {\n    var _this47 = this;\n    _classCallCheck(this, ls);\n    // The last promise in the queue.\n    this.It = Promise.resolve(),\n    // A list of retryable operations. Retryable operations are run in order and\n    // retried with backoff.\n    this.Tt = [],\n    // Is this AsyncQueue being shut down? Once it is set to true, it will not\n    // be changed again.\n    this.At = !1,\n    // Operations scheduled to be queued in the future. Operations are\n    // automatically removed after they are run or canceled.\n    this.Rt = [],\n    // visible for testing\n    this.Pt = null,\n    // Flag set while there's an outstanding AsyncQueue operation, used for\n    // assertion sanity-checks.\n    this.Vt = !1,\n    // Enabled during shutdown on Safari to prevent future access to IndexedDB.\n    this.$t = !1,\n    // List of TimerIds to fast-forward delays for.\n    this.Nt = [],\n    // Backoff timer used to schedule retries for retryable operations\n    this.gt = new hn(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */),\n    // Visibility handler that triggers an immediate retry of all retryable\n    // operations. Meant to speed up recovery when we regain file system access\n    // after page comes into foreground.\n    this.Dt = function () {\n      var t = as();\n      t && y(\"AsyncQueue\", \"Visibility state changed to \" + t.visibilityState), _this47.gt.X();\n    };\n    var t = as();\n    t && \"function\" == typeof t.addEventListener && t.addEventListener(\"visibilitychange\", this.Dt);\n  }\n  _createClass(ls, [{\n    key: \"isShuttingDown\",\n    get: function get() {\n      return this.At;\n    }\n    /**\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\n     * we ignore the Promise result).\n     */\n  }, {\n    key: \"enqueueAndForget\",\n    value: function enqueueAndForget(t) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.enqueue(t);\n    }\n  }, {\n    key: \"enqueueAndForgetEvenWhileRestricted\",\n    value: function enqueueAndForgetEvenWhileRestricted(t) {\n      this.Ft(),\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.xt(t);\n    }\n  }, {\n    key: \"enterRestrictedMode\",\n    value: function enterRestrictedMode(t) {\n      if (!this.At) {\n        this.At = !0, this.$t = t || !1;\n        var e = as();\n        e && \"function\" == typeof e.removeEventListener && e.removeEventListener(\"visibilitychange\", this.Dt);\n      }\n    }\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(t) {\n      var _this48 = this;\n      if (this.Ft(), this.At)\n        // Return a Promise which never resolves.\n        return new Promise(function () {});\n      // Create a deferred Promise that we can return to the callee. This\n      // allows us to return a \"hanging Promise\" only to the callee and still\n      // advance the queue even when the operation is not run.\n      var e = new j();\n      return this.xt(function () {\n        return _this48.At && _this48.$t ? Promise.resolve() : (t().then(e.resolve, e.reject), e.promise);\n      }).then(function () {\n        return e.promise;\n      });\n    }\n  }, {\n    key: \"enqueueRetryable\",\n    value: function enqueueRetryable(t) {\n      var _this49 = this;\n      this.enqueueAndForget(function () {\n        return _this49.Tt.push(t), _this49.St();\n      });\n    }\n    /**\n     * Runs the next operation from the retryable queue. If the operation fails,\n     * reschedules with backoff.\n     */\n  }, {\n    key: \"St\",\n    value: function () {\n      var _St = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this50 = this;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(0 !== this.Tt.length)) {\n                  _context5.next = 14;\n                  break;\n                }\n                _context5.prev = 1;\n                _context5.next = 4;\n                return this.Tt[0]();\n              case 4:\n                this.Tt.shift();\n                this.gt.reset();\n                _context5.next = 13;\n                break;\n              case 8:\n                _context5.prev = 8;\n                _context5.t0 = _context5[\"catch\"](1);\n                if (\n                /**\n                * @license\n                * Copyright 2017 Google LLC\n                *\n                * Licensed under the Apache License, Version 2.0 (the \"License\");\n                * you may not use this file except in compliance with the License.\n                * You may obtain a copy of the License at\n                *\n                *   http://www.apache.org/licenses/LICENSE-2.0\n                *\n                * Unless required by applicable law or agreed to in writing, software\n                * distributed under the License is distributed on an \"AS IS\" BASIS,\n                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                * See the License for the specific language governing permissions and\n                * limitations under the License.\n                */\n                /** Verifies whether `e` is an IndexedDbTransactionError. */\n                function (t) {\n                  // Use name equality, as instanceof checks on errors don't work with errors\n                  // that wrap other errors.\n                  return \"IndexedDbTransactionError\" === t.name;\n                }\n                /**\n                * @license\n                * Copyright 2020 Google LLC\n                *\n                * Licensed under the Apache License, Version 2.0 (the \"License\");\n                * you may not use this file except in compliance with the License.\n                * You may obtain a copy of the License at\n                *\n                *   http://www.apache.org/licenses/LICENSE-2.0\n                *\n                * Unless required by applicable law or agreed to in writing, software\n                * distributed under the License is distributed on an \"AS IS\" BASIS,\n                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                * See the License for the specific language governing permissions and\n                * limitations under the License.\n                */(_context5.t0)) {\n                  _context5.next = 12;\n                  break;\n                }\n                throw _context5.t0;\n              case 12:\n                // Failure will be handled by AsyncQueue\n                y(\"AsyncQueue\", \"Operation failed with retryable error: \" + _context5.t0);\n              case 13:\n                this.Tt.length > 0 &&\n                // If there are additional operations, we re-schedule `retryNextOp()`.\n                // This is necessary to run retryable operations that failed during\n                // their initial attempt since we don't know whether they are already\n                // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\n                // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\n                // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\n                // call scheduled here.\n                // Since `backoffAndRun()` cancels an existing backoff and schedules a\n                // new backoff on every call, there is only ever a single additional\n                // operation in the queue.\n                this.gt.H(function () {\n                  return _this50.St();\n                });\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 8]]);\n      }));\n      function St() {\n        return _St.apply(this, arguments);\n      }\n      return St;\n    }()\n  }, {\n    key: \"xt\",\n    value: function xt(t) {\n      var _this51 = this;\n      var e = this.It.then(function () {\n        return _this51.Vt = !0, t()[\"catch\"](function (t) {\n          _this51.Pt = t, _this51.Vt = !1;\n          var e =\n          /**\n          * Chrome includes Error.message in Error.stack. Other browsers do not.\n          * This returns expected output of message + stack when available.\n          * @param error - Error or FirestoreError\n          */\n          function (t) {\n            var e = t.message || \"\";\n            t.stack && (e = t.stack.includes(t.message) ? t.stack : t.message + \"\\n\" + t.stack);\n            return e;\n          }\n          /**\n          * @license\n          * Copyright 2020 Google LLC\n          *\n          * Licensed under the Apache License, Version 2.0 (the \"License\");\n          * you may not use this file except in compliance with the License.\n          * You may obtain a copy of the License at\n          *\n          *   http://www.apache.org/licenses/LICENSE-2.0\n          *\n          * Unless required by applicable law or agreed to in writing, software\n          * distributed under the License is distributed on an \"AS IS\" BASIS,\n          * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          * See the License for the specific language governing permissions and\n          * limitations under the License.\n          */\n          // TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n          // legacy SDK.\n          /**\n          * A reference to a transaction.\n          *\n          * The `Transaction` object passed to a transaction's `updateFunction` provides\n          * the methods to read and write data within the transaction context. See\n          * {@link runTransaction}.\n          */(t);\n          // Re-throw the error so that this.tail becomes a rejected Promise and\n          // all further attempts to chain (via .then) will just short-circuit\n          // and return the rejected Promise.\n          throw g(\"INTERNAL UNHANDLED ERROR: \", e), t;\n        }).then(function (t) {\n          return _this51.Vt = !1, t;\n        });\n      });\n      return this.It = e, e;\n    }\n  }, {\n    key: \"enqueueAfterDelay\",\n    value: function enqueueAfterDelay(t, e, n) {\n      var _this52 = this;\n      this.Ft(),\n      // Fast-forward delays for timerIds that have been overriden.\n      this.Nt.indexOf(t) > -1 && (e = 0);\n      var r = hs.createAndSchedule(this, t, e, n, function (t) {\n        return _this52.qt(t);\n      });\n      return this.Rt.push(r), r;\n    }\n  }, {\n    key: \"Ft\",\n    value: function Ft() {\n      this.Pt && b();\n    }\n  }, {\n    key: \"verifyOperationInProgress\",\n    value: function verifyOperationInProgress() {}\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n  }, {\n    key: \"Ot\",\n    value: function () {\n      var _Ot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var t;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                t = this.It;\n                _context6.next = 3;\n                return t;\n              case 3:\n                if (t !== this.It) {\n                  _context6.next = 0;\n                  break;\n                }\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function Ot() {\n        return _Ot.apply(this, arguments);\n      }\n      return Ot;\n    }()\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n  }, {\n    key: \"kt\",\n    value: function kt(t) {\n      var _iterator17 = _createForOfIteratorHelper(this.Rt),\n        _step17;\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var e = _step17.value;\n          if (e.timerId === t) return !0;\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n      return !1;\n    }\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId - Delayed operations up to and including this TimerId\n     * will be drained. Pass TimerId.All to run all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n  }, {\n    key: \"Ct\",\n    value: function Ct(t) {\n      var _this53 = this;\n      // Note that draining may generate more delayed ops, so we do that first.\n      return this.Ot().then(function () {\n        // Run ops in the same order they'd run if they ran naturally.\n        _this53.Rt.sort(function (t, e) {\n          return t.targetTimeMs - e.targetTimeMs;\n        });\n        var _iterator18 = _createForOfIteratorHelper(_this53.Rt),\n          _step18;\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var e = _step18.value;\n            if (e.skipDelay(), \"all\" /* TimerId.All */ !== t && e.timerId === t) break;\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n        return _this53.Ot();\n      });\n    }\n    /**\n     * For Tests: Skip all subsequent delays for a timer id.\n     */\n  }, {\n    key: \"Lt\",\n    value: function Lt(t) {\n      this.Nt.push(t);\n    }\n    /** Called once a DelayedOperation is run or canceled. */\n  }, {\n    key: \"qt\",\n    value: function qt(t) {\n      // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n      var e = this.Rt.indexOf(t);\n      this.Rt.splice(e, 1);\n    }\n  }]);\n  return ls;\n}();\nvar fs = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function fs(t, e) {\n    _classCallCheck(this, fs);\n    this._firestore = t, this._transaction = e, this._dataReader = Wn(t);\n  }\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  _createClass(fs, [{\n    key: \"get\",\n    value: function get(t) {\n      var _this54 = this;\n      var e = ss(t, this._firestore),\n        n = new Br(this._firestore);\n      return this._transaction.lookup([e._key]).then(function (t) {\n        if (!t || 1 !== t.length) return b();\n        var r = t[0];\n        if (r.isFoundDocument()) return new fr(_this54._firestore, n, r.key, r, e.converter);\n        if (r.isNoDocument()) return new fr(_this54._firestore, n, e._key, null, e.converter);\n        throw b();\n      });\n    }\n  }, {\n    key: \"set\",\n    value: function set(t, e, n) {\n      var r = ss(t, this._firestore),\n        s = jr(r.converter, e, n),\n        i = Gn(this._dataReader, \"Transaction.set\", r._key, s, null !== r.converter, n);\n      return this._transaction.set(r._key, i), this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, n) {\n      var s = ss(t, this._firestore);\n      // For Compat types, we have to \"extract\" the underlying types before\n      // performing validation.\n      var i;\n      for (var _len19 = arguments.length, r = new Array(_len19 > 3 ? _len19 - 3 : 0), _key19 = 3; _key19 < _len19; _key19++) {\n        r[_key19 - 3] = arguments[_key19];\n      }\n      return i = \"string\" == typeof (e = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(e)) || e instanceof On ? er(this._dataReader, \"Transaction.update\", s._key, e, n, r) : tr(this._dataReader, \"Transaction.update\", s._key, e), this._transaction.update(s._key, i), this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `Transaction` instance. Used for chaining method calls.\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(t) {\n      var e = ss(t, this._firestore);\n      return this._transaction[\"delete\"](e._key), this;\n    }\n  }]);\n  return fs;\n}();\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nfunction ds(t, e, n) {\n  var r = yn(t = ct(t, _n)),\n    s = Object.assign(Object.assign({}, us), n);\n  !function (t) {\n    if (t.maxAttempts < 1) throw new U(P, \"Max attempts must be at least 1\");\n  }(s);\n  var i = new j();\n  return new cs(new ls(), r, s, function (n) {\n    return e(new fs(t, n));\n  }, i).run(), i.promise;\n}\n\n/**\n * Firestore Lite\n *\n * @remarks Firestore Lite is a small online-only SDK that allows read\n * and write access to your Firestore database. All operations connect\n * directly to the backend, and `onSnapshot()` APIs are not supported.\n * @packageDocumentation\n */\n!function (t) {\n  w = t;\n}(\"\".concat(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION, \"_lite\")), (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"firestore/lite\", function (t, _ref13) {\n  var e = _ref13.instanceIdentifier,\n    n = _ref13.options;\n  var r = t.getProvider(\"app\").getImmediate(),\n    s = new _n(new W(t.getProvider(\"auth-internal\")), new H(t.getProvider(\"app-check-internal\")), function (t, e) {\n      if (!Object.prototype.hasOwnProperty.apply(t.options, [\"projectId\"])) throw new U(P, '\"projectId\" not provided in firebase.initializeApp.');\n      return new X(t.options.projectId, e);\n    }\n    /**\n    * @license\n    * Copyright 2017 Google LLC\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */(r, e), r);\n  return n && s._setSettings(n), s;\n}, \"PUBLIC\").setMultipleInstances(!0)),\n// RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(\"firestore-lite\", \"3.8.0\", \"\"), (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(\"firestore-lite\", \"3.8.0\", \"esm2017\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2xpdGUvaW5kZXguYnJvd3Nlci5lc20yMDE3LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBSU1BLENBQUM7RUFDSCxXQUFZQyxDQUFDLEVBQUU7SUFBQTtJQUNYLElBQUksQ0FBQ0MsR0FBRyxHQUFHRCxDQUFDO0VBQ3BCO0VBQUs7SUFBQTtJQUFBLE9BQ0QsMkJBQWtCO01BQ2QsT0FBTyxJQUFJLElBQUksSUFBSSxDQUFDQyxHQUFHO0lBQy9CO0lBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFIQTtJQUFBO0lBQUEsT0FHVyxpQkFBUTtNQUNYLE9BQU8sSUFBSSxDQUFDQyxlQUFlLEVBQUUsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxHQUFHLEdBQUcsZ0JBQWdCO0lBQzVFO0VBQUs7SUFBQTtJQUFBLE9BQ0QsaUJBQVFELENBQUMsRUFBRTtNQUNQLE9BQU9BLENBQUMsQ0FBQ0MsR0FBRyxLQUFLLElBQUksQ0FBQ0EsR0FBRztJQUNqQztFQUFLO0VBQUE7QUFBQTtBQUdMO0FBQStCRixDQUFDLENBQUNJLGVBQWUsR0FBRyxJQUFJSixDQUFDLENBQUMsSUFBSSxDQUFDO0FBQzlEO0FBQ0E7QUFDQUEsQ0FBQyxDQUFDSyxrQkFBa0IsR0FBRyxJQUFJTCxDQUFDLENBQUMsd0JBQXdCLENBQUMsRUFBRUEsQ0FBQyxDQUFDTSxXQUFXLEdBQUcsSUFBSU4sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEVBQ2hHQSxDQUFDLENBQUNPLFNBQVMsR0FB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QUNBO0FBQ0E7QUFDQSxNQWZBLENBZUtnRSxDQUFDLEVBQUVoRSxDQUFDLENBQUMsRUFBRWdFLENBQUMsQ0FBQztFQUNWLE9BQU8vRCxDQUFDLElBQUkyRSxDQUFDLENBQUNpYyxZQUFZLENBQUM1Z0IsQ0FBQyxDQUFDLEVBQUUyRSxDQUFDO0FBQ3BDLENBQUMsRUFBRyxRQUFRLENBQUMsQ0FBQ2lwQixvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDO0FBQ0E3cEIsOERBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUVBLDhEQUFDLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLFNBQWtCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saWJyYXJ5L2luZGV4LmJyb3dzZXIuZXNtMjAxNy5qcz84ZjY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwIGFzIHQsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UgYXMgZSwgX3JlZ2lzdGVyQ29tcG9uZW50IGFzIG4sIHJlZ2lzdGVyVmVyc2lvbiBhcyByLCBTREtfVkVSU0lPTiBhcyBzIH0gZnJvbSBcIkBmaXJlYmFzZS9hcHBcIjtcblxuaW1wb3J0IHsgQ29tcG9uZW50IGFzIGkgfSBmcm9tIFwiQGZpcmViYXNlL2NvbXBvbmVudFwiO1xuXG5pbXBvcnQgeyBMb2dnZXIgYXMgbywgTG9nTGV2ZWwgYXMgdSB9IGZyb20gXCJAZmlyZWJhc2UvbG9nZ2VyXCI7XG5cbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgYXMgYywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0IGFzIGEsIGNyZWF0ZU1vY2tVc2VyVG9rZW4gYXMgaCwgZ2V0TW9kdWxhckluc3RhbmNlIGFzIGwsIGRlZXBFcXVhbCBhcyBmIH0gZnJvbSBcIkBmaXJlYmFzZS91dGlsXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFNpbXBsZSB3cmFwcGVyIGFyb3VuZCBhIG51bGxhYmxlIFVJRC4gTW9zdGx5IGV4aXN0cyB0byBtYWtlIGNvZGUgbW9yZVxuICogcmVhZGFibGUuXG4gKi9cbmNsYXNzIGQge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy51aWQgPSB0O1xuICAgIH1cbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XG4gICAgICAgIHJldHVybiBudWxsICE9IHRoaXMudWlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxuICAgICAqIGRpY3Rpb25hcnkuXG4gICAgICovICAgIHRvS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSA/IFwidWlkOlwiICsgdGhpcy51aWQgOiBcImFub255bW91cy11c2VyXCI7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdC51aWQgPT09IHRoaXMudWlkO1xuICAgIH1cbn1cblxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovIGQuVU5BVVRIRU5USUNBVEVEID0gbmV3IGQobnVsbCksIFxuLy8gVE9ETyhtaWtlbGVoZW4pOiBMb29rIGludG8gZ2V0dGluZyBhIHByb3BlciB1aWQtZXF1aXZhbGVudCBmb3Jcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxuZC5HT09HTEVfQ1JFREVOVElBTFMgPSBuZXcgZChcImdvb2dsZS1jcmVkZW50aWFscy11aWRcIiksIGQuRklSU1RfUEFSVFkgPSBuZXcgZChcImZpcnN0LXBhcnR5LXVpZFwiKSwgXG5kLk1PQ0tfVVNFUiA9IG5ldyBkKFwibW9jay11c2VyXCIpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubGV0IHcgPSBcIjkuMTUuMFwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbSA9IG5ldyBvKFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiKTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2ZXJib3NpdHkgb2YgQ2xvdWQgRmlyZXN0b3JlIGxvZ3MgKGRlYnVnLCBlcnJvciwgb3Igc2lsZW50KS5cbiAqXG4gKiBAcGFyYW0gbG9nTGV2ZWwgLSBUaGUgdmVyYm9zaXR5IHlvdSBzZXQgZm9yIGFjdGl2aXR5IGFuZCBlcnJvciBsb2dnaW5nLiBDYW5cbiAqICAgYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqICAgPHVsPlxuICogICAgIDxsaT5gZGVidWdgIGZvciB0aGUgbW9zdCB2ZXJib3NlIGxvZ2dpbmcgbGV2ZWwsIHByaW1hcmlseSBmb3JcbiAqICAgICBkZWJ1Z2dpbmcuPC9saT5cbiAqICAgICA8bGk+YGVycm9yYCB0byBsb2cgZXJyb3JzIG9ubHkuPC9saT5cbiAqICAgICA8bGk+PGNvZGU+YHNpbGVudGAgdG8gdHVybiBvZmYgbG9nZ2luZy48L2xpPlxuICogICA8L3VsPlxuICovIGZ1bmN0aW9uIHAodCkge1xuICAgIG0uc2V0TG9nTGV2ZWwodCk7XG59XG5cbmZ1bmN0aW9uIHkodCwgLi4uZSkge1xuICAgIGlmIChtLmxvZ0xldmVsIDw9IHUuREVCVUcpIHtcbiAgICAgICAgY29uc3QgbiA9IGUubWFwKHYpO1xuICAgICAgICBtLmRlYnVnKGBGaXJlc3RvcmUgKCR7d30pOiAke3R9YCwgLi4ubik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnKHQsIC4uLmUpIHtcbiAgICBpZiAobS5sb2dMZXZlbCA8PSB1LkVSUk9SKSB7XG4gICAgICAgIGNvbnN0IG4gPSBlLm1hcCh2KTtcbiAgICAgICAgbS5lcnJvcihgRmlyZXN0b3JlICgke3d9KTogJHt0fWAsIC4uLm4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqLyBmdW5jdGlvbiBfKHQsIC4uLmUpIHtcbiAgICBpZiAobS5sb2dMZXZlbCA8PSB1LldBUk4pIHtcbiAgICAgICAgY29uc3QgbiA9IGUubWFwKHYpO1xuICAgICAgICBtLndhcm4oYEZpcmVzdG9yZSAoJHt3fSk6ICR7dH1gLCAuLi5uKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYWRkaXRpb25hbCBsb2cgcGFyYW1ldGVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICovIGZ1bmN0aW9uIHYodCkge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSByZXR1cm4gdDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZSA9IHQsIEpTT04uc3RyaW5naWZ5KGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ29udmVydGluZyB0byBKU09OIGZhaWxlZCwganVzdCBsb2cgdGhlIG9iamVjdCBkaXJlY3RseVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbiAgICAvKiogRm9ybWF0cyBhbiBvYmplY3QgYXMgYSBKU09OIHN0cmluZywgc3VpdGFibGUgZm9yIGxvZ2dpbmcuICovXG4gICAgdmFyIGU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAqIE1lc3NhZ2VzIGFyZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAqXG4gKiBSZXR1cm5zIGBuZXZlcmAgYW5kIGNhbiBiZSB1c2VkIGluIGV4cHJlc3Npb25zOlxuICogQGV4YW1wbGVcbiAqIGxldCBmdXR1cmVWYXIgPSBmYWlsKCdub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gKi8gZnVuY3Rpb24gYih0ID0gXCJVbmV4cGVjdGVkIHN0YXRlXCIpIHtcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXG4gICAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cbiAgICBjb25zdCBlID0gYEZJUkVTVE9SRSAoJHt3fSkgSU5URVJOQUwgQVNTRVJUSU9OIEZBSUxFRDogYCArIHQ7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmVzdG9yZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcbiAgICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXG4gICAgdGhyb3cgZyhlKSwgbmV3IEVycm9yKGUpO1xufVxuXG4vKipcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxuICogZ2l2ZW4gbWVzc2FnZSBpZiBpdCBkaWQuXG4gKlxuICogTWVzc2FnZXMgYXJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuICovIGZ1bmN0aW9uIEUodCwgZSkge1xuICAgIHQgfHwgYigpO1xufVxuXG4vKipcbiAqIENhc3RzIGBvYmpgIHRvIGBUYC4gSW4gbm9uLXByb2R1Y3Rpb24gYnVpbGRzLCB2ZXJpZmllcyB0aGF0IGBvYmpgIGlzIGFuXG4gKiBpbnN0YW5jZSBvZiBgVGAgYmVmb3JlIGNhc3RpbmcuXG4gKi8gZnVuY3Rpb24gSSh0LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5lKSB7XG4gICAgcmV0dXJuIHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNvbnN0IFQgPSBcIm9rXCIsIEEgPSBcImNhbmNlbGxlZFwiLCBSID0gXCJ1bmtub3duXCIsIFAgPSBcImludmFsaWQtYXJndW1lbnRcIiwgViA9IFwiZGVhZGxpbmUtZXhjZWVkZWRcIiwgJCA9IFwibm90LWZvdW5kXCIsIE4gPSBcImFscmVhZHktZXhpc3RzXCIsIEQgPSBcInBlcm1pc3Npb24tZGVuaWVkXCIsIEYgPSBcInVuYXV0aGVudGljYXRlZFwiLCB4ID0gXCJyZXNvdXJjZS1leGhhdXN0ZWRcIiwgUyA9IFwiZmFpbGVkLXByZWNvbmRpdGlvblwiLCBxID0gXCJhYm9ydGVkXCIsIE8gPSBcIm91dC1vZi1yYW5nZVwiLCBrID0gXCJ1bmltcGxlbWVudGVkXCIsIEMgPSBcImludGVybmFsXCIsIEwgPSBcInVuYXZhaWxhYmxlXCIsIE0gPSBcImRhdGEtbG9zc1wiO1xuXG4vKiogQW4gZXJyb3IgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgb3BlcmF0aW9uLiAqLyBjbGFzcyBVIGV4dGVuZHMgYyB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYmFja2VuZCBlcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVycm9yLlxuICAgICAqL1xuICAgIHQsIFxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIGVycm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIGUpIHtcbiAgICAgICAgc3VwZXIodCwgZSksIHRoaXMuY29kZSA9IHQsIHRoaXMubWVzc2FnZSA9IGUsIFxuICAgICAgICAvLyBIQUNLOiBXZSB3cml0ZSBhIHRvU3RyaW5nIHByb3BlcnR5IGRpcmVjdGx5IGJlY2F1c2UgRXJyb3IgaXMgbm90IGEgcmVhbFxuICAgICAgICAvLyBjbGFzcyBhbmQgc28gaW5oZXJpdGFuY2UgZG9lcyBub3Qgd29yayBjb3JyZWN0bHkuIFdlIGNvdWxkIGFsdGVybmF0aXZlbHlcbiAgICAgICAgLy8gZG8gdGhlIHNhbWUgXCJiYWNrLWRvb3IgaW5oZXJpdGFuY2VcIiB0cmljayB0aGF0IEZpcmViYXNlRXJyb3IgZG9lcy5cbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMubmFtZX06IFtjb2RlPSR7dGhpcy5jb2RlfV06ICR7dGhpcy5tZXNzYWdlfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyBqIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKCh0LCBlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSB0LCB0aGlzLnJlamVjdCA9IGU7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzIEIge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgdGhpcy51c2VyID0gZSwgdGhpcy50eXBlID0gXCJPQXV0aFwiLCB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwLCB0aGlzLmhlYWRlcnMuc2V0KFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7dH1gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cbiAqIEBpbnRlcm5hbFxuICovIGNsYXNzIFEge1xuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7fVxuICAgIHN0YXJ0KHQsIGUpIHtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cbiAgICAgICAgdC5lbnF1ZXVlUmV0cnlhYmxlKCgoKSA9PiBlKGQuVU5BVVRIRU5USUNBVEVEKSkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHt9XG59XG5cbi8qKlxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHJldHVybnMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBmb3JcbiAqIGVtdWxhdG9yIHRva2VuIG1vY2tpbmcuXG4gKi8gY2xhc3MgeiB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLnRva2VuID0gdCwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCBzZXRDaGFuZ2VMaXN0ZW5lcigpXG4gICAgICAgICAqIFRoaXMgaXNuJ3QgYWN0dWFsbHkgbmVjZXNzYXJ5IHNpbmNlIHRoZSBVSUQgbmV2ZXIgY2hhbmdlcywgYnV0IHdlIHVzZSB0aGlzXG4gICAgICAgICAqIHRvIHZlcmlmeSB0aGUgbGlzdGVuIGNvbnRyYWN0IGlzIGFkaGVyZWQgdG8gaW4gdGVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50b2tlbik7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHt9XG4gICAgc3RhcnQodCwgZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gZSwgXG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXG4gICAgICAgIHQuZW5xdWV1ZVJldHJ5YWJsZSgoKCkgPT4gZSh0aGlzLnRva2VuLnVzZXIpKSk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG59XG5cbi8qKiBDcmVkZW50aWFsIHByb3ZpZGVyIGZvciB0aGUgTGl0ZSBTREsuICovIGNsYXNzIFcge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gbnVsbCwgdC5vbkluaXQoKHQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gdDtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aCA/IHRoaXMuYXV0aC5nZXRUb2tlbigpLnRoZW4oKHQgPT4gdCA/IChFKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQuYWNjZXNzVG9rZW4pLCBcbiAgICAgICAgbmV3IEIodC5hY2Nlc3NUb2tlbiwgbmV3IGQodGhpcy5hdXRoLmdldFVpZCgpKSkpIDogbnVsbCkpIDogUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7fVxuICAgIHN0YXJ0KHQsIGUpIHt9XG4gICAgc2h1dGRvd24oKSB7fVxufVxuXG4vKlxuICogRmlyc3RQYXJ0eVRva2VuIHByb3ZpZGVzIGEgZnJlc2ggdG9rZW4gZWFjaCB0aW1lIGl0cyB2YWx1ZVxuICogaXMgcmVxdWVzdGVkLCBiZWNhdXNlIGlmIHRoZSB0b2tlbiBpcyB0b28gb2xkLCByZXF1ZXN0cyB3aWxsIGJlIHJlamVjdGVkLlxuICogVGVjaG5pY2FsbHkgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgU0RLIHNob3VsZCBncmFjZWZ1bGx5XG4gKiByZWNvdmVyIGZyb20gdW5hdXRoZW50aWNhdGVkIGVycm9ycyAoc2VlIGIvMzMxNDc4MTggZm9yIGNvbnRleHQpLCBidXQgaXQnc1xuICogc2FmZXIgdG8ga2VlcCB0aGUgaW1wbGVtZW50YXRpb24gYXMtaXMuXG4gKi8gY2xhc3MgRyB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgcikge1xuICAgICAgICB0aGlzLnQgPSB0LCB0aGlzLmkgPSBlLCB0aGlzLm8gPSBuLCB0aGlzLnUgPSByLCB0aGlzLnR5cGUgPSBcIkZpcnN0UGFydHlcIiwgdGhpcy51c2VyID0gZC5GSVJTVF9QQVJUWSwgXG4gICAgICAgIHRoaXMuaCA9IG5ldyBNYXA7XG4gICAgfVxuICAgIC8qKiBHZXRzIGFuIGF1dGhvcml6YXRpb24gdG9rZW4sIHVzaW5nIGEgcHJvdmlkZWQgZmFjdG9yeSBmdW5jdGlvbiwgb3IgZmFsbGluZyBiYWNrIHRvIEZpcnN0IFBhcnR5IEdBUEkuICovICAgIGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnUgPyB0aGlzLnUoKSA6IChcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgcmVhbGx5IGlzIGEgR2FwaSBjbGllbnQuXG4gICAgICAgIEUoIShcIm9iamVjdFwiICE9IHR5cGVvZiB0aGlzLnQgfHwgbnVsbCA9PT0gdGhpcy50IHx8ICF0aGlzLnQuYXV0aCB8fCAhdGhpcy50LmF1dGguZ2V0QXV0aEhlYWRlclZhbHVlRm9yRmlyc3RQYXJ0eSkpLCBcbiAgICAgICAgdGhpcy50LmF1dGguZ2V0QXV0aEhlYWRlclZhbHVlRm9yRmlyc3RQYXJ0eShbXSkpO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgdGhpcy5oLnNldChcIlgtR29vZy1BdXRoVXNlclwiLCB0aGlzLmkpO1xuICAgICAgICAvLyBVc2UgYXJyYXkgbm90YXRpb24gdG8gcHJldmVudCBtaW5pZmljYXRpb25cbiAgICAgICAgY29uc3QgdCA9IHRoaXMubCgpO1xuICAgICAgICByZXR1cm4gdCAmJiB0aGlzLmguc2V0KFwiQXV0aG9yaXphdGlvblwiLCB0KSwgdGhpcy5vICYmIHRoaXMuaC5zZXQoXCJYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW5cIiwgdGhpcy5vKSwgXG4gICAgICAgIHRoaXMuaDtcbiAgICB9XG59XG5cbi8qXG4gKiBQcm92aWRlcyB1c2VyIGNyZWRlbnRpYWxzIHJlcXVpcmVkIGZvciB0aGUgRmlyZXN0b3JlIEphdmFTY3JpcHQgU0RLXG4gKiB0byBhdXRoZW50aWNhdGUgdGhlIHVzZXIsIHVzaW5nIHRlY2huaXF1ZSB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlXG4gKiB0byBhcHBsaWNhdGlvbnMgaG9zdGVkIGJ5IEdvb2dsZS5cbiAqLyBjbGFzcyBLIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBuLCByKSB7XG4gICAgICAgIHRoaXMudCA9IHQsIHRoaXMuaSA9IGUsIHRoaXMubyA9IG4sIHRoaXMudSA9IHI7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBHKHRoaXMudCwgdGhpcy5pLCB0aGlzLm8sIHRoaXMudSkpO1xuICAgIH1cbiAgICBzdGFydCh0LCBlKSB7XG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVpZC5cbiAgICAgICAgdC5lbnF1ZXVlUmV0cnlhYmxlKCgoKSA9PiBlKGQuRklSU1RfUEFSVFkpKSk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge31cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7fVxufVxuXG5jbGFzcyBZIHtcbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0LCB0aGlzLnR5cGUgPSBcIkFwcENoZWNrXCIsIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAsIHQgJiYgdC5sZW5ndGggPiAwICYmIHRoaXMuaGVhZGVycy5zZXQoXCJ4LWZpcmViYXNlLWFwcGNoZWNrXCIsIHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblxuLyoqIEFwcENoZWNrIHRva2VuIHByb3ZpZGVyIGZvciB0aGUgTGl0ZSBTREsuICovIGNsYXNzIEgge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5tID0gdCwgdGhpcy5hcHBDaGVjayA9IG51bGwsIHQub25Jbml0KCh0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sgPSB0O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjayA/IHRoaXMuYXBwQ2hlY2suZ2V0VG9rZW4oKS50aGVuKCh0ID0+IHQgPyAoRShcInN0cmluZ1wiID09IHR5cGVvZiB0LnRva2VuKSwgXG4gICAgICAgIG5ldyBZKHQudG9rZW4pKSA6IG51bGwpKSA6IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkge31cbiAgICBzdGFydCh0LCBlKSB7fVxuICAgIHNodXRkb3duKCkge31cbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBDcmVkZW50aWFsc1Byb3ZpZGVyIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZlxuICogdGhlIGNyZWRlbnRpYWxzIHBhc3NlZCBpbi5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEoge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBEYXRhYmFzZUluZm8gdXNpbmcgdGhlIHByb3ZpZGVkIGhvc3QsIGRhdGFiYXNlSWQgYW5kXG4gICAgICogcGVyc2lzdGVuY2VLZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSB0byB1c2UuXG4gICAgICogQHBhcmFtIGFwcElkIC0gVGhlIEZpcmViYXNlIEFwcCBJZC5cbiAgICAgKiBAcGFyYW0gcGVyc2lzdGVuY2VLZXkgLSBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIEZpcmVzdG9yZSdzIGxvY2FsXG4gICAgICogc3RvcmFnZSAodXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBkYXRhYmFzZUlkKS5cbiAgICAgKiBAcGFyYW0gaG9zdCAtIFRoZSBGaXJlc3RvcmUgYmFja2VuZCBob3N0IHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIHNzbCAtIFdoZXRoZXIgdG8gdXNlIFNTTCB3aGVuIGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIGZvcmNlTG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZm9yY2VMb25nUG9sbGluZyBvcHRpb25cbiAgICAgKiB3aGVuIHVzaW5nIFdlYkNoYW5uZWwgYXMgdGhlIG5ldHdvcmsgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBhdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZGV0ZWN0QnVmZmVyaW5nUHJveHlcbiAgICAgKiBvcHRpb24gd2hlbiB1c2luZyBXZWJDaGFubmVsIGFzIHRoZSBuZXR3b3JrIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gdXNlRmV0Y2hTdHJlYW1zIFdoZXRoZXIgdG8gdXNlIHRoZSBGZXRjaCBBUEkgaW5zdGVhZCBvZlxuICAgICAqIFhNTEhUVFBSZXF1ZXN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgciwgcywgaSwgbywgdSkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSB0LCB0aGlzLmFwcElkID0gZSwgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IG4sIHRoaXMuaG9zdCA9IHIsIHRoaXMuc3NsID0gcywgXG4gICAgICAgIHRoaXMuZm9yY2VMb25nUG9sbGluZyA9IGksIHRoaXMuYXV0b0RldGVjdExvbmdQb2xsaW5nID0gbywgdGhpcy51c2VGZXRjaFN0cmVhbXMgPSB1O1xuICAgIH1cbn1cblxuLyoqIFRoZSBkZWZhdWx0IGRhdGFiYXNlIG5hbWUgZm9yIGEgcHJvamVjdC4gKi9cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGF0YWJhc2UgSUQgYSBGaXJlc3RvcmUgY2xpZW50IGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBYIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0gdCwgdGhpcy5kYXRhYmFzZSA9IGUgfHwgXCIoZGVmYXVsdClcIjtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFgoXCJcIiwgXCJcIik7XG4gICAgfVxuICAgIGdldCBpc0RlZmF1bHREYXRhYmFzZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiKGRlZmF1bHQpXCIgPT09IHRoaXMuZGF0YWJhc2U7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFggJiYgdC5wcm9qZWN0SWQgPT09IHRoaXMucHJvamVjdElkICYmIHQuZGF0YWJhc2UgPT09IHRoaXMuZGF0YWJhc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIFBhdGggcmVwcmVzZW50cyBhbiBvcmRlcmVkIHNlcXVlbmNlIG9mIHN0cmluZyBzZWdtZW50cy5cbiAqL1xuY2xhc3MgWiB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbikge1xuICAgICAgICB2b2lkIDAgPT09IGUgPyBlID0gMCA6IGUgPiB0Lmxlbmd0aCAmJiBiKCksIHZvaWQgMCA9PT0gbiA/IG4gPSB0Lmxlbmd0aCAtIGUgOiBuID4gdC5sZW5ndGggLSBlICYmIGIoKSwgXG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSB0LCB0aGlzLm9mZnNldCA9IGUsIHRoaXMubGVuID0gbjtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuO1xuICAgIH1cbiAgICBpc0VxdWFsKHQpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IFouY29tcGFyYXRvcih0aGlzLCB0KTtcbiAgICB9XG4gICAgY2hpbGQodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcbiAgICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBaID8gdC5mb3JFYWNoKCh0ID0+IHtcbiAgICAgICAgICAgIGUucHVzaCh0KTtcbiAgICAgICAgfSkpIDogZS5wdXNoKHQpLCB0aGlzLmNvbnN0cnVjdChlKTtcbiAgICB9XG4gICAgLyoqIFRoZSBpbmRleCBvZiBvbmUgcGFzdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBwYXRoLiAqLyAgICBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvcEZpcnN0KHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPSB2b2lkIDAgPT09IHQgPyAxIDogdCwgdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQgKyB0LCB0aGlzLmxlbmd0aCAtIHQpO1xuICAgIH1cbiAgICBwb3BMYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGZpcnN0U2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXRdO1xuICAgIH1cbiAgICBsYXN0U2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGdldCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzW3RoaXMub2Zmc2V0ICsgdF07XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAwID09PSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaXNQcmVmaXhPZih0KSB7XG4gICAgICAgIGlmICh0Lmxlbmd0aCA8IHRoaXMubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdGhpcy5sZW5ndGg7IGUrKykgaWYgKHRoaXMuZ2V0KGUpICE9PSB0LmdldChlKSkgcmV0dXJuICExO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGlzSW1tZWRpYXRlUGFyZW50T2YodCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggKyAxICE9PSB0Lmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMubGVuZ3RoOyBlKyspIGlmICh0aGlzLmdldChlKSAhPT0gdC5nZXQoZSkpIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmb3JFYWNoKHQpIHtcbiAgICAgICAgZm9yIChsZXQgZSA9IHRoaXMub2Zmc2V0LCBuID0gdGhpcy5saW1pdCgpOyBlIDwgbjsgZSsrKSB0KHRoaXMuc2VnbWVudHNbZV0pO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmF0b3IodCwgZSkge1xuICAgICAgICBjb25zdCBuID0gTWF0aC5taW4odC5sZW5ndGgsIGUubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBuOyByKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0LmdldChyKSwgcyA9IGUuZ2V0KHIpO1xuICAgICAgICAgICAgaWYgKG4gPCBzKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAobiA+IHMpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Lmxlbmd0aCA8IGUubGVuZ3RoID8gLTEgOiB0Lmxlbmd0aCA+IGUubGVuZ3RoID8gMSA6IDA7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgc2xhc2gtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgcmVzb3VyY2VzIChkb2N1bWVudHMgYW5kIGNvbGxlY3Rpb25zKVxuICogd2l0aGluIEZpcmVzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqLyBjbGFzcyB0dCBleHRlbmRzIFoge1xuICAgIGNvbnN0cnVjdCh0LCBlLCBuKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHQodCwgZSwgbik7XG4gICAgfVxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICAgICAgLy8gTk9URTogVGhlIGNsaWVudCBpcyBpZ25vcmFudCBvZiBhbnkgcGF0aCBzZWdtZW50cyBjb250YWluaW5nIGVzY2FwZVxuICAgICAgICAvLyBzZXF1ZW5jZXMgKGUuZy4gX19pZDEyM19fKSBhbmQganVzdCBwYXNzZXMgdGhlbSB0aHJvdWdoIHJhdyAodGhleSBleGlzdFxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmpvaW4oXCIvXCIpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXNvdXJjZSBwYXRoIGZyb20gdGhlIGdpdmVuIHNsYXNoLWRlbGltaXRlZCBzdHJpbmcuIElmIG11bHRpcGxlXG4gICAgICogYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYWxsIGNvbXBvbmVudHMgYXJlIGNvbWJpbmVkLiBMZWFkaW5nIGFuZCB0cmFpbGluZ1xuICAgICAqIHNsYXNoZXMgZnJvbSBhbGwgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICAgKi8gICAgc3RhdGljIGZyb21TdHJpbmcoLi4udCkge1xuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXG4gICAgICAgIC8vIHNlcXVlbmNlcyAoZS5nLiBfX2lkMTIzX18pIGFuZCBqdXN0IHBhc3NlcyB0aGVtIHRocm91Z2ggcmF3ICh0aGV5IGV4aXN0XG4gICAgICAgIC8vIGZvciBsZWdhY3kgcmVhc29ucyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGZyZXF1ZW50bHkpLlxuICAgICAgICBjb25zdCBlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiB0KSB7XG4gICAgICAgICAgICBpZiAobi5pbmRleE9mKFwiLy9cIikgPj0gMCkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgc2VnbWVudCAoJHtufSkuIFBhdGhzIG11c3Qgbm90IGNvbnRhaW4gLy8gaW4gdGhlbS5gKTtcbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWxpbmcgc2xhc2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaCguLi5uLnNwbGl0KFwiL1wiKS5maWx0ZXIoKHQgPT4gdC5sZW5ndGggPiAwKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdHQoZSk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHQoW10pO1xuICAgIH1cbn1cblxuY29uc3QgZXQgPSAvXltfYS16QS1aXVtfYS16QS1aMC05XSokLztcblxuLyoqXG4gKiBBIGRvdC1zZXBhcmF0ZWQgcGF0aCBmb3IgbmF2aWdhdGluZyBzdWItb2JqZWN0cyB3aXRoaW4gYSBkb2N1bWVudC5cbiAqIEBpbnRlcm5hbFxuICovIGNsYXNzIG50IGV4dGVuZHMgWiB7XG4gICAgY29uc3RydWN0KHQsIGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBudCh0LCBlLCBuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgY291bGQgYmUgdXNlZCBhcyBhIHNlZ21lbnQgaW4gYSBmaWVsZCBwYXRoXG4gICAgICogd2l0aG91dCBlc2NhcGluZy5cbiAgICAgKi8gICAgc3RhdGljIGlzVmFsaWRJZGVudGlmaWVyKHQpIHtcbiAgICAgICAgcmV0dXJuIGV0LnRlc3QodCk7XG4gICAgfVxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLm1hcCgodCA9PiAodCA9IHQucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL2AvZywgXCJcXFxcYFwiKSwgXG4gICAgICAgIG50LmlzVmFsaWRJZGVudGlmaWVyKHQpIHx8ICh0ID0gXCJgXCIgKyB0ICsgXCJgXCIpLCB0KSkpLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpZWxkIHJlZmVyZW5jZXMgdGhlIGtleSBvZiBhIGRvY3VtZW50LlxuICAgICAqLyAgICBpc0tleUZpZWxkKCkge1xuICAgICAgICByZXR1cm4gMSA9PT0gdGhpcy5sZW5ndGggJiYgXCJfX25hbWVfX1wiID09PSB0aGlzLmdldCgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIGRlc2lnbmF0aW5nIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cbiAgICAgKi8gICAgc3RhdGljIGtleUZpZWxkKCkge1xuICAgICAgICByZXR1cm4gbmV3IG50KFsgXCJfX25hbWVfX1wiIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBmaWVsZCBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gc2VydmVyLWZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiAtIFNwbGl0dGluZyB0aGUgZW1wdHkgc3RyaW5nIGlzIG5vdCBhbGxvd2VkIChmb3Igbm93IGF0IGxlYXN0KS5cbiAgICAgKiAtIEVtcHR5IHNlZ21lbnRzIHdpdGhpbiB0aGUgc3RyaW5nIChlLmcuIGlmIHRoZXJlIGFyZSB0d28gY29uc2VjdXRpdmVcbiAgICAgKiAgIHNlcGFyYXRvcnMpIGFyZSBub3QgYWxsb3dlZC5cbiAgICAgKlxuICAgICAqIFRPRE8oYi8zNzI0NDE1Nyk6IHdlIHNob3VsZCBtYWtlIHRoaXMgbW9yZSBzdHJpY3QuIFJpZ2h0IG5vdywgaXQgYWxsb3dzXG4gICAgICogbm9uLWlkZW50aWZpZXIgcGF0aCBjb21wb25lbnRzLCBldmVuIGlmIHRoZXkgYXJlbid0IGVzY2FwZWQuXG4gICAgICovICAgIHN0YXRpYyBmcm9tU2VydmVyRm9ybWF0KHQpIHtcbiAgICAgICAgY29uc3QgZSA9IFtdO1xuICAgICAgICBsZXQgbiA9IFwiXCIsIHIgPSAwO1xuICAgICAgICBjb25zdCBzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKDAgPT09IG4ubGVuZ3RoKSB0aHJvdyBuZXcgVShQLCBgSW52YWxpZCBmaWVsZCBwYXRoICgke3R9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGJlZ2luIHdpdGggJy4nLCBlbmQgd2l0aCAnLicsIG9yIGNvbnRhaW4gJy4uJ2ApO1xuICAgICAgICAgICAgZS5wdXNoKG4pLCBuID0gXCJcIjtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGkgPSAhMTtcbiAgICAgICAgZm9yICg7ciA8IHQubGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0W3JdO1xuICAgICAgICAgICAgaWYgKFwiXFxcXFwiID09PSBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIgKyAxID09PSB0Lmxlbmd0aCkgdGhyb3cgbmV3IFUoUCwgXCJQYXRoIGhhcyB0cmFpbGluZyBlc2NhcGUgY2hhcmFjdGVyOiBcIiArIHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0W3IgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoXCJcXFxcXCIgIT09IGUgJiYgXCIuXCIgIT09IGUgJiYgXCJgXCIgIT09IGUpIHRocm93IG5ldyBVKFAsIFwiUGF0aCBoYXMgaW52YWxpZCBlc2NhcGUgc2VxdWVuY2U6IFwiICsgdCk7XG4gICAgICAgICAgICAgICAgbiArPSBlLCByICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgXCJgXCIgPT09IGUgPyAoaSA9ICFpLCByKyspIDogXCIuXCIgIT09IGUgfHwgaSA/IChuICs9IGUsIHIrKykgOiAocygpLCByKyspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzKCksIGkpIHRocm93IG5ldyBVKFAsIFwiVW50ZXJtaW5hdGVkIGAgaW4gcGF0aDogXCIgKyB0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBudChlKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBudChbXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqLyBjbGFzcyBydCB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLnBhdGggPSB0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhdGgodCkge1xuICAgICAgICByZXR1cm4gbmV3IHJ0KHR0LmZyb21TdHJpbmcodCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU5hbWUodCkge1xuICAgICAgICByZXR1cm4gbmV3IHJ0KHR0LmZyb21TdHJpbmcodCkucG9wRmlyc3QoNSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnQodHQuZW1wdHlQYXRoKCkpO1xuICAgIH1cbiAgICBnZXQgY29sbGVjdGlvbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKS5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBpcyBpbiB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb25JZC4gKi8gICAgaGFzQ29sbGVjdGlvbklkKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGggPj0gMiAmJiB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKSA9PT0gdDtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gZ3JvdXAgKGkuZS4gdGhlIG5hbWUgb2YgdGhlIHBhcmVudCBjb2xsZWN0aW9uKSBmb3IgdGhpcyBrZXkuICovICAgIGdldENvbGxlY3Rpb25Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXQodGhpcy5wYXRoLmxlbmd0aCAtIDIpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIHBhcmVudCBjb2xsZWN0aW9uLiAqLyAgICBnZXRDb2xsZWN0aW9uUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3BMYXN0KCk7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdCAmJiAwID09PSB0dC5jb21wYXJhdG9yKHRoaXMucGF0aCwgdC5wYXRoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmF0b3IodCwgZSkge1xuICAgICAgICByZXR1cm4gdHQuY29tcGFyYXRvcih0LnBhdGgsIGUucGF0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0RvY3VtZW50S2V5KHQpIHtcbiAgICAgICAgcmV0dXJuIHQubGVuZ3RoICUgMiA9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGRvY3VtZW50IGtleSB3aXRoIHRoZSBnaXZlbiBzZWdtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byB0aGUgZG9jdW1lbnRcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBEb2N1bWVudEtleVxuICAgICAqLyAgICBzdGF0aWMgZnJvbVNlZ21lbnRzKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBydChuZXcgdHQodC5zbGljZSgpKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiBzdCh0LCBlLCBuKSB7XG4gICAgaWYgKCFuKSB0aHJvdyBuZXcgVShQLCBgRnVuY3Rpb24gJHt0fSgpIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSAke2V9LmApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHR3byBib29sZWFuIG9wdGlvbnMgYXJlIG5vdCBzZXQgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBpbnRlcm5hbFxuICovXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBkb2N1bWVudCAoaW5kaWNhdGVkIGJ5IHRoZSBmYWN0IGl0IGNvbnRhaW5zXG4gKiBhbiBldmVuIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxuICovXG5mdW5jdGlvbiBpdCh0KSB7XG4gICAgaWYgKCFydC5pc0RvY3VtZW50S2V5KHQpKSB0aHJvdyBuZXcgVShQLCBgSW52YWxpZCBkb2N1bWVudCByZWZlcmVuY2UuIERvY3VtZW50IHJlZmVyZW5jZXMgbXVzdCBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHt0fSBoYXMgJHt0Lmxlbmd0aH0uYCk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGNvbGxlY3Rpb24gKGluZGljYXRlZCBieSB0aGUgZmFjdCBpdFxuICogY29udGFpbnMgYW4gb2RkIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxuICovIGZ1bmN0aW9uIG90KHQpIHtcbiAgICBpZiAocnQuaXNEb2N1bWVudEtleSh0KSkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgY29sbGVjdGlvbiByZWZlcmVuY2UuIENvbGxlY3Rpb24gcmVmZXJlbmNlcyBtdXN0IGhhdmUgYW4gb2RkIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7dH0gaGFzICR7dC5sZW5ndGh9LmApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdCdzIGEgbm9uLW51bGwgb2JqZWN0IHdpdGhvdXQgYSBjdXN0b20gcHJvdG90eXBlXG4gKiAoaS5lLiBleGNsdWRlcyBBcnJheSwgRGF0ZSwgZXRjLikuXG4gKi9cbi8qKiBSZXR1cm5zIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHR5cGUgLyB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgaW5wdXQuICovXG5mdW5jdGlvbiB1dCh0KSB7XG4gICAgaWYgKHZvaWQgMCA9PT0gdCkgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgaWYgKG51bGwgPT09IHQpIHJldHVybiBcIm51bGxcIjtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgcmV0dXJuIHQubGVuZ3RoID4gMjAgJiYgKHQgPSBgJHt0LnN1YnN0cmluZygwLCAyMCl9Li4uYCksIFxuICAgIEpTT04uc3RyaW5naWZ5KHQpO1xuICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB0IHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiB0KSByZXR1cm4gXCJcIiArIHQ7XG4gICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFwiYW4gYXJyYXlcIjtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZSA9IFxuICAgICAgICAgICAgLyoqIHRyeSB0byBnZXQgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIG9iamVjdC4gKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodC5jb25zdHJ1Y3RvcikgcmV0dXJuIHQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICogQ2FzdHMgYG9iamAgdG8gYFRgLCBvcHRpb25hbGx5IHVud3JhcHBpbmcgQ29tcGF0IHR5cGVzIHRvIGV4cG9zZSB0aGVcbiAqIHVuZGVybHlpbmcgaW5zdGFuY2UuIFRocm93cyBpZiAgYG9iamAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBUYC5cbiAqXG4gKiBUaGlzIGNhc3QgaXMgdXNlZCBpbiB0aGUgTGl0ZSBhbmQgRnVsbCBTREsgdG8gdmVyaWZ5IGluc3RhbmNlIHR5cGVzIGZvclxuICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcHVibGljIEFQSS5cbiAqIEBpbnRlcm5hbFxuICovICh0KTtcbiAgICAgICAgICAgIHJldHVybiBlID8gYGEgY3VzdG9tICR7ZX0gb2JqZWN0YCA6IFwiYW4gb2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IFwiYSBmdW5jdGlvblwiIDogYigpO1xufVxuXG5mdW5jdGlvbiBjdCh0LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5lKSB7XG4gICAgaWYgKFwiX2RlbGVnYXRlXCIgaW4gdCAmJiAoXG4gICAgLy8gVW53cmFwIENvbXBhdCB0eXBlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdCA9IHQuX2RlbGVnYXRlKSwgISh0IGluc3RhbmNlb2YgZSkpIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gdC5jb25zdHJ1Y3Rvci5uYW1lKSB0aHJvdyBuZXcgVShQLCBcIlR5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGluc3RhbmNlLiBEaWQgeW91IHBhc3MgYSByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgU0RLP1wiKTtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbiA9IHV0KHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFUoUCwgYEV4cGVjdGVkIHR5cGUgJyR7ZS5uYW1lfScsIGJ1dCBpdCB3YXM6ICR7bn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gYXQodCwgZSkge1xuICAgIGlmIChlIDw9IDApIHRocm93IG5ldyBVKFAsIGBGdW5jdGlvbiAke3R9KCkgcmVxdWlyZXMgYSBwb3NpdGl2ZSBudW1iZXIsIGJ1dCBpdCB3YXM6ICR7ZX0uYCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHZhcmlhYmxlIGlzIGVpdGhlciB1bmRlZmluZWQgb3IgbnVsbC5cbiAqLyBmdW5jdGlvbiBodCh0KSB7XG4gICAgcmV0dXJuIG51bGwgPT0gdDtcbn1cblxuLyoqIFJldHVybnMgd2hldGhlciB0aGUgdmFsdWUgcmVwcmVzZW50cyAtMC4gKi8gZnVuY3Rpb24gbHQodCkge1xuICAgIC8vIERldGVjdCBpZiB0aGUgdmFsdWUgaXMgLTAuMC4gQmFzZWQgb24gcG9seWZpbGwgZnJvbVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgIHJldHVybiAwID09PSB0ICYmIDEgLyB0ID09IC0xIC8gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGFuZCBpbiB0aGUgc2FmZSBpbnRlZ2VyIHJhbmdlXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdCBmb3IgYmVpbmcgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgcmFuZ2VcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGZ0ID0ge1xuICAgIEJhdGNoR2V0RG9jdW1lbnRzOiBcImJhdGNoR2V0XCIsXG4gICAgQ29tbWl0OiBcImNvbW1pdFwiLFxuICAgIFJ1blF1ZXJ5OiBcInJ1blF1ZXJ5XCIsXG4gICAgUnVuQWdncmVnYXRpb25RdWVyeTogXCJydW5BZ2dyZWdhdGlvblF1ZXJ5XCJcbn07XG5cbi8qKlxuICogTWFwcyBSUEMgbmFtZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgUkVTVCBlbmRwb2ludCBuYW1lLlxuICpcbiAqIFdlIHVzZSBhcnJheSBub3RhdGlvbiB0byBhdm9pZCBtYW5nbGluZy5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRXJyb3IgQ29kZXMgZGVzY3JpYmluZyB0aGUgZGlmZmVyZW50IHdheXMgR1JQQyBjYW4gZmFpbC4gVGhlc2UgYXJlIGNvcGllZFxuICogZGlyZWN0bHkgZnJvbSBHUlBDJ3Mgc291cmNlcyBoZXJlOlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9iY2VlYzk0ZWE0ZmM1ZjAwODVkODEyMzVkOGUxYzA2Nzk4ZGMzNDFhL2luY2x1ZGUvZ3JwYyUyQiUyQi9pbXBsL2NvZGVnZW4vc3RhdHVzX2NvZGVfZW51bS5oXG4gKlxuICogSW1wb3J0YW50ISBUaGUgbmFtZXMgb2YgdGhlc2UgaWRlbnRpZmllcnMgbWF0dGVyIGJlY2F1c2UgdGhlIHN0cmluZyBmb3Jtc1xuICogYXJlIHVzZWQgZm9yIHJldmVyc2UgbG9va3VwcyBmcm9tIHRoZSB3ZWJjaGFubmVsIHN0cmVhbS4gRG8gTk9UIGNoYW5nZSB0aGVcbiAqIG5hbWVzIG9mIHRoZXNlIGlkZW50aWZpZXJzIG9yIGNoYW5nZSB0aGlzIGludG8gYSBjb25zdCBlbnVtLlxuICovXG52YXIgZHQsIHd0O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIEhUVFAgU3RhdHVzIENvZGUgdG8gdGhlIGVxdWl2YWxlbnQgZXJyb3IgY29kZS5cbiAqXG4gKiBAcGFyYW0gc3RhdHVzIC0gQW4gSFRUUCBTdGF0dXMgQ29kZSwgbGlrZSAyMDAsIDQwNCwgNTAzLCBldGMuXG4gKiBAcmV0dXJucyBUaGUgZXF1aXZhbGVudCBDb2RlLiBVbmtub3duIHN0YXR1cyBjb2RlcyBhcmUgbWFwcGVkIHRvXG4gKiAgICAgQ29kZS5VTktOT1dOLlxuICovXG5mdW5jdGlvbiBtdCh0KSB7XG4gICAgaWYgKHZvaWQgMCA9PT0gdCkgcmV0dXJuIGcoXCJSUENfRVJST1JcIiwgXCJIVFRQIGVycm9yIGhhcyBubyBzdGF0dXNcIiksIFI7XG4gICAgLy8gVGhlIGNhbm9uaWNhbCBlcnJvciBjb2RlcyBmb3IgR29vZ2xlIEFQSXMgWzFdIHNwZWNpZnkgbWFwcGluZyBvbnRvIEhUVFBcbiAgICAvLyBzdGF0dXMgY29kZXMgYnV0IHRoZSBtYXBwaW5nIGlzIG5vdCBiaWplY3RpdmUuIEluIGVhY2ggY2FzZSBvZiBhbWJpZ3VpdHlcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGNob29zZXMgYSBwcmltYXJ5IGVycm9yLlxuICAgIFxuICAgIC8vIFsxXVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZWFwaXMvYmxvYi9tYXN0ZXIvZ29vZ2xlL3JwYy9jb2RlLnByb3RvXG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSAyMDA6XG4gICAgICAgIC8vIE9LXG4gICAgICAgIHJldHVybiBUO1xuXG4gICAgICBjYXNlIDQwMDpcbiAgICAgICAgLy8gQmFkIFJlcXVlc3RcbiAgICAgICAgcmV0dXJuIFM7XG5cbiAgICAgICAgLy8gT3RoZXIgcG9zc2liaWxpdGllcyBiYXNlZCBvbiB0aGUgZm9yd2FyZCBtYXBwaW5nXG4gICAgICAgIC8vIHJldHVybiBDb2RlLklOVkFMSURfQVJHVU1FTlQ7XG4gICAgICAgIC8vIHJldHVybiBDb2RlLk9VVF9PRl9SQU5HRTtcbiAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgIC8vIFVuYXV0aG9yaXplZFxuICAgICAgICByZXR1cm4gRjtcblxuICAgICAgY2FzZSA0MDM6XG4gICAgICAgIC8vIEZvcmJpZGRlblxuICAgICAgICByZXR1cm4gRDtcblxuICAgICAgY2FzZSA0MDQ6XG4gICAgICAgIC8vIE5vdCBGb3VuZFxuICAgICAgICByZXR1cm4gJDtcblxuICAgICAgY2FzZSA0MDk6XG4gICAgICAgIC8vIENvbmZsaWN0XG4gICAgICAgIHJldHVybiBxO1xuXG4gICAgICAgIC8vIE90aGVyIHBvc3NpYmlsaXRpZXM6XG4gICAgICAgIC8vIHJldHVybiBDb2RlLkFMUkVBRFlfRVhJU1RTO1xuICAgICAgICAgICAgICBjYXNlIDQxNjpcbiAgICAgICAgLy8gUmFuZ2UgTm90IFNhdGlzZmlhYmxlXG4gICAgICAgIHJldHVybiBPO1xuXG4gICAgICBjYXNlIDQyOTpcbiAgICAgICAgLy8gVG9vIE1hbnkgUmVxdWVzdHNcbiAgICAgICAgcmV0dXJuIHg7XG5cbiAgICAgIGNhc2UgNDk5OlxuICAgICAgICAvLyBDbGllbnQgQ2xvc2VkIFJlcXVlc3RcbiAgICAgICAgcmV0dXJuIEE7XG5cbiAgICAgIGNhc2UgNTAwOlxuICAgICAgICAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgcmV0dXJuIFI7XG5cbiAgICAgICAgLy8gT3RoZXIgcG9zc2liaWxpdGllczpcbiAgICAgICAgLy8gcmV0dXJuIENvZGUuSU5URVJOQUw7XG4gICAgICAgIC8vIHJldHVybiBDb2RlLkRBVEFfTE9TUztcbiAgICAgICAgICAgICAgY2FzZSA1MDE6XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWRcbiAgICAgICAgcmV0dXJuIGs7XG5cbiAgICAgIGNhc2UgNTAzOlxuICAgICAgICAvLyBTZXJ2aWNlIFVuYXZhaWxhYmxlXG4gICAgICAgIHJldHVybiBMO1xuXG4gICAgICBjYXNlIDUwNDpcbiAgICAgICAgLy8gR2F0ZXdheSBUaW1lb3V0XG4gICAgICAgIHJldHVybiBWO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdCA+PSAyMDAgJiYgdCA8IDMwMCA/IFQgOiB0ID49IDQwMCAmJiB0IDwgNTAwID8gUyA6IHQgPj0gNTAwICYmIHQgPCA2MDAgPyBDIDogUjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgUmVzdC1iYXNlZCBjb25uZWN0aW9uIHRoYXQgcmVsaWVzIG9uIHRoZSBuYXRpdmUgSFRUUCBzdGFja1xuICogKGUuZy4gYGZldGNoYCBvciBhIHBvbHlmaWxsKS5cbiAqLyAod3QgPSBkdCB8fCAoZHQgPSB7fSkpW3d0Lk9LID0gMF0gPSBcIk9LXCIsIHd0W3d0LkNBTkNFTExFRCA9IDFdID0gXCJDQU5DRUxMRURcIiwgXG53dFt3dC5VTktOT1dOID0gMl0gPSBcIlVOS05PV05cIiwgd3Rbd3QuSU5WQUxJRF9BUkdVTUVOVCA9IDNdID0gXCJJTlZBTElEX0FSR1VNRU5UXCIsIFxud3Rbd3QuREVBRExJTkVfRVhDRUVERUQgPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIiwgd3Rbd3QuTk9UX0ZPVU5EID0gNV0gPSBcIk5PVF9GT1VORFwiLCBcbnd0W3d0LkFMUkVBRFlfRVhJU1RTID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCIsIHd0W3d0LlBFUk1JU1NJT05fREVOSUVEID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCIsIFxud3Rbd3QuVU5BVVRIRU5USUNBVEVEID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIiwgd3Rbd3QuUkVTT1VSQ0VfRVhIQVVTVEVEID0gOF0gPSBcIlJFU09VUkNFX0VYSEFVU1RFRFwiLCBcbnd0W3d0LkZBSUxFRF9QUkVDT05ESVRJT04gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLCB3dFt3dC5BQk9SVEVEID0gMTBdID0gXCJBQk9SVEVEXCIsIFxud3Rbd3QuT1VUX09GX1JBTkdFID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIiwgd3Rbd3QuVU5JTVBMRU1FTlRFRCA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiLCBcbnd0W3d0LklOVEVSTkFMID0gMTNdID0gXCJJTlRFUk5BTFwiLCB3dFt3dC5VTkFWQUlMQUJMRSA9IDE0XSA9IFwiVU5BVkFJTEFCTEVcIiwgd3Rbd3QuREFUQV9MT1NTID0gMTVdID0gXCJEQVRBX0xPU1NcIjtcblxuY2xhc3MgcHQgZXh0ZW5kcyBcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFJlc3QtYmFzZWQgY29ubmVjdGlvbnMgdG8gdGhlIGJhY2tlbmQgKFdlYkNoYW5uZWwgYW5kXG4gKiBIVFRQKS5cbiAqL1xuY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSB0LCB0aGlzLmRhdGFiYXNlSWQgPSB0LmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGUgPSB0LnNzbCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgICAgICB0aGlzLnAgPSBlICsgXCI6Ly9cIiArIHQuaG9zdCwgdGhpcy5nID0gXCJwcm9qZWN0cy9cIiArIHRoaXMuZGF0YWJhc2VJZC5wcm9qZWN0SWQgKyBcIi9kYXRhYmFzZXMvXCIgKyB0aGlzLmRhdGFiYXNlSWQuZGF0YWJhc2UgKyBcIi9kb2N1bWVudHNcIjtcbiAgICB9XG4gICAgZ2V0IHYoKSB7XG4gICAgICAgIC8vIEJvdGggYGludm9rZVJQQygpYCBhbmQgYGludm9rZVN0cmVhbWluZ1JQQygpYCB1c2UgdGhlaXIgYHBhdGhgIGFyZ3VtZW50cyB0byBkZXRlcm1pbmVcbiAgICAgICAgLy8gd2hlcmUgdG8gcnVuIHRoZSBxdWVyeSwgYW5kIGV4cGVjdCB0aGUgYHJlcXVlc3RgIHRvIE5PVCBzcGVjaWZ5IHRoZSBcInBhdGhcIi5cbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBJKHQsIGUsIG4sIHIsIHMpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuVCh0LCBlKTtcbiAgICAgICAgeShcIlJlc3RDb25uZWN0aW9uXCIsIFwiU2VuZGluZzogXCIsIGksIG4pO1xuICAgICAgICBjb25zdCBvID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLkEobywgciwgcyksIHRoaXMuUih0LCBpLCBvLCBuKS50aGVuKCh0ID0+ICh5KFwiUmVzdENvbm5lY3Rpb25cIiwgXCJSZWNlaXZlZDogXCIsIHQpLCBcbiAgICAgICAgdCkpLCAoZSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBfKFwiUmVzdENvbm5lY3Rpb25cIiwgYCR7dH0gZmFpbGVkIHdpdGggZXJyb3I6IGAsIGUsIFwidXJsOiBcIiwgaSwgXCJyZXF1ZXN0OlwiLCBuKSwgXG4gICAgICAgICAgICBlO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIFAodCwgZSwgbiwgciwgcywgaSkge1xuICAgICAgICAvLyBUaGUgUkVTVCBBUEkgYXV0b21hdGljYWxseSBhZ2dyZWdhdGVzIGFsbCBvZiB0aGUgc3RyZWFtZWQgcmVzdWx0cywgc28gd2VcbiAgICAgICAgLy8gY2FuIGp1c3QgdXNlIHRoZSBub3JtYWwgaW52b2tlKCkgbWV0aG9kLlxuICAgICAgICByZXR1cm4gdGhpcy5JKHQsIGUsIG4sIHIsIHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgaGVhZGVycyBmb3IgYSByZXF1ZXN0LCBhZGRpbmcgYW55IGF1dGhvcml6YXRpb24gdG9rZW4gaWZcbiAgICAgKiBwcmVzZW50IGFuZCBhbnkgYWRkaXRpb25hbCBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi8gICAgQSh0LCBlLCBuKSB7XG4gICAgICAgIHRbXCJYLUdvb2ctQXBpLUNsaWVudFwiXSA9IFwiZ2wtanMvIGZpcmUvXCIgKyB3LCBcbiAgICAgICAgLy8gQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluIHdpbGwgYXZvaWQgcHJlZmxpZ2h0IHJlcXVlc3RzIHdoaWNoIG1pZ2h0XG4gICAgICAgIC8vIG1lc3Mgd2l0aCBDT1JTIGFuZCByZWRpcmVjdHMgYnkgcHJveGllcy4gSWYgd2UgYWRkIGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBjaGFuZ2UgdGhpcyBjb2RlIHRvIHBvdGVudGlhbGx5IHVzZSB0aGUgJGh0dHBPdmVyd3JpdGVcbiAgICAgICAgLy8gcGFyYW1ldGVyIHN1cHBvcnRlZCBieSBFU0YgdG8gYXZvaWQgdHJpZ2dlcmluZyBwcmVmbGlnaHQgcmVxdWVzdHMuXG4gICAgICAgIHRbXCJDb250ZW50LVR5cGVcIl0gPSBcInRleHQvcGxhaW5cIiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQgJiYgKHRbXCJYLUZpcmViYXNlLUdNUElEXCJdID0gdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpLCBcbiAgICAgICAgZSAmJiBlLmhlYWRlcnMuZm9yRWFjaCgoKGUsIG4pID0+IHRbbl0gPSBlKSksIG4gJiYgbi5oZWFkZXJzLmZvckVhY2goKChlLCBuKSA9PiB0W25dID0gZSkpO1xuICAgIH1cbiAgICBUKHQsIGUpIHtcbiAgICAgICAgY29uc3QgbiA9IGZ0W3RdO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5wfS92MS8ke2V9OiR7bn1gO1xuICAgIH1cbn0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhYmFzZUluZm8gLSBUaGUgY29ubmVjdGlvbiBpbmZvLlxuICAgICAqIEBwYXJhbSBmZXRjaEltcGwgLSBgZmV0Y2hgIG9yIGEgUG9seWZpbGwgdGhhdCBpbXBsZW1lbnRzIHRoZSBmZXRjaCBBUEkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcih0KSwgdGhpcy5WID0gZTtcbiAgICB9XG4gICAgJCh0LCBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgYnkgRmV0Y2hDb25uZWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBSKHQsIGUsIG4sIHIpIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIGNvbnN0IGkgPSBKU09OLnN0cmluZ2lmeShyKTtcbiAgICAgICAgbGV0IG87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvID0gYXdhaXQgdGhpcy5WKGUsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG4sXG4gICAgICAgICAgICAgICAgYm9keTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0O1xuICAgICAgICAgICAgdGhyb3cgbmV3IFUobXQoZS5zdGF0dXMpLCBcIlJlcXVlc3QgZmFpbGVkIHdpdGggZXJyb3I6IFwiICsgZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW8ub2spIHtcbiAgICAgICAgICAgIGxldCB0ID0gYXdhaXQgby5qc29uKCk7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHQpICYmICh0ID0gdFswXSk7XG4gICAgICAgICAgICBjb25zdCBlID0gbnVsbCA9PT0gKHMgPSBudWxsID09IHQgPyB2b2lkIDAgOiB0LmVycm9yKSB8fCB2b2lkIDAgPT09IHMgPyB2b2lkIDAgOiBzLm1lc3NhZ2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVShtdChvLnN0YXR1cyksIGBSZXF1ZXN0IGZhaWxlZCB3aXRoIGVycm9yOiAke251bGwgIT0gZSA/IGUgOiBvLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8uanNvbigpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBJbml0aWFsaXplcyB0aGUgSFRUUCBjb25uZWN0aW9uIGZvciB0aGUgUkVTVCBBUEkuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYG5CeXRlc2Agb2YgcmFuZG9tIGJ5dGVzLlxuICpcbiAqIElmIGBuQnl0ZXMgPCAwYCAsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiB5dCh0KSB7XG4gICAgLy8gUG9seWZpbGxzIGZvciBJRSBhbmQgV2ViV29ya2VyIGJ5IHVzaW5nIGBzZWxmYCBhbmQgYG1zQ3J5cHRvYCB3aGVuIGBjcnlwdG9gIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgY29uc3QgZSA9IFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiAmJiAoc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0byksIG4gPSBuZXcgVWludDhBcnJheSh0KTtcbiAgICBpZiAoZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuZ2V0UmFuZG9tVmFsdWVzKSBlLmdldFJhbmRvbVZhbHVlcyhuKTsgZWxzZSBcbiAgICAvLyBGYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tXG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0OyBlKyspIG5bZV0gPSBNYXRoLmZsb29yKDI1NiAqIE1hdGgucmFuZG9tKCkpO1xuICAgIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyBndCB7XG4gICAgc3RhdGljIE4oKSB7XG4gICAgICAgIC8vIEFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgIGNvbnN0IHQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCIsIGUgPSBNYXRoLmZsb29yKDI1NiAvIHQubGVuZ3RoKSAqIHQubGVuZ3RoO1xuICAgICAgICAvLyBUaGUgbGFyZ2VzdCBieXRlIHZhbHVlIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiBgY2hhci5sZW5ndGhgLlxuICAgICAgICAgICAgICAgIGxldCBuID0gXCJcIjtcbiAgICAgICAgZm9yICg7bi5sZW5ndGggPCAyMDsgKSB7XG4gICAgICAgICAgICBjb25zdCByID0geXQoNDApO1xuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCByLmxlbmd0aDsgKytzKSBcbiAgICAgICAgICAgIC8vIE9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IGFyZSBbMCwgbWF4TXVsdGlwbGUpLCB0aGlzIGVuc3VyZXMgdGhleSBjYW5cbiAgICAgICAgICAgIC8vIGJlIGV2ZW5seSBtYXBwZWQgdG8gaW5kaWNlcyBvZiBgY2hhcnNgIHZpYSBhIG1vZHVsbyBvcGVyYXRpb24uXG4gICAgICAgICAgICBuLmxlbmd0aCA8IDIwICYmIHJbc10gPCBlICYmIChuICs9IHQuY2hhckF0KHJbc10gJSB0Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX3QodCwgZSkge1xuICAgIHJldHVybiB0IDwgZSA/IC0xIDogdCA+IGUgPyAxIDogMDtcbn1cblxuLyoqIEhlbHBlciB0byBjb21wYXJlIGFycmF5cyB1c2luZyBpc0VxdWFsKCkuICovIGZ1bmN0aW9uIHZ0KHQsIGUsIG4pIHtcbiAgICByZXR1cm4gdC5sZW5ndGggPT09IGUubGVuZ3RoICYmIHQuZXZlcnkoKCh0LCByKSA9PiBuKHQsIGVbcl0pKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uIGJ0KHQpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgZm9yIChjb25zdCBuIGluIHQpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBuKSAmJiBlKys7XG4gICAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIEV0KHQsIGUpIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gdCkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG4pICYmIGUobiwgdFtuXSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEltbXV0YWJsZSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBcInByb3RvXCIgYnl0ZSBzdHJpbmcuXG4gKlxuICogUHJvdG8gYnl0ZSBzdHJpbmdzIGNhbiBlaXRoZXIgYmUgQmFzZTY0LWVuY29kZWQgc3RyaW5ncyBvciBVaW50OEFycmF5cyB3aGVuXG4gKiBzZW50IG9uIHRoZSB3aXJlLiBUaGlzIGNsYXNzIGFic3RyYWN0cyBhd2F5IHRoaXMgZGlmZmVyZW50aWF0aW9uIGJ5IGhvbGRpbmdcbiAqIHRoZSBwcm90byBieXRlIHN0cmluZyBpbiBhIGNvbW1vbiBjbGFzcyB0aGF0IG11c3QgYmUgY29udmVydGVkIGludG8gYSBzdHJpbmdcbiAqIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgcHJvdG8uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgSXQge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5iaW5hcnlTdHJpbmcgPSB0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBhdG9iKHQpO1xuICAgICAgICByZXR1cm4gbmV3IEl0KGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkodCkge1xuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTsgUmVtb3ZlIHRoZSBjb3B5IG9mIHRoZSBieXRlIHN0cmluZyBoZXJlIGFzIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIGlzIGZyZXF1ZW50bHkgY2FsbGVkIGR1cmluZyBpbmRleGluZy5cbiAgICAgICAgY29uc3QgZSA9IFxuICAgICAgICAvKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIFVpbnQ4YXJyYXkgdG8gYSBiaW5hcnkgc3RyaW5nLlxuICovXG4gICAgICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGxldCBlID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7ICsrbikgZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRbbl0pO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhIGJpbmFyeSBzdHJpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqLyAodCk7XG4gICAgICAgIHJldHVybiBuZXcgSXQoZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgdCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB0IDwgdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KHQrKyksXG4gICAgICAgICAgICAgICAgZG9uZTogITFcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkb25lOiAhMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuIHQgPSB0aGlzLmJpbmFyeVN0cmluZywgYnRvYSh0KTtcbiAgICAgICAgLyoqIENvbnZlcnRzIGEgYmluYXJ5IHN0cmluZyB0byBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZy4gKi9cbiAgICAgICAgdmFyIHQ7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIGVbbl0gPSB0LmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuICAgICAgICAvLyBBIFJlZ0V4cCBtYXRjaGluZyBJU08gODYwMSBVVEMgdGltZXN0YW1wcyB3aXRoIG9wdGlvbmFsIGZyYWN0aW9uLlxuICAgICAgICAodGhpcy5iaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICBhcHByb3hpbWF0ZUJ5dGVTaXplKCkge1xuICAgICAgICByZXR1cm4gMiAqIHRoaXMuYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY29tcGFyZVRvKHQpIHtcbiAgICAgICAgcmV0dXJuIF90KHRoaXMuYmluYXJ5U3RyaW5nLCB0LmJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcgPT09IHQuYmluYXJ5U3RyaW5nO1xuICAgIH1cbn1cblxuSXQuRU1QVFlfQllURV9TVFJJTkcgPSBuZXcgSXQoXCJcIik7XG5cbmNvbnN0IFR0ID0gbmV3IFJlZ0V4cCgvXlxcZHs0fS1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkKD86XFwuKFxcZCspKT9aJC8pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB2YWx1ZXMgZm9yIGEgdGltZXN0YW1wIHZhbHVlIGludG8gYSBcInNlY29uZHMgYW5kXG4gKiBuYW5vc1wiIHJlcHJlc2VudGF0aW9uLlxuICovIGZ1bmN0aW9uIEF0KHQpIHtcbiAgICAvLyBUaGUganNvbiBpbnRlcmZhY2UgKGZvciB0aGUgYnJvd3Nlcikgd2lsbCByZXR1cm4gYW4gaXNvIHRpbWVzdGFtcCBzdHJpbmcsXG4gICAgLy8gd2hpbGUgdGhlIHByb3RvIGpzIGxpYnJhcnkgKGZvciBub2RlKSB3aWxsIHJldHVybiBhXG4gICAgLy8gZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBpbnN0YW5jZS5cbiAgICBpZiAoRSghIXQpLCBcInN0cmluZ1wiID09IHR5cGVvZiB0KSB7XG4gICAgICAgIC8vIFRoZSBkYXRlIHN0cmluZyBjYW4gaGF2ZSBoaWdoZXIgcHJlY2lzaW9uIChuYW5vcykgdGhhbiB0aGUgRGF0ZSBjbGFzc1xuICAgICAgICAvLyAobWlsbGlzKSwgc28gd2UgZG8gc29tZSBjdXN0b20gcGFyc2luZyBoZXJlLlxuICAgICAgICAvLyBQYXJzZSB0aGUgbmFub3MgcmlnaHQgb3V0IG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGxldCBlID0gMDtcbiAgICAgICAgY29uc3QgbiA9IFR0LmV4ZWModCk7XG4gICAgICAgIGlmIChFKCEhbiksIG5bMV0pIHtcbiAgICAgICAgICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gb3V0IHRvIDkgZGlnaXRzIChuYW5vcykuXG4gICAgICAgICAgICBsZXQgdCA9IG5bMV07XG4gICAgICAgICAgICB0ID0gKHQgKyBcIjAwMDAwMDAwMFwiKS5zdWJzdHIoMCwgOSksIGUgPSBOdW1iZXIodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgdGhlIGRhdGUgdG8gZ2V0IHRoZSBzZWNvbmRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBuZXcgRGF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlY29uZHM6IE1hdGguZmxvb3Ioci5nZXRUaW1lKCkgLyAxZTMpLFxuICAgICAgICAgICAgbmFub3M6IGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogUnQodC5zZWNvbmRzKSxcbiAgICAgICAgbmFub3M6IFJ0KHQubmFub3MpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIG51bWJlcnMgaW50byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICogUmV0dXJucyAwIGlmIHRoZSB2YWx1ZSBpcyBub3QgbnVtZXJpYy5cbiAqLyBmdW5jdGlvbiBSdCh0KSB7XG4gICAgLy8gVE9ETyhiam9ybmljayk6IEhhbmRsZSBpbnQ2NCBncmVhdGVyIHRoYW4gNTMgYml0cy5cbiAgICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgdCA/IHQgOiBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gTnVtYmVyKHQpIDogMDtcbn1cblxuLyoqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgQmxvYnMgaW50byBhIEJ5dGVTdHJpbmcuICovIGZ1bmN0aW9uIFB0KHQpIHtcbiAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IEl0LmZyb21CYXNlNjRTdHJpbmcodCkgOiBJdC5mcm9tVWludDhBcnJheSh0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIFRoZSBlYXJsaWVzdCBkYXRlIHN1cHBvcnRlZCBieSBGaXJlc3RvcmUgdGltZXN0YW1wcyAoMDAwMS0wMS0wMVQwMDowMDowMFopLlxuLyoqXG4gKiBBIGBUaW1lc3RhbXBgIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3JcbiAqIGNhbGVuZGFyLCByZXByZXNlbnRlZCBhcyBzZWNvbmRzIGFuZCBmcmFjdGlvbnMgb2Ygc2Vjb25kcyBhdCBuYW5vc2Vjb25kXG4gKiByZXNvbHV0aW9uIGluIFVUQyBFcG9jaCB0aW1lLlxuICpcbiAqIEl0IGlzIGVuY29kZWQgdXNpbmcgdGhlIFByb2xlcHRpYyBHcmVnb3JpYW4gQ2FsZW5kYXIgd2hpY2ggZXh0ZW5kcyB0aGVcbiAqIEdyZWdvcmlhbiBjYWxlbmRhciBiYWNrd2FyZHMgdG8geWVhciBvbmUuIEl0IGlzIGVuY29kZWQgYXNzdW1pbmcgYWxsIG1pbnV0ZXNcbiAqIGFyZSA2MCBzZWNvbmRzIGxvbmcsIGkuZS4gbGVhcCBzZWNvbmRzIGFyZSBcInNtZWFyZWRcIiBzbyB0aGF0IG5vIGxlYXAgc2Vjb25kXG4gKiB0YWJsZSBpcyBuZWVkZWQgZm9yIGludGVycHJldGF0aW9uLiBSYW5nZSBpcyBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gKiA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouXG4gKlxuICogRm9yIGV4YW1wbGVzIGFuZCBmdXJ0aGVyIHNwZWNpZmljYXRpb25zLCByZWZlciB0byB0aGVcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3Byb3RvYnVmL2Jsb2IvbWFzdGVyL3NyYy9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvIHwgVGltZXN0YW1wIGRlZmluaXRpb259LlxuICovXG5jbGFzcyBWdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXG4gICAgICogICAgIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAgICAgKiAgICAgOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAqIEBwYXJhbSBuYW5vc2Vjb25kcyAtIFRoZSBub24tbmVnYXRpdmUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmRcbiAgICAgKiAgICAgcmVzb2x1dGlvbi4gTmVnYXRpdmUgc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmVcbiAgICAgKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zZWNvbmRzIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZVxuICAgICAqICAgICBmcm9tIDAgdG8gOTk5LDk5OSw5OTkgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxuICAgICAqL1xuICAgIHQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLipcbiAgICAgKi9cbiAgICBlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlY29uZHMgPSB0LCB0aGlzLm5hbm9zZWNvbmRzID0gZSwgZSA8IDApIHRocm93IG5ldyBVKFAsIFwiVGltZXN0YW1wIG5hbm9zZWNvbmRzIG91dCBvZiByYW5nZTogXCIgKyBlKTtcbiAgICAgICAgaWYgKGUgPj0gMWU5KSB0aHJvdyBuZXcgVShQLCBcIlRpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6IFwiICsgZSk7XG4gICAgICAgIGlmICh0IDwgLTYyMTM1NTk2ODAwKSB0aHJvdyBuZXcgVShQLCBcIlRpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogXCIgKyB0KTtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJyZWFrIGluIHRoZSB5ZWFyIDEwLDAwMC5cbiAgICAgICAgICAgICAgICBpZiAodCA+PSAyNTM0MDIzMDA4MDApIHRocm93IG5ldyBVKFAsIFwiVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiBcIiArIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCB3aXRoIHRoZSBjdXJyZW50IGRhdGUsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBuZXcgdGltZXN0YW1wIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBkYXRlLlxuICAgICAqLyAgICBzdGF0aWMgbm93KCkge1xuICAgICAgICByZXR1cm4gVnQuZnJvbU1pbGxpcyhEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gaW5pdGlhbGl6ZSB0aGUgYFRpbWVzdGFtcGAgZnJvbS5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cbiAgICAgKiAgICAgZGF0ZS5cbiAgICAgKi8gICAgc3RhdGljIGZyb21EYXRlKHQpIHtcbiAgICAgICAgcmV0dXJuIFZ0LmZyb21NaWxsaXModC5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbGxpc2Vjb25kcyAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgVW5peCBlcG9jaFxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cbiAgICAgKiAgICAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICAgKi8gICAgc3RhdGljIGZyb21NaWxsaXModCkge1xuICAgICAgICBjb25zdCBlID0gTWF0aC5mbG9vcih0IC8gMWUzKSwgbiA9IE1hdGguZmxvb3IoMWU2ICogKHQgLSAxZTMgKiBlKSk7XG4gICAgICAgIHJldHVybiBuZXcgVnQoZSwgbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QuIFRoaXMgY29udmVyc2lvblxuICAgICAqIGNhdXNlcyBhIGxvc3Mgb2YgcHJlY2lzaW9uIHNpbmNlIGBEYXRlYCBvYmplY3RzIG9ubHkgc3VwcG9ydCBtaWxsaXNlY29uZFxuICAgICAqIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhc1xuICAgICAqICAgICB0aGlzIGBUaW1lc3RhbXBgLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKi8gICAgdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b01pbGxpcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIG51bWVyaWMgdGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMgc2luY2VcbiAgICAgKiBlcG9jaCkuIFRoaXMgb3BlcmF0aW9uIGNhdXNlcyBhIGxvc3Mgb2YgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBvaW50IGluIHRpbWUgY29ycmVzcG9uZGluZyB0byB0aGlzIHRpbWVzdGFtcCwgcmVwcmVzZW50ZWQgYXNcbiAgICAgKiAgICAgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAgICAgKi8gICAgdG9NaWxsaXMoKSB7XG4gICAgICAgIHJldHVybiAxZTMgKiB0aGlzLnNlY29uZHMgKyB0aGlzLm5hbm9zZWNvbmRzIC8gMWU2O1xuICAgIH1cbiAgICBfY29tcGFyZVRvKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcyA9PT0gdC5zZWNvbmRzID8gX3QodGhpcy5uYW5vc2Vjb25kcywgdC5uYW5vc2Vjb25kcykgOiBfdCh0aGlzLnNlY29uZHMsIHQuc2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBUaW1lc3RhbXBgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYFRpbWVzdGFtcGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgVGltZXN0YW1wYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqLyAgICBpc0VxdWFsKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuc2Vjb25kcyA9PT0gdGhpcy5zZWNvbmRzICYmIHQubmFub3NlY29uZHMgPT09IHRoaXMubmFub3NlY29uZHM7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBUaW1lc3RhbXBgLiAqLyAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiVGltZXN0YW1wKHNlY29uZHM9XCIgKyB0aGlzLnNlY29uZHMgKyBcIiwgbmFub3NlY29uZHM9XCIgKyB0aGlzLm5hbm9zZWNvbmRzICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgVGltZXN0YW1wYC4gKi8gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vjb25kczogdGhpcy5zZWNvbmRzLFxuICAgICAgICAgICAgbmFub3NlY29uZHM6IHRoaXMubmFub3NlY29uZHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBvYmplY3QgdG8gYSBwcmltaXRpdmUgc3RyaW5nLCB3aGljaCBhbGxvd3MgYFRpbWVzdGFtcGAgb2JqZWN0c1xuICAgICAqIHRvIGJlIGNvbXBhcmVkIHVzaW5nIHRoZSBgPmAsIGA8PWAsIGA+PWAgYW5kIGA+YCBvcGVyYXRvcnMuXG4gICAgICovICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gPHNlY29uZHM+LjxuYW5vc2Vjb25kcz4gd2hlcmVcbiAgICAgICAgLy8gPHNlY29uZHM+IGlzIHRyYW5zbGF0ZWQgdG8gaGF2ZSBhIG5vbi1uZWdhdGl2ZSB2YWx1ZSBhbmQgYm90aCA8c2Vjb25kcz5cbiAgICAgICAgLy8gYW5kIDxuYW5vc2Vjb25kcz4gYXJlIGxlZnQtcGFkZGVkIHdpdGggemVyb2VzIHRvIGJlIGEgY29uc2lzdGVudCBsZW5ndGguXG4gICAgICAgIC8vIFN0cmluZ3Mgd2l0aCB0aGlzIGZvcm1hdCB0aGVuIGhhdmUgYSBsZXhpb2dyYXBoaWNhbCBvcmRlcmluZyB0aGF0IG1hdGNoZXNcbiAgICAgICAgLy8gdGhlIGV4cGVjdGVkIG9yZGVyaW5nLiBUaGUgPHNlY29uZHM+IHRyYW5zbGF0aW9uIGlzIGRvbmUgdG8gYXZvaWQgaGF2aW5nXG4gICAgICAgIC8vIGEgbGVhZGluZyBuZWdhdGl2ZSBzaWduIChpLmUuIGEgbGVhZGluZyAnLScgY2hhcmFjdGVyKSBpbiBpdHMgc3RyaW5nXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3aGljaCB3b3VsZCBhZmZlY3QgaXRzIGxleGlvZ3JhcGhpY2FsIG9yZGVyaW5nLlxuICAgICAgICBjb25zdCB0ID0gdGhpcy5zZWNvbmRzIC0gLTYyMTM1NTk2ODAwO1xuICAgICAgICAvLyBOb3RlOiBVcCB0byAxMiBkZWNpbWFsIGRpZ2l0cyBhcmUgcmVxdWlyZWQgdG8gcmVwcmVzZW50IGFsbCB2YWxpZFxuICAgICAgICAvLyAnc2Vjb25kcycgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodCkucGFkU3RhcnQoMTIsIFwiMFwiKSArIFwiLlwiICsgU3RyaW5nKHRoaXMubmFub3NlY29uZHMpLnBhZFN0YXJ0KDksIFwiMFwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2NhbGx5LWFwcGxpZWQgU2VydmVyVGltZXN0YW1wLlxuICpcbiAqIFNlcnZlciBUaW1lc3RhbXBzIGFyZSBiYWNrZWQgYnkgTWFwVmFsdWVzIHRoYXQgY29udGFpbiBhbiBpbnRlcm5hbCBmaWVsZFxuICogYF9fdHlwZV9fYCB3aXRoIGEgdmFsdWUgb2YgYHNlcnZlcl90aW1lc3RhbXBgLiBUaGUgcHJldmlvdXMgdmFsdWUgYW5kIGxvY2FsXG4gKiB3cml0ZSB0aW1lIGFyZSBzdG9yZWQgaW4gaXRzIGBfX3ByZXZpb3VzX3ZhbHVlX19gIGFuZCBgX19sb2NhbF93cml0ZV90aW1lX19gXG4gKiBmaWVsZHMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIE5vdGVzOlxuICogLSBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgYXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhXG4gKiAgIHRyYW5zZm9ybS4gVGhleSBjYW4gb25seSBleGlzdCBpbiB0aGUgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBUaGVyZWZvcmVcbiAqICAgdGhleSBkbyBub3QgbmVlZCB0byBiZSBwYXJzZWQgb3Igc2VyaWFsaXplZC5cbiAqIC0gV2hlbiBldmFsdWF0ZWQgbG9jYWxseSAoZS5nLiBmb3Igc25hcHNob3QuZGF0YSgpKSwgdGhleSBieSBkZWZhdWx0XG4gKiAgIGV2YWx1YXRlIHRvIGBudWxsYC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgY29uZmlndXJlZCBieSBwYXNzaW5nIGN1c3RvbVxuICogICBGaWVsZFZhbHVlT3B0aW9ucyB0byB2YWx1ZSgpLlxuICogLSBXaXRoIHJlc3BlY3QgdG8gb3RoZXIgU2VydmVyVGltZXN0YW1wVmFsdWVzLCB0aGV5IHNvcnQgYnkgdGhlaXJcbiAqICAgbG9jYWxXcml0ZVRpbWUuXG4gKi8gZnVuY3Rpb24gJHQodCkge1xuICAgIHZhciBlLCBuO1xuICAgIHJldHVybiBcInNlcnZlcl90aW1lc3RhbXBcIiA9PT0gKG51bGwgPT09IChuID0gKChudWxsID09PSAoZSA9IG51bGwgPT0gdCA/IHZvaWQgMCA6IHQubWFwVmFsdWUpIHx8IHZvaWQgMCA9PT0gZSA/IHZvaWQgMCA6IGUuZmllbGRzKSB8fCB7fSkuX190eXBlX18pIHx8IHZvaWQgMCA9PT0gbiA/IHZvaWQgMCA6IG4uc3RyaW5nVmFsdWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBiZWZvcmUgdGhpcyBTZXJ2ZXJUaW1lc3RhbXAgd2FzIHNldC5cbiAqXG4gKiBQcmVzZXJ2aW5nIHRoZSBwcmV2aW91cyB2YWx1ZXMgYWxsb3dzIHRoZSB1c2VyIHRvIGRpc3BsYXkgdGhlIGxhc3QgcmVzb2xlZFxuICogdmFsdWUgdW50aWwgdGhlIGJhY2tlbmQgcmVzcG9uZHMgd2l0aCB0aGUgdGltZXN0YW1wLlxuICovIGZ1bmN0aW9uIE50KHQpIHtcbiAgICBjb25zdCBlID0gdC5tYXBWYWx1ZS5maWVsZHMuX19wcmV2aW91c192YWx1ZV9fO1xuICAgIHJldHVybiAkdChlKSA/IE50KGUpIDogZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2NhbCB0aW1lIGF0IHdoaWNoIHRoaXMgdGltZXN0YW1wIHdhcyBmaXJzdCBzZXQuXG4gKi8gZnVuY3Rpb24gRHQodCkge1xuICAgIGNvbnN0IGUgPSBBdCh0Lm1hcFZhbHVlLmZpZWxkcy5fX2xvY2FsX3dyaXRlX3RpbWVfXy50aW1lc3RhbXBWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBWdChlLnNlY29uZHMsIGUubmFub3MpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjb25zdCBGdCA9IHtcbiAgICBmaWVsZHM6IHtcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiBcIl9fbWF4X19cIlxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqIEV4dHJhY3RzIHRoZSBiYWNrZW5kJ3MgdHlwZSBvcmRlciBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlLiAqL1xuZnVuY3Rpb24geHQodCkge1xuICAgIHJldHVybiBcIm51bGxWYWx1ZVwiIGluIHQgPyAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi8gOiBcImJvb2xlYW5WYWx1ZVwiIGluIHQgPyAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi8gOiBcImludGVnZXJWYWx1ZVwiIGluIHQgfHwgXCJkb3VibGVWYWx1ZVwiIGluIHQgPyAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLyA6IFwidGltZXN0YW1wVmFsdWVcIiBpbiB0ID8gMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi8gOiBcInN0cmluZ1ZhbHVlXCIgaW4gdCA/IDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovIDogXCJieXRlc1ZhbHVlXCIgaW4gdCA/IDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLyA6IFwicmVmZXJlbmNlVmFsdWVcIiBpbiB0ID8gNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi8gOiBcImdlb1BvaW50VmFsdWVcIiBpbiB0ID8gOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLyA6IFwiYXJyYXlWYWx1ZVwiIGluIHQgPyA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovIDogXCJtYXBWYWx1ZVwiIGluIHQgPyAkdCh0KSA/IDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovIDogXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVmFsdWUgcmVwcmVzZW50cyB0aGUgY2Fub25pY2FsIHtAbGluayAjTUFYX1ZBTFVFfSAuICovXG4gICAgZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gXCJfX21heF9fXCIgPT09ICgoKHQubWFwVmFsdWUgfHwge30pLmZpZWxkcyB8fCB7fSkuX190eXBlX18gfHwge30pLnN0cmluZ1ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuICAgIC8qKlxuICogUmVwcmVzZW50cyBhIGJvdW5kIG9mIGEgcXVlcnkuXG4gKlxuICogVGhlIGJvdW5kIGlzIHNwZWNpZmllZCB3aXRoIHRoZSBnaXZlbiBjb21wb25lbnRzIHJlcHJlc2VudGluZyBhIHBvc2l0aW9uIGFuZFxuICogd2hldGhlciBpdCdzIGp1c3QgYmVmb3JlIG9yIGp1c3QgYWZ0ZXIgdGhlIHBvc2l0aW9uIChyZWxhdGl2ZSB0byB3aGF0ZXZlciB0aGVcbiAqIHF1ZXJ5IG9yZGVyIGlzKS5cbiAqXG4gKiBUaGUgcG9zaXRpb24gcmVwcmVzZW50cyBhIGxvZ2ljYWwgaW5kZXggcG9zaXRpb24gZm9yIGEgcXVlcnkuIEl0J3MgYSBwcmVmaXhcbiAqIG9mIHZhbHVlcyBmb3IgdGhlIChwb3RlbnRpYWxseSBpbXBsaWNpdCkgb3JkZXIgYnkgY2xhdXNlcyBvZiBhIHF1ZXJ5LlxuICpcbiAqIEJvdW5kIHByb3ZpZGVzIGEgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkb2N1bWVudCBjb21lcyBiZWZvcmUgb3JcbiAqIGFmdGVyIGEgYm91bmQuIFRoaXMgaXMgaW5mbHVlbmNlZCBieSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBqdXN0IGJlZm9yZSBvclxuICoganVzdCBhZnRlciB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICovICh0KSA/IDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovIDogMTAgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovIDogYigpO1xufVxuXG4vKiogVGVzdHMgYGxlZnRgIGFuZCBgcmlnaHRgIGZvciBlcXVhbGl0eSBiYXNlZCBvbiB0aGUgYmFja2VuZCBzZW1hbnRpY3MuICovIGZ1bmN0aW9uIFN0KHQsIGUpIHtcbiAgICBpZiAodCA9PT0gZSkgcmV0dXJuICEwO1xuICAgIGNvbnN0IG4gPSB4dCh0KTtcbiAgICBpZiAobiAhPT0geHQoZSkpIHJldHVybiAhMTtcbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovIDpcbiAgICAgIGNhc2UgOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gITA7XG5cbiAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovIDpcbiAgICAgICAgcmV0dXJuIHQuYm9vbGVhblZhbHVlID09PSBlLmJvb2xlYW5WYWx1ZTtcblxuICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiBEdCh0KS5pc0VxdWFsKER0KGUpKTtcblxuICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdC50aW1lc3RhbXBWYWx1ZSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlLnRpbWVzdGFtcFZhbHVlICYmIHQudGltZXN0YW1wVmFsdWUubGVuZ3RoID09PSBlLnRpbWVzdGFtcFZhbHVlLmxlbmd0aCkgXG4gICAgICAgICAgICAvLyBVc2Ugc3RyaW5nIGVxdWFsaXR5IGZvciBJU08gODYwMSB0aW1lc3RhbXBzXG4gICAgICAgICAgICByZXR1cm4gdC50aW1lc3RhbXBWYWx1ZSA9PT0gZS50aW1lc3RhbXBWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBBdCh0LnRpbWVzdGFtcFZhbHVlKSwgciA9IEF0KGUudGltZXN0YW1wVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG4uc2Vjb25kcyA9PT0gci5zZWNvbmRzICYmIG4ubmFub3MgPT09IHIubmFub3M7XG4gICAgICAgIH0odCwgZSk7XG5cbiAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gdC5zdHJpbmdWYWx1ZSA9PT0gZS5zdHJpbmdWYWx1ZTtcblxuICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIFB0KHQuYnl0ZXNWYWx1ZSkuaXNFcXVhbChQdChlLmJ5dGVzVmFsdWUpKTtcbiAgICAgICAgfSh0LCBlKTtcblxuICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiB0LnJlZmVyZW5jZVZhbHVlID09PSBlLnJlZmVyZW5jZVZhbHVlO1xuXG4gICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJ0KHQuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgPT09IFJ0KGUuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgJiYgUnQodC5nZW9Qb2ludFZhbHVlLmxvbmdpdHVkZSkgPT09IFJ0KGUuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpO1xuICAgICAgICB9KHQsIGUpO1xuXG4gICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIGlmIChcImludGVnZXJWYWx1ZVwiIGluIHQgJiYgXCJpbnRlZ2VyVmFsdWVcIiBpbiBlKSByZXR1cm4gUnQodC5pbnRlZ2VyVmFsdWUpID09PSBSdChlLmludGVnZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoXCJkb3VibGVWYWx1ZVwiIGluIHQgJiYgXCJkb3VibGVWYWx1ZVwiIGluIGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gUnQodC5kb3VibGVWYWx1ZSksIHIgPSBSdChlLmRvdWJsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbiA9PT0gciA/IGx0KG4pID09PSBsdChyKSA6IGlzTmFOKG4pICYmIGlzTmFOKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9KHQsIGUpO1xuXG4gICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gdnQodC5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSwgZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSwgU3QpO1xuXG4gICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gdC5tYXBWYWx1ZS5maWVsZHMgfHwge30sIHIgPSBlLm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChidChuKSAhPT0gYnQocikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBpbiBuKSBpZiAobi5oYXNPd25Qcm9wZXJ0eSh0KSAmJiAodm9pZCAwID09PSByW3RdIHx8ICFTdChuW3RdLCByW3RdKSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBBcnJheVZhbHVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gKi8gKHQsIGUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcXQodCwgZSkge1xuICAgIHJldHVybiB2b2lkIDAgIT09ICh0LnZhbHVlcyB8fCBbXSkuZmluZCgodCA9PiBTdCh0LCBlKSkpO1xufVxuXG5mdW5jdGlvbiBPdCh0LCBlKSB7XG4gICAgaWYgKHQgPT09IGUpIHJldHVybiAwO1xuICAgIGNvbnN0IG4gPSB4dCh0KSwgciA9IHh0KGUpO1xuICAgIGlmIChuICE9PSByKSByZXR1cm4gX3Qobiwgcik7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLyA6XG4gICAgICBjYXNlIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovIDpcbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovIDpcbiAgICAgICAgcmV0dXJuIF90KHQuYm9vbGVhblZhbHVlLCBlLmJvb2xlYW5WYWx1ZSk7XG5cbiAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IFJ0KHQuaW50ZWdlclZhbHVlIHx8IHQuZG91YmxlVmFsdWUpLCByID0gUnQoZS5pbnRlZ2VyVmFsdWUgfHwgZS5kb3VibGVWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbiA8IHIgPyAtMSA6IG4gPiByID8gMSA6IG4gPT09IHIgPyAwIDogXG4gICAgICAgICAgICAvLyBvbmUgb3IgYm90aCBhcmUgTmFOLlxuICAgICAgICAgICAgaXNOYU4obikgPyBpc05hTihyKSA/IDAgOiAtMSA6IDE7XG4gICAgICAgIH0odCwgZSk7XG5cbiAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4ga3QodC50aW1lc3RhbXBWYWx1ZSwgZS50aW1lc3RhbXBWYWx1ZSk7XG5cbiAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4ga3QoRHQodCksIER0KGUpKTtcblxuICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiBfdCh0LnN0cmluZ1ZhbHVlLCBlLnN0cmluZ1ZhbHVlKTtcblxuICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi8gOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IFB0KHQpLCByID0gUHQoZSk7XG4gICAgICAgICAgICByZXR1cm4gbi5jb21wYXJlVG8ocik7XG4gICAgICAgIH0odC5ieXRlc1ZhbHVlLCBlLmJ5dGVzVmFsdWUpO1xuXG4gICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiL1wiKSwgciA9IGUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBuLmxlbmd0aCAmJiB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBfdChuW3RdLCByW3RdKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gZSkgcmV0dXJuIGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Qobi5sZW5ndGgsIHIubGVuZ3RoKTtcbiAgICAgICAgfSh0LnJlZmVyZW5jZVZhbHVlLCBlLnJlZmVyZW5jZVZhbHVlKTtcblxuICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBfdChSdCh0LmxhdGl0dWRlKSwgUnQoZS5sYXRpdHVkZSkpO1xuICAgICAgICAgICAgaWYgKDAgIT09IG4pIHJldHVybiBuO1xuICAgICAgICAgICAgcmV0dXJuIF90KFJ0KHQubG9uZ2l0dWRlKSwgUnQoZS5sb25naXR1ZGUpKTtcbiAgICAgICAgfSh0Lmdlb1BvaW50VmFsdWUsIGUuZ2VvUG9pbnRWYWx1ZSk7XG5cbiAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gdC52YWx1ZXMgfHwgW10sIHIgPSBlLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbi5sZW5ndGggJiYgdCA8IHIubGVuZ3RoOyArK3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gT3Qoblt0XSwgclt0XSk7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHJldHVybiBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90KG4ubGVuZ3RoLCByLmxlbmd0aCk7XG4gICAgICAgIH0odC5hcnJheVZhbHVlLCBlLmFycmF5VmFsdWUpO1xuXG4gICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLyA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gRnQgJiYgZSA9PT0gRnQpIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKHQgPT09IEZ0KSByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmIChlID09PSBGdCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgY29uc3QgbiA9IHQuZmllbGRzIHx8IHt9LCByID0gT2JqZWN0LmtleXMobiksIHMgPSBlLmZpZWxkcyB8fCB7fSwgaSA9IE9iamVjdC5rZXlzKHMpO1xuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggTWFwVmFsdWVzIGFyZSBsaWtlbHkgc29ydGVkIGNvcnJlY3RseSBiYXNlZCBvbiB0aGVpciBpbnNlcnRpb25cbiAgICAgICAgICAgIC8vIG9yZGVyIChlLmcuIHdoZW4gcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCksIGxvY2FsIG1vZGlmaWNhdGlvbnMgY2FuIGJyaW5nXG4gICAgICAgICAgICAvLyBlbGVtZW50cyBvdXQgb2Ygb3JkZXIuIFdlIG5lZWQgdG8gcmUtc29ydCB0aGUgZWxlbWVudHMgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBJRHMgYXJlIGluZGVwZW5kZW50IG9mIGluc2VydGlvbiBvcmRlci5cbiAgICAgICAgICAgIHIuc29ydCgpLCBpLnNvcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgci5sZW5ndGggJiYgdCA8IGkubGVuZ3RoOyArK3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gX3Qoclt0XSwgaVt0XSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IGUpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBPdChuW3JbdF1dLCBzW2lbdF1dKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gbykgcmV0dXJuIG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Qoci5sZW5ndGgsIGkubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIGRhdGFiYXNlIGFuZCBrZXkuICovICh0Lm1hcFZhbHVlLCBlLm1hcFZhbHVlKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgYigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24ga3QodCwgZSkge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgdC5sZW5ndGggPT09IGUubGVuZ3RoKSByZXR1cm4gX3QodCwgZSk7XG4gICAgY29uc3QgbiA9IEF0KHQpLCByID0gQXQoZSksIHMgPSBfdChuLnNlY29uZHMsIHIuc2Vjb25kcyk7XG4gICAgcmV0dXJuIDAgIT09IHMgPyBzIDogX3Qobi5uYW5vcywgci5uYW5vcyk7XG59XG5cbmZ1bmN0aW9uIEN0KHQsIGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWZlcmVuY2VWYWx1ZTogYHByb2plY3RzLyR7dC5wcm9qZWN0SWR9L2RhdGFiYXNlcy8ke3QuZGF0YWJhc2V9L2RvY3VtZW50cy8ke2UucGF0aC5jYW5vbmljYWxTdHJpbmcoKX1gXG4gICAgfTtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIEFycmF5VmFsdWUuICovIGZ1bmN0aW9uIEx0KHQpIHtcbiAgICByZXR1cm4gISF0ICYmIFwiYXJyYXlWYWx1ZVwiIGluIHQ7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIE51bGxWYWx1ZS4gKi8gZnVuY3Rpb24gTXQodCkge1xuICAgIHJldHVybiAhIXQgJiYgXCJudWxsVmFsdWVcIiBpbiB0O1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgTmFOLiAqLyBmdW5jdGlvbiBVdCh0KSB7XG4gICAgcmV0dXJuICEhdCAmJiBcImRvdWJsZVZhbHVlXCIgaW4gdCAmJiBpc05hTihOdW1iZXIodC5kb3VibGVWYWx1ZSkpO1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBNYXBWYWx1ZS4gKi8gZnVuY3Rpb24ganQodCkge1xuICAgIHJldHVybiAhIXQgJiYgXCJtYXBWYWx1ZVwiIGluIHQ7XG59XG5cbi8qKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgLiAqLyBmdW5jdGlvbiBCdCh0KSB7XG4gICAgaWYgKHQuZ2VvUG9pbnRWYWx1ZSkgcmV0dXJuIHtcbiAgICAgICAgZ2VvUG9pbnRWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgdC5nZW9Qb2ludFZhbHVlKVxuICAgIH07XG4gICAgaWYgKHQudGltZXN0YW1wVmFsdWUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdC50aW1lc3RhbXBWYWx1ZSkgcmV0dXJuIHtcbiAgICAgICAgdGltZXN0YW1wVmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHQudGltZXN0YW1wVmFsdWUpXG4gICAgfTtcbiAgICBpZiAodC5tYXBWYWx1ZSkge1xuICAgICAgICBjb25zdCBlID0ge1xuICAgICAgICAgICAgbWFwVmFsdWU6IHtcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdCh0Lm1hcFZhbHVlLmZpZWxkcywgKCh0LCBuKSA9PiBlLm1hcFZhbHVlLmZpZWxkc1t0XSA9IEJ0KG4pKSksIGU7XG4gICAgfVxuICAgIGlmICh0LmFycmF5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgICAgIGFycmF5VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgKHQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLmxlbmd0aDsgKytuKSBlLmFycmF5VmFsdWUudmFsdWVzW25dID0gQnQodC5hcnJheVZhbHVlLnZhbHVlc1tuXSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdCk7XG59XG5cbmNsYXNzIFF0IHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB0LCB0aGlzLmluY2x1c2l2ZSA9IGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB6dCh0LCBlKSB7XG4gICAgaWYgKG51bGwgPT09IHQpIHJldHVybiBudWxsID09PSBlO1xuICAgIGlmIChudWxsID09PSBlKSByZXR1cm4gITE7XG4gICAgaWYgKHQuaW5jbHVzaXZlICE9PSBlLmluY2x1c2l2ZSB8fCB0LnBvc2l0aW9uLmxlbmd0aCAhPT0gZS5wb3NpdGlvbi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQucG9zaXRpb24ubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgaWYgKCFTdCh0LnBvc2l0aW9uW25dLCBlLnBvc2l0aW9uW25dKSkgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzIFd0IHt9XG5cbmNsYXNzIEd0IGV4dGVuZHMgV3Qge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHtcbiAgICAgICAgc3VwZXIoKSwgdGhpcy5maWVsZCA9IHQsIHRoaXMub3AgPSBlLCB0aGlzLnZhbHVlID0gbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqLyAgICBzdGF0aWMgY3JlYXRlKHQsIGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIHQuaXNLZXlGaWVsZCgpID8gXCJpblwiIC8qIE9wZXJhdG9yLklOICovID09PSBlIHx8IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovID09PSBlID8gdGhpcy5jcmVhdGVLZXlGaWVsZEluRmlsdGVyKHQsIGUsIG4pIDogbmV3IEh0KHQsIGUsIG4pIDogXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovID09PSBlID8gbmV3IHRlKHQsIG4pIDogXCJpblwiIC8qIE9wZXJhdG9yLklOICovID09PSBlID8gbmV3IGVlKHQsIG4pIDogXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gPT09IGUgPyBuZXcgbmUodCwgbikgOiBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLyA9PT0gZSA/IG5ldyByZSh0LCBuKSA6IG5ldyBHdCh0LCBlLCBuKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIodCwgZSwgbikge1xuICAgICAgICByZXR1cm4gXCJpblwiIC8qIE9wZXJhdG9yLklOICovID09PSBlID8gbmV3IEp0KHQsIG4pIDogbmV3IFh0KHQsIG4pO1xuICAgIH1cbiAgICBtYXRjaGVzKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgLy8gVHlwZXMgZG8gbm90IGhhdmUgdG8gbWF0Y2ggaW4gTk9UX0VRVUFMIGZpbHRlcnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8gPT09IHRoaXMub3AgPyBudWxsICE9PSBlICYmIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24oT3QoZSwgdGhpcy52YWx1ZSkpIDogbnVsbCAhPT0gZSAmJiB4dCh0aGlzLnZhbHVlKSA9PT0geHQoZSkgJiYgdGhpcy5tYXRjaGVzQ29tcGFyaXNvbihPdChlLCB0aGlzLnZhbHVlKSk7XG4gICAgICAgIC8vIE9ubHkgY29tcGFyZSB0eXBlcyB3aXRoIG1hdGNoaW5nIGJhY2tlbmQgb3JkZXIgKHN1Y2ggYXMgZG91YmxlIGFuZCBpbnQpLlxuICAgICAgICB9XG4gICAgbWF0Y2hlc0NvbXBhcmlzb24odCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3ApIHtcbiAgICAgICAgICBjYXNlIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLyA6XG4gICAgICAgICAgICByZXR1cm4gdCA8IDA7XG5cbiAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi8gOlxuICAgICAgICAgICAgcmV0dXJuIHQgPD0gMDtcblxuICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovIDpcbiAgICAgICAgICAgIHJldHVybiAwID09PSB0O1xuXG4gICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovIDpcbiAgICAgICAgICAgIHJldHVybiAwICE9PSB0O1xuXG4gICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi8gOlxuICAgICAgICAgICAgcmV0dXJuIHQgPiAwO1xuXG4gICAgICAgICAgY2FzZSBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovIDpcbiAgICAgICAgICAgIHJldHVybiB0ID49IDA7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0luZXF1YWxpdHkoKSB7XG4gICAgICAgIHJldHVybiBbIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLyAsIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi8gLCBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi8gLCBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovICwgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLyAsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovIF0uaW5kZXhPZih0aGlzLm9wKSA+PSAwO1xuICAgIH1cbiAgICBnZXRGbGF0dGVuZWRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gWyB0aGlzIF07XG4gICAgfVxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbIHRoaXMgXTtcbiAgICB9XG4gICAgZ2V0Rmlyc3RJbmVxdWFsaXR5RmllbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5lcXVhbGl0eSgpID8gdGhpcy5maWVsZCA6IG51bGw7XG4gICAgfVxufVxuXG5jbGFzcyBLdCBleHRlbmRzIFd0IHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMuZmlsdGVycyA9IHQsIHRoaXMub3AgPSBlLCB0aGlzLkQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICovICAgIHN0YXRpYyBjcmVhdGUodCwgZSkge1xuICAgICAgICByZXR1cm4gbmV3IEt0KHQsIGUpO1xuICAgIH1cbiAgICBtYXRjaGVzKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovID09PSB0aGlzLm9wID8gdm9pZCAwID09PSB0aGlzLmZpbHRlcnMuZmluZCgoZSA9PiAhZS5tYXRjaGVzKHQpKSkgOiB2b2lkIDAgIT09IHRoaXMuZmlsdGVycy5maW5kKChlID0+IGUubWF0Y2hlcyh0KSkpO1xuICAgIH1cbiAgICBnZXRGbGF0dGVuZWRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdGhpcy5EIHx8ICh0aGlzLkQgPSB0aGlzLmZpbHRlcnMucmVkdWNlKCgodCwgZSkgPT4gdC5jb25jYXQoZS5nZXRGbGF0dGVuZWRGaWx0ZXJzKCkpKSwgW10pKSwgXG4gICAgICAgIHRoaXMuRDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIG11dGFibGUgY29weSBvZiBgdGhpcy5maWx0ZXJzYFxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB0aGlzLmZpbHRlcnMpO1xuICAgIH1cbiAgICBnZXRGaXJzdEluZXF1YWxpdHlGaWVsZCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuRigodCA9PiB0LmlzSW5lcXVhbGl0eSgpKSk7XG4gICAgICAgIHJldHVybiBudWxsICE9PSB0ID8gdC5maWVsZCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFBlcmZvcm1zIGEgZGVwdGgtZmlyc3Qgc2VhcmNoIHRvIGZpbmQgYW5kIHJldHVybiB0aGUgZmlyc3QgRmllbGRGaWx0ZXIgaW4gdGhlIGNvbXBvc2l0ZSBmaWx0ZXJcbiAgICAvLyB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLiBSZXR1cm5zIGBudWxsYCBpZiBub25lIG9mIHRoZSBGaWVsZEZpbHRlcnMgc2F0aXNmeSB0aGVcbiAgICAvLyBwcmVkaWNhdGUuXG4gICAgRih0KSB7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSkgaWYgKHQoZSkpIHJldHVybiBlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFl0KHQsIGUpIHtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIEd0ID8gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEd0ICYmIHQub3AgPT09IGUub3AgJiYgdC5maWVsZC5pc0VxdWFsKGUuZmllbGQpICYmIFN0KHQudmFsdWUsIGUudmFsdWUpO1xuICAgIH0odCwgZSkgOiB0IGluc3RhbmNlb2YgS3QgPyBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgS3QgJiYgdC5vcCA9PT0gZS5vcCAmJiB0LmZpbHRlcnMubGVuZ3RoID09PSBlLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5maWx0ZXJzLnJlZHVjZSgoKHQsIG4sIHIpID0+IHQgJiYgWXQobiwgZS5maWx0ZXJzW3JdKSksICEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIC8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgKGkuZS4gJ19fbmFtZV9fJykuICovICh0LCBlKSA6IHZvaWQgYigpO1xufVxuXG5jbGFzcyBIdCBleHRlbmRzIEd0IHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBuKSB7XG4gICAgICAgIHN1cGVyKHQsIGUsIG4pLCB0aGlzLmtleSA9IHJ0LmZyb21OYW1lKG4ucmVmZXJlbmNlVmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHJ0LmNvbXBhcmF0b3IodC5rZXksIHRoaXMua2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24oZSk7XG4gICAgfVxufVxuXG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIHdpdGhpbiBhbiBhcnJheS4gKi8gY2xhc3MgSnQgZXh0ZW5kcyBHdCB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcih0LCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gLCBlKSwgdGhpcy5rZXlzID0gWnQoXCJpblwiIC8qIE9wZXJhdG9yLklOICovICwgZSk7XG4gICAgfVxuICAgIG1hdGNoZXModCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLnNvbWUoKGUgPT4gZS5pc0VxdWFsKHQua2V5KSkpO1xuICAgIH1cbn1cblxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyBub3QgcHJlc2VudCB3aXRoaW4gYW4gYXJyYXkuICovIGNsYXNzIFh0IGV4dGVuZHMgR3Qge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgc3VwZXIodCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gLCBlKSwgdGhpcy5rZXlzID0gWnQoXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gLCBlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyh0KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5rZXlzLnNvbWUoKGUgPT4gZS5pc0VxdWFsKHQua2V5KSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gWnQodCwgZSkge1xuICAgIHZhciBuO1xuICAgIHJldHVybiAoKG51bGwgPT09IChuID0gZS5hcnJheVZhbHVlKSB8fCB2b2lkIDAgPT09IG4gPyB2b2lkIDAgOiBuLnZhbHVlcykgfHwgW10pLm1hcCgodCA9PiBydC5mcm9tTmFtZSh0LnJlZmVyZW5jZVZhbHVlKSkpO1xufVxuXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucyBvcGVyYXRvci4gKi8gY2xhc3MgdGUgZXh0ZW5kcyBHdCB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcih0LCBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gLCBlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0LmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIHJldHVybiBMdChlKSAmJiBxdChlLmFycmF5VmFsdWUsIHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgSU4gb3BlcmF0b3IuICovIGNsYXNzIGVlIGV4dGVuZHMgR3Qge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgc3VwZXIodCwgXCJpblwiIC8qIE9wZXJhdG9yLklOICovICwgZSk7XG4gICAgfVxuICAgIG1hdGNoZXModCkge1xuICAgICAgICBjb25zdCBlID0gdC5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gZSAmJiBxdCh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIGUpO1xuICAgIH1cbn1cblxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgbm90LWluIG9wZXJhdG9yLiAqLyBjbGFzcyBuZSBleHRlbmRzIEd0IHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHN1cGVyKHQsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovICwgZSk7XG4gICAgfVxuICAgIG1hdGNoZXModCkge1xuICAgICAgICBpZiAocXQodGhpcy52YWx1ZS5hcnJheVZhbHVlLCB7XG4gICAgICAgICAgICBudWxsVmFsdWU6IFwiTlVMTF9WQUxVRVwiXG4gICAgICAgIH0pKSByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGUgPSB0LmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIHJldHVybiBudWxsICE9PSBlICYmICFxdCh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIGUpO1xuICAgIH1cbn1cblxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMtYW55IG9wZXJhdG9yLiAqLyBjbGFzcyByZSBleHRlbmRzIEd0IHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHN1cGVyKHQsIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovICwgZSk7XG4gICAgfVxuICAgIG1hdGNoZXModCkge1xuICAgICAgICBjb25zdCBlID0gdC5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gISghTHQoZSkgfHwgIWUuYXJyYXlWYWx1ZS52YWx1ZXMpICYmIGUuYXJyYXlWYWx1ZS52YWx1ZXMuc29tZSgodCA9PiBxdCh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIHQpKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBvcmRlcmluZyBvbiBhIGZpZWxkLCBpbiBzb21lIERpcmVjdGlvbi4gRGlyZWN0aW9uIGRlZmF1bHRzIHRvIEFTQ0VORElORy5cbiAqLyBjbGFzcyBzZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSA9IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLykge1xuICAgICAgICB0aGlzLmZpZWxkID0gdCwgdGhpcy5kaXIgPSBlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaWUodCwgZSkge1xuICAgIHJldHVybiB0LmRpciA9PT0gZS5kaXIgJiYgdC5maWVsZC5pc0VxdWFsKGUuZmllbGQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHZlcnNpb24gb2YgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHZlcnNpb25cbiAqIHRpbWVzdGFtcCwgc3VjaCBhcyB1cGRhdGVfdGltZSBvciByZWFkX3RpbWUuXG4gKi8gY2xhc3Mgb2Uge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVRpbWVzdGFtcCh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgb2UodCk7XG4gICAgfVxuICAgIHN0YXRpYyBtaW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgb2UobmV3IFZ0KDAsIDApKTtcbiAgICB9XG4gICAgc3RhdGljIG1heCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBvZShuZXcgVnQoMjUzNDAyMzAwNzk5LCA5OTk5OTk5OTkpKTtcbiAgICB9XG4gICAgY29tcGFyZVRvKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLl9jb21wYXJlVG8odC50aW1lc3RhbXApO1xuICAgIH1cbiAgICBpc0VxdWFsKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLmlzRXF1YWwodC50aW1lc3RhbXApO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVyc2lvbiBmb3IgdXNlIGluIHNwZWMgdGVzdHMuICovICAgIHRvTWljcm9zZWNvbmRzKCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIG1pY3Jvc2Vjb25kcy5cbiAgICAgICAgcmV0dXJuIDFlNiAqIHRoaXMudGltZXN0YW1wLnNlY29uZHMgKyB0aGlzLnRpbWVzdGFtcC5uYW5vc2Vjb25kcyAvIDFlMztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlNuYXBzaG90VmVyc2lvbihcIiArIHRoaXMudGltZXN0YW1wLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgdG9UaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBBbiBpbW11dGFibGUgc29ydGVkIG1hcCBpbXBsZW1lbnRhdGlvbiwgYmFzZWQgb24gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrXG4vLyB0cmVlLlxuY2xhc3MgdWUge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gdCwgdGhpcy5yb290ID0gZSB8fCBhZS5FTVBUWTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cbiAgICBpbnNlcnQodCwgZSkge1xuICAgICAgICByZXR1cm4gbmV3IHVlKHRoaXMuY29tcGFyYXRvciwgdGhpcy5yb290Lmluc2VydCh0LCBlLCB0aGlzLmNvbXBhcmF0b3IpLmNvcHkobnVsbCwgbnVsbCwgYWUuQkxBQ0ssIG51bGwsIG51bGwpKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgIHJlbW92ZSh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdWUodGhpcy5jb21wYXJhdG9yLCB0aGlzLnJvb3QucmVtb3ZlKHQsIHRoaXMuY29tcGFyYXRvcikuY29weShudWxsLCBudWxsLCBhZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXG4gICAgZ2V0KHQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGZvciAoOyFlLmlzRW1wdHkoKTsgKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gdGhpcy5jb21wYXJhdG9yKHQsIGUua2V5KTtcbiAgICAgICAgICAgIGlmICgwID09PSBuKSByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgICAgIG4gPCAwID8gZSA9IGUubGVmdCA6IG4gPiAwICYmIChlID0gZS5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoaXMgc29ydGVkIG1hcCwgb3IgLTEgaWYgaXQgZG9lc24ndFxuICAgIC8vIGV4aXN0LlxuICAgIGluZGV4T2YodCkge1xuICAgICAgICAvLyBOdW1iZXIgb2Ygbm9kZXMgdGhhdCB3ZXJlIHBydW5lZCB3aGVuIGRlc2NlbmRpbmcgcmlnaHRcbiAgICAgICAgbGV0IGUgPSAwLCBuID0gdGhpcy5yb290O1xuICAgICAgICBmb3IgKDshbi5pc0VtcHR5KCk7ICkge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY29tcGFyYXRvcih0LCBuLmtleSk7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcikgcmV0dXJuIGUgKyBuLmxlZnQuc2l6ZTtcbiAgICAgICAgICAgIHIgPCAwID8gbiA9IG4ubGVmdCA6IChcbiAgICAgICAgICAgIC8vIENvdW50IGFsbCBub2RlcyBsZWZ0IG9mIHRoZSBub2RlIHBsdXMgdGhlIG5vZGUgaXRzZWxmXG4gICAgICAgICAgICBlICs9IG4ubGVmdC5zaXplICsgMSwgbiA9IG4ucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGUgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2l6ZTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWluaW11bSBrZXkgaW4gdGhlIG1hcC5cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QubWluS2V5KCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXG4gICAgbWF4S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Lm1heEtleSgpO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIG1hcCBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgLy8gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICBpbm9yZGVyVHJhdmVyc2FsKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pbm9yZGVyVHJhdmVyc2FsKHQpO1xuICAgIH1cbiAgICBmb3JFYWNoKHQpIHtcbiAgICAgICAgdGhpcy5pbm9yZGVyVHJhdmVyc2FsKCgoZSwgbikgPT4gKHQoZSwgbiksICExKSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdCA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5pbm9yZGVyVHJhdmVyc2FsKCgoZSwgbikgPT4gKHQucHVzaChgJHtlfToke259YCksICExKSkpLCBgeyR7dC5qb2luKFwiLCBcIil9fWA7XG4gICAgfVxuICAgIC8vIFRyYXZlcnNlcyB0aGUgbWFwIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvblxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXNcbiAgICAvLyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICByZXZlcnNlVHJhdmVyc2FsKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5yZXZlcnNlVHJhdmVyc2FsKHQpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cbiAgICBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjZSh0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgITEpO1xuICAgIH1cbiAgICBnZXRJdGVyYXRvckZyb20odCkge1xuICAgICAgICByZXR1cm4gbmV3IGNlKHRoaXMucm9vdCwgdCwgdGhpcy5jb21wYXJhdG9yLCAhMSk7XG4gICAgfVxuICAgIGdldFJldmVyc2VJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjZSh0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgITApO1xuICAgIH1cbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjZSh0aGlzLnJvb3QsIHQsIHRoaXMuY29tcGFyYXRvciwgITApO1xuICAgIH1cbn1cblxuIC8vIGVuZCBTb3J0ZWRNYXBcbi8vIEFuIGl0ZXJhdG9yIG92ZXIgYW4gTExSQk5vZGUuXG5jbGFzcyBjZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgcikge1xuICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IHIsIHRoaXMubm9kZVN0YWNrID0gW107XG4gICAgICAgIGxldCBzID0gMTtcbiAgICAgICAgZm9yICg7IXQuaXNFbXB0eSgpOyApIGlmIChzID0gZSA/IG4odC5rZXksIGUpIDogMSwgXG4gICAgICAgIC8vIGZsaXAgdGhlIGNvbXBhcmlzb24gaWYgd2UncmUgZ29pbmcgaW4gcmV2ZXJzZVxuICAgICAgICBlICYmIHIgJiYgKHMgKj0gLTEpLCBzIDwgMCkgXG4gICAgICAgIC8vIFRoaXMgbm9kZSBpcyBsZXNzIHRoYW4gb3VyIHN0YXJ0IGtleS4gaWdub3JlIGl0XG4gICAgICAgIHQgPSB0aGlzLmlzUmV2ZXJzZSA/IHQubGVmdCA6IHQucmlnaHQ7IGVsc2Uge1xuICAgICAgICAgICAgaWYgKDAgPT09IHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjayxcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RvcCBpdGVyYXRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaCh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZVxuICAgICAgICAgICAgLy8gdG8gdGhlIG5leHQgb25lXG4gICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKHQpLCB0ID0gdGhpcy5pc1JldmVyc2UgPyB0LnJpZ2h0IDogdC5sZWZ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHQoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcy5ub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSBmb3IgKHQgPSB0LmxlZnQ7ICF0LmlzRW1wdHkoKTsgKSB0aGlzLm5vZGVTdGFjay5wdXNoKHQpLCB0ID0gdC5yaWdodDsgZWxzZSBmb3IgKHQgPSB0LnJpZ2h0OyAhdC5pc0VtcHR5KCk7ICkgdGhpcy5ub2RlU3RhY2sucHVzaCh0KSwgXG4gICAgICAgIHQgPSB0LmxlZnQ7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBoYXNOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2subGVuZ3RoID4gMDtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKDAgPT09IHRoaXMubm9kZVN0YWNrLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLm5vZGVTdGFja1t0aGlzLm5vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogdC5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdC52YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuIC8vIGVuZCBTb3J0ZWRNYXBJdGVyYXRvclxuLy8gUmVwcmVzZW50cyBhIG5vZGUgaW4gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrIHRyZWUuXG5jbGFzcyBhZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgciwgcykge1xuICAgICAgICB0aGlzLmtleSA9IHQsIHRoaXMudmFsdWUgPSBlLCB0aGlzLmNvbG9yID0gbnVsbCAhPSBuID8gbiA6IGFlLlJFRCwgdGhpcy5sZWZ0ID0gbnVsbCAhPSByID8gciA6IGFlLkVNUFRZLCBcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGwgIT0gcyA/IHMgOiBhZS5FTVBUWSwgdGhpcy5zaXplID0gdGhpcy5sZWZ0LnNpemUgKyAxICsgdGhpcy5yaWdodC5zaXplO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXG4gICAgY29weSh0LCBlLCBuLCByLCBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYWUobnVsbCAhPSB0ID8gdCA6IHRoaXMua2V5LCBudWxsICE9IGUgPyBlIDogdGhpcy52YWx1ZSwgbnVsbCAhPSBuID8gbiA6IHRoaXMuY29sb3IsIG51bGwgIT0gciA/IHIgOiB0aGlzLmxlZnQsIG51bGwgIT0gcyA/IHMgOiB0aGlzLnJpZ2h0KTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgIC8vIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICBpbm9yZGVyVHJhdmVyc2FsKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKHQpIHx8IHQodGhpcy5rZXksIHRoaXMudmFsdWUpIHx8IHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbCh0KTtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvblxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cbiAgICByZXZlcnNlVHJhdmVyc2FsKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQucmV2ZXJzZVRyYXZlcnNhbCh0KSB8fCB0KHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fCB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbCh0KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxuICAgIG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5pc0VtcHR5KCkgPyB0aGlzIDogdGhpcy5sZWZ0Lm1pbigpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigpLmtleTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXG4gICAgbWF4S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5pc0VtcHR5KCkgPyB0aGlzLmtleSA6IHRoaXMucmlnaHQubWF4S2V5KCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIGtleS92YWx1ZSBhZGRlZC5cbiAgICBpbnNlcnQodCwgZSwgbikge1xuICAgICAgICBsZXQgciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHMgPSBuKHQsIHIua2V5KTtcbiAgICAgICAgcmV0dXJuIHIgPSBzIDwgMCA/IHIuY29weShudWxsLCBudWxsLCBudWxsLCByLmxlZnQuaW5zZXJ0KHQsIGUsIG4pLCBudWxsKSA6IDAgPT09IHMgPyByLmNvcHkobnVsbCwgZSwgbnVsbCwgbnVsbCwgbnVsbCkgOiByLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgci5yaWdodC5pbnNlcnQodCwgZSwgbikpLCBcbiAgICAgICAgci5maXhVcCgpO1xuICAgIH1cbiAgICByZW1vdmVNaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSByZXR1cm4gYWUuRU1QVFk7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHQubGVmdC5pc1JlZCgpIHx8IHQubGVmdC5sZWZ0LmlzUmVkKCkgfHwgKHQgPSB0Lm1vdmVSZWRMZWZ0KCkpLCB0ID0gdC5jb3B5KG51bGwsIG51bGwsIG51bGwsIHQubGVmdC5yZW1vdmVNaW4oKSwgbnVsbCksIFxuICAgICAgICB0LmZpeFVwKCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXG4gICAgcmVtb3ZlKHQsIGUpIHtcbiAgICAgICAgbGV0IG4sIHIgPSB0aGlzO1xuICAgICAgICBpZiAoZSh0LCByLmtleSkgPCAwKSByLmxlZnQuaXNFbXB0eSgpIHx8IHIubGVmdC5pc1JlZCgpIHx8IHIubGVmdC5sZWZ0LmlzUmVkKCkgfHwgKHIgPSByLm1vdmVSZWRMZWZ0KCkpLCBcbiAgICAgICAgciA9IHIuY29weShudWxsLCBudWxsLCBudWxsLCByLmxlZnQucmVtb3ZlKHQsIGUpLCBudWxsKTsgZWxzZSB7XG4gICAgICAgICAgICBpZiAoci5sZWZ0LmlzUmVkKCkgJiYgKHIgPSByLnJvdGF0ZVJpZ2h0KCkpLCByLnJpZ2h0LmlzRW1wdHkoKSB8fCByLnJpZ2h0LmlzUmVkKCkgfHwgci5yaWdodC5sZWZ0LmlzUmVkKCkgfHwgKHIgPSByLm1vdmVSZWRSaWdodCgpKSwgXG4gICAgICAgICAgICAwID09PSBlKHQsIHIua2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChyLnJpZ2h0LmlzRW1wdHkoKSkgcmV0dXJuIGFlLkVNUFRZO1xuICAgICAgICAgICAgICAgIG4gPSByLnJpZ2h0Lm1pbigpLCByID0gci5jb3B5KG4ua2V5LCBuLnZhbHVlLCBudWxsLCBudWxsLCByLnJpZ2h0LnJlbW92ZU1pbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSByLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgci5yaWdodC5yZW1vdmUodCwgZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLmZpeFVwKCk7XG4gICAgfVxuICAgIGlzUmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxuICAgIGZpeFVwKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0LnJpZ2h0LmlzUmVkKCkgJiYgIXQubGVmdC5pc1JlZCgpICYmICh0ID0gdC5yb3RhdGVMZWZ0KCkpLCB0LmxlZnQuaXNSZWQoKSAmJiB0LmxlZnQubGVmdC5pc1JlZCgpICYmICh0ID0gdC5yb3RhdGVSaWdodCgpKSwgXG4gICAgICAgIHQubGVmdC5pc1JlZCgpICYmIHQucmlnaHQuaXNSZWQoKSAmJiAodCA9IHQuY29sb3JGbGlwKCkpLCB0O1xuICAgIH1cbiAgICBtb3ZlUmVkTGVmdCgpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzLmNvbG9yRmxpcCgpO1xuICAgICAgICByZXR1cm4gdC5yaWdodC5sZWZ0LmlzUmVkKCkgJiYgKHQgPSB0LmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgdC5yaWdodC5yb3RhdGVSaWdodCgpKSwgXG4gICAgICAgIHQgPSB0LnJvdGF0ZUxlZnQoKSwgdCA9IHQuY29sb3JGbGlwKCkpLCB0O1xuICAgIH1cbiAgICBtb3ZlUmVkUmlnaHQoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcy5jb2xvckZsaXAoKTtcbiAgICAgICAgcmV0dXJuIHQubGVmdC5sZWZ0LmlzUmVkKCkgJiYgKHQgPSB0LnJvdGF0ZVJpZ2h0KCksIHQgPSB0LmNvbG9yRmxpcCgpKSwgdDtcbiAgICB9XG4gICAgcm90YXRlTGVmdCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuY29weShudWxsLCBudWxsLCBhZS5SRUQsIG51bGwsIHRoaXMucmlnaHQubGVmdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgdCwgbnVsbCk7XG4gICAgfVxuICAgIHJvdGF0ZVJpZ2h0KCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIGFlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIHQpO1xuICAgIH1cbiAgICBjb2xvckZsaXAoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKSwgZSA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkobnVsbCwgbnVsbCwgIXRoaXMuY29sb3IsIHQsIGUpO1xuICAgIH1cbiAgICAvLyBGb3IgdGVzdGluZy5cbiAgICBjaGVja01heERlcHRoKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jaGVjaygpO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgdCkgPD0gdGhpcy5zaXplICsgMTtcbiAgICB9XG4gICAgLy8gSW4gYSBiYWxhbmNlZCBSQiB0cmVlLCB0aGUgYmxhY2stZGVwdGggKG51bWJlciBvZiBibGFjayBub2RlcykgZnJvbSByb290IHRvXG4gICAgLy8gbGVhdmVzIGlzIGVxdWFsIG9uIGJvdGggc2lkZXMuICBUaGlzIGZ1bmN0aW9uIHZlcmlmaWVzIHRoYXQgb3IgYXNzZXJ0cy5cbiAgICBjaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWQoKSAmJiB0aGlzLmxlZnQuaXNSZWQoKSkgdGhyb3cgYigpO1xuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZCgpKSB0aHJvdyBiKCk7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmxlZnQuY2hlY2soKTtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMucmlnaHQuY2hlY2soKSkgdGhyb3cgYigpO1xuICAgICAgICByZXR1cm4gdCArICh0aGlzLmlzUmVkKCkgPyAwIDogMSk7XG4gICAgfVxufVxuXG4gLy8gZW5kIExMUkJOb2RlXG4vLyBFbXB0eSBub2RlIGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBMTFJCIHRyZWVzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFlLkVNUFRZID0gbnVsbCwgYWUuUkVEID0gITAsIGFlLkJMQUNLID0gITE7XG5cbi8vIGVuZCBMTFJCRW1wdHlOb2RlXG5hZS5FTVBUWSA9IG5ldyBcbi8vIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cbmNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG4gICAgZ2V0IGtleSgpIHtcbiAgICAgICAgdGhyb3cgYigpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHRocm93IGIoKTtcbiAgICB9XG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICB0aHJvdyBiKCk7XG4gICAgfVxuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICB0aHJvdyBiKCk7XG4gICAgfVxuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgdGhyb3cgYigpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgIGNvcHkodCwgZSwgbiwgciwgcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXG4gICAgaW5zZXJ0KHQsIGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhZSh0LCBlKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cbiAgICByZW1vdmUodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBpbm9yZGVyVHJhdmVyc2FsKHQpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXZlcnNlVHJhdmVyc2FsKHQpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtYXhLZXkoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc1JlZCgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICAvLyBGb3IgdGVzdGluZy5cbiAgICBjaGVja01heERlcHRoKCkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGNoZWNrKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTb3J0ZWRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZWxlbWVudHNcbiAqIGluIG9yZGVyIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci5cbiAqXG4gKiBOT1RFOiBpZiBwcm92aWRlZCBjb21wYXJhdG9yIHJldHVybnMgMCBmb3IgdHdvIGVsZW1lbnRzLCB3ZSBjb25zaWRlciB0aGVtIHRvXG4gKiBiZSBlcXVhbCFcbiAqL1xuY2xhc3MgaGUge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gdCwgdGhpcy5kYXRhID0gbmV3IHVlKHRoaXMuY29tcGFyYXRvcik7XG4gICAgfVxuICAgIGhhcyh0KSB7XG4gICAgICAgIHJldHVybiBudWxsICE9PSB0aGlzLmRhdGEuZ2V0KHQpO1xuICAgIH1cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5taW5LZXkoKTtcbiAgICB9XG4gICAgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXhLZXkoKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2l6ZTtcbiAgICB9XG4gICAgaW5kZXhPZih0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaW5kZXhPZih0KTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIG9yZGVyIGRlZmluZWQgYnkgXCJjb21wYXJhdG9yXCIgKi8gICAgZm9yRWFjaCh0KSB7XG4gICAgICAgIHRoaXMuZGF0YS5pbm9yZGVyVHJhdmVyc2FsKCgoZSwgbikgPT4gKHQoZSksICExKSkpO1xuICAgIH1cbiAgICAvKiogSXRlcmF0ZXMgb3ZlciBgZWxlbWBzIHN1Y2ggdGhhdDogcmFuZ2VbMF0gJmx0Oz0gZWxlbSAmbHQ7IHJhbmdlWzFdLiAqLyAgICBmb3JFYWNoSW5SYW5nZSh0LCBlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHRbMF0pO1xuICAgICAgICBmb3IgKDtuLmhhc05leHQoKTsgKSB7XG4gICAgICAgICAgICBjb25zdCByID0gbi5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKHIua2V5LCB0WzFdKSA+PSAwKSByZXR1cm47XG4gICAgICAgICAgICBlKHIua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGBlbGVtYHMgc3VjaCB0aGF0OiBzdGFydCAmbHQ7PSBlbGVtIHVudGlsIGZhbHNlIGlzIHJldHVybmVkLlxuICAgICAqLyAgICBmb3JFYWNoV2hpbGUodCwgZSkge1xuICAgICAgICBsZXQgbjtcbiAgICAgICAgZm9yIChuID0gdm9pZCAwICE9PSBlID8gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShlKSA6IHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpOyBuLmhhc05leHQoKTsgKSB7XG4gICAgICAgICAgICBpZiAoIXQobi5nZXROZXh0KCkua2V5KSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBGaW5kcyB0aGUgbGVhc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYGVsZW1gLiAqLyAgICBmaXJzdEFmdGVyT3JFcXVhbCh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHQpO1xuICAgICAgICByZXR1cm4gZS5oYXNOZXh0KCkgPyBlLmdldE5leHQoKS5rZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsZSh0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKSk7XG4gICAgfVxuICAgIGdldEl0ZXJhdG9yRnJvbSh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgbGUodGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbSh0KSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCAqLyAgICBhZGQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuZGF0YS5yZW1vdmUodCkuaW5zZXJ0KHQsICEwKSk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGFuIGVsZW1lbnQgKi8gICAgZGVsZXRlKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKHQpID8gdGhpcy5jb3B5KHRoaXMuZGF0YS5yZW1vdmUodCkpIDogdGhpcztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pc0VtcHR5KCk7XG4gICAgfVxuICAgIHVuaW9uV2l0aCh0KSB7XG4gICAgICAgIGxldCBlID0gdGhpcztcbiAgICAgICAgLy8gTWFrZSBzdXJlIGByZXN1bHRgIGFsd2F5cyByZWZlcnMgdG8gdGhlIGxhcmdlciBvbmUgb2YgdGhlIHR3byBzZXRzLlxuICAgICAgICAgICAgICAgIHJldHVybiBlLnNpemUgPCB0LnNpemUgJiYgKGUgPSB0LCB0ID0gdGhpcyksIHQuZm9yRWFjaCgodCA9PiB7XG4gICAgICAgICAgICBlID0gZS5hZGQodCk7XG4gICAgICAgIH0pKSwgZTtcbiAgICB9XG4gICAgaXNFcXVhbCh0KSB7XG4gICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBoZSkpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gdC5zaXplKSByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKSwgbiA9IHQuZGF0YS5nZXRJdGVyYXRvcigpO1xuICAgICAgICBmb3IgKDtlLmhhc05leHQoKTsgKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gZS5nZXROZXh0KCkua2V5LCByID0gbi5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgaWYgKDAgIT09IHRoaXMuY29tcGFyYXRvcih0LCByKSkgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3QgdCA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlID0+IHtcbiAgICAgICAgICAgIHQucHVzaChlKTtcbiAgICAgICAgfSkpLCB0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdCA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlID0+IHQucHVzaChlKSkpLCBcIlNvcnRlZFNldChcIiArIHQudG9TdHJpbmcoKSArIFwiKVwiO1xuICAgIH1cbiAgICBjb3B5KHQpIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBoZSh0aGlzLmNvbXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gZS5kYXRhID0gdCwgZTtcbiAgICB9XG59XG5cbmNsYXNzIGxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuaXRlciA9IHQ7XG4gICAgfVxuICAgIGdldE5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuZ2V0TmV4dCgpLmtleTtcbiAgICB9XG4gICAgaGFzTmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5oYXNOZXh0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhIHNldCBvZiBmaWVsZHMgdGhhdCBjYW4gYmUgdXNlZCB0byBwYXJ0aWFsbHkgcGF0Y2ggYSBkb2N1bWVudC5cbiAqIEZpZWxkTWFzayBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggT2JqZWN0VmFsdWUuXG4gKiBFeGFtcGxlczpcbiAqICAgZm9vIC0gT3ZlcndyaXRlcyBmb28gZW50aXJlbHkgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuIElmIGZvbyBpcyBub3RcbiAqICAgICAgICAgcHJlc2VudCBpbiB0aGUgY29tcGFuaW9uIE9iamVjdFZhbHVlLCB0aGUgZmllbGQgaXMgZGVsZXRlZC5cbiAqICAgZm9vLmJhciAtIE92ZXJ3cml0ZXMgb25seSB0aGUgZmllbGQgYmFyIG9mIHRoZSBvYmplY3QgZm9vLlxuICogICAgICAgICAgICAgSWYgZm9vIGlzIG5vdCBhbiBvYmplY3QsIGZvbyBpcyByZXBsYWNlZCB3aXRoIGFuIG9iamVjdFxuICogICAgICAgICAgICAgY29udGFpbmluZyBmb29cbiAqLyBjbGFzcyBmZSB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IHQsIFxuICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IHZhbGlkYXRpb24gb2YgRmllbGRNYXNrXG4gICAgICAgIC8vIFNvcnQgdGhlIGZpZWxkIG1hc2sgdG8gc3VwcG9ydCBgRmllbGRNYXNrLmlzRXF1YWwoKWAgYW5kIGFzc2VydCBiZWxvdy5cbiAgICAgICAgdC5zb3J0KG50LmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZmUoW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEZpZWxkTWFzayBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGFkZGluZyBhbGwgdGhlIGdpdmVuXG4gICAgICogZmllbGRzIHBhdGhzIHRvIHRoaXMgZmllbGQgbWFzay5cbiAgICAgKi8gICAgdW5pb25XaXRoKHQpIHtcbiAgICAgICAgbGV0IGUgPSBuZXcgaGUobnQuY29tcGFyYXRvcik7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLmZpZWxkcykgZSA9IGUuYWRkKHQpO1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdCkgZSA9IGUuYWRkKG4pO1xuICAgICAgICByZXR1cm4gbmV3IGZlKGUudG9BcnJheSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCBgZmllbGRQYXRoYCBpcyBpbmNsdWRlZCBieSBhdCBsZWFzdCBvbmUgZmllbGQgaW4gdGhpcyBmaWVsZFxuICAgICAqIG1hc2suXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIE8obikgb3BlcmF0aW9uLCB3aGVyZSBgbmAgaXMgdGhlIHNpemUgb2YgdGhlIGZpZWxkIG1hc2suXG4gICAgICovICAgIGNvdmVycyh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmZpZWxkcykgaWYgKGUuaXNQcmVmaXhPZih0KSkgcmV0dXJuICEwO1xuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdnQodGhpcy5maWVsZHMsIHQuZmllbGRzLCAoKHQsIGUpID0+IHQuaXNFcXVhbChlKSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gT2JqZWN0VmFsdWUgcmVwcmVzZW50cyBhIE1hcFZhbHVlIGluIHRoZSBGaXJlc3RvcmUgUHJvdG8gYW5kIG9mZmVycyB0aGVcbiAqIGFiaWxpdHkgdG8gYWRkIGFuZCByZW1vdmUgZmllbGRzICh2aWEgdGhlIE9iamVjdFZhbHVlQnVpbGRlcikuXG4gKi8gY2xhc3MgZGUge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHQ7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZSh7XG4gICAgICAgICAgICBtYXBWYWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIG9yIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIHNlYXJjaFxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhdCB0aGUgcGF0aCBvciBudWxsIGlmIHRoZSBwYXRoIGlzIG5vdCBzZXQuXG4gICAgICovICAgIGZpZWxkKHQpIHtcbiAgICAgICAgaWYgKHQuaXNFbXB0eSgpKSByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aCAtIDE7ICsrbikgaWYgKGUgPSAoZS5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3QuZ2V0KG4pXSwgXG4gICAgICAgICAgICAhanQoZSkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGUgPSAoZS5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3QubGFzdFNlZ21lbnQoKV0sIGUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWVsZCB0byB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqLyAgICBzZXQodCwgZSkge1xuICAgICAgICB0aGlzLmdldEZpZWxkc01hcCh0LnBvcExhc3QoKSlbdC5sYXN0U2VnbWVudCgpXSA9IEJ0KGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm92aWRlZCBmaWVsZHMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gQSBtYXAgb2YgZmllbGRzIHRvIHZhbHVlcyAob3IgbnVsbCBmb3IgZGVsZXRlcykuXG4gICAgICovICAgIHNldEFsbCh0KSB7XG4gICAgICAgIGxldCBlID0gbnQuZW1wdHlQYXRoKCksIG4gPSB7fSwgciA9IFtdO1xuICAgICAgICB0LmZvckVhY2goKCh0LCBzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWUuaXNJbW1lZGlhdGVQYXJlbnRPZihzKSkge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgYWNjdW11bGF0ZWQgY2hhbmdlcyBhdCB0aGlzIHBhcmVudCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmdldEZpZWxkc01hcChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlcyh0LCBuLCByKSwgbiA9IHt9LCByID0gW10sIGUgPSBzLnBvcExhc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPyBuW3MubGFzdFNlZ21lbnQoKV0gPSBCdCh0KSA6IHIucHVzaChzLmxhc3RTZWdtZW50KCkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmdldEZpZWxkc01hcChlKTtcbiAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMocywgbiwgcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGZpZWxkIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC4gSWYgdGhlcmUgaXMgbm8gZmllbGQgYXQgdGhlXG4gICAgICogc3BlY2lmaWVkIHBhdGgsIG5vdGhpbmcgaXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpZWxkIHBhdGggdG8gcmVtb3ZlLlxuICAgICAqLyAgICBkZWxldGUodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5maWVsZCh0LnBvcExhc3QoKSk7XG4gICAgICAgIGp0KGUpICYmIGUubWFwVmFsdWUuZmllbGRzICYmIGRlbGV0ZSBlLm1hcFZhbHVlLmZpZWxkc1t0Lmxhc3RTZWdtZW50KCldO1xuICAgIH1cbiAgICBpc0VxdWFsKHQpIHtcbiAgICAgICAgcmV0dXJuIFN0KHRoaXMudmFsdWUsIHQudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAgdGhhdCBjb250YWlucyB0aGUgbGVhZiBlbGVtZW50IG9mIGBwYXRoYC4gSWYgdGhlIHBhcmVudFxuICAgICAqIGVudHJ5IGRvZXMgbm90IHlldCBleGlzdCwgb3IgaWYgaXQgaXMgbm90IGEgbWFwLCBhIG5ldyBtYXAgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqLyAgICBnZXRGaWVsZHNNYXAodCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGUubWFwVmFsdWUuZmllbGRzIHx8IChlLm1hcFZhbHVlID0ge1xuICAgICAgICAgICAgZmllbGRzOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICBsZXQgciA9IGUubWFwVmFsdWUuZmllbGRzW3QuZ2V0KG4pXTtcbiAgICAgICAgICAgIGp0KHIpICYmIHIubWFwVmFsdWUuZmllbGRzIHx8IChyID0ge1xuICAgICAgICAgICAgICAgIG1hcFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlLm1hcFZhbHVlLmZpZWxkc1t0LmdldChuKV0gPSByKSwgZSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUubWFwVmFsdWUuZmllbGRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyBgZmllbGRzTWFwYCBieSBhZGRpbmcsIHJlcGxhY2luZyBvciBkZWxldGluZyB0aGUgc3BlY2lmaWVkXG4gICAgICogZW50cmllcy5cbiAgICAgKi8gICAgYXBwbHlDaGFuZ2VzKHQsIGUsIG4pIHtcbiAgICAgICAgRXQoZSwgKChlLCBuKSA9PiB0W2VdID0gbikpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgbikgZGVsZXRlIHRbZV07XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IGRlKEJ0KHRoaXMudmFsdWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUgd2l0aCBhIGtleSwgdmVyc2lvbiwgZGF0YSBhbmQgd2hldGhlciBpdFxuICogaGFzIGxvY2FsIG11dGF0aW9ucyBhcHBsaWVkIHRvIGl0LlxuICpcbiAqIERvY3VtZW50cyBjYW4gdHJhbnNpdGlvbiBiZXR3ZWVuIHN0YXRlcyB2aWEgYGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoKWAsXG4gKiBgY29udmVydFRvTm9Eb2N1bWVudCgpYCBhbmQgYGNvbnZlcnRUb1Vua25vd25Eb2N1bWVudCgpYC4gSWYgYSBkb2N1bWVudCBkb2VzXG4gKiBub3QgdHJhbnNpdGlvbiB0byBvbmUgb2YgdGhlc2Ugc3RhdGVzIGV2ZW4gYWZ0ZXIgYWxsIG11dGF0aW9ucyBoYXZlIGJlZW5cbiAqIGFwcGxpZWQsIGBpc1ZhbGlkRG9jdW1lbnQoKWAgcmV0dXJucyBmYWxzZSBhbmQgdGhlIGRvY3VtZW50IHNob3VsZCBiZSByZW1vdmVkXG4gKiBmcm9tIGFsbCB2aWV3cy5cbiAqLyBjbGFzcyB3ZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgciwgcywgaSwgbykge1xuICAgICAgICB0aGlzLmtleSA9IHQsIHRoaXMuZG9jdW1lbnRUeXBlID0gZSwgdGhpcy52ZXJzaW9uID0gbiwgdGhpcy5yZWFkVGltZSA9IHIsIHRoaXMuY3JlYXRlVGltZSA9IHMsIFxuICAgICAgICB0aGlzLmRhdGEgPSBpLCB0aGlzLmRvY3VtZW50U3RhdGUgPSBvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZG9jdW1lbnQgd2l0aCBubyBrbm93biB2ZXJzaW9uIG9yIGRhdGEsIGJ1dCB3aGljaCBjYW4gc2VydmUgYXNcbiAgICAgKiBiYXNlIGRvY3VtZW50IGZvciBtdXRhdGlvbnMuXG4gICAgICovICAgIHN0YXRpYyBuZXdJbnZhbGlkRG9jdW1lbnQodCkge1xuICAgICAgICByZXR1cm4gbmV3IHdlKHQsIDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi8gLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyBvZS5taW4oKSwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIG9lLm1pbigpLCBcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBvZS5taW4oKSwgZGUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCB3aXRoIHRoZSBnaXZlbiBkYXRhIGF0IHRoZVxuICAgICAqIGdpdmVuIHZlcnNpb24uXG4gICAgICovICAgIHN0YXRpYyBuZXdGb3VuZERvY3VtZW50KHQsIGUsIG4sIHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3ZSh0LCAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLyAsIFxuICAgICAgICAvKiB2ZXJzaW9uICovIGUsIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBvZS5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gbiwgciwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gbm90IGV4aXN0IGF0IHRoZSBnaXZlbiB2ZXJzaW9uLiAqLyAgICBzdGF0aWMgbmV3Tm9Eb2N1bWVudCh0LCBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2UodCwgMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8gLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyBlLCBcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gb2UubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIG9lLm1pbigpLCBkZS5lbXB0eSgpLCAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIGV4aXN0IGF0IHRoZSBnaXZlbiB2ZXJzaW9uIGJ1dFxuICAgICAqIHdob3NlIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cbiAgICAgKi8gICAgc3RhdGljIG5ld1Vua25vd25Eb2N1bWVudCh0LCBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2UodCwgMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLyAsIFxuICAgICAgICAvKiB2ZXJzaW9uICovIGUsIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBvZS5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gb2UubWluKCksIGRlLmVtcHR5KCksIDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYW5kIHRoYXQgaXRzIHZlcnNpb25cbiAgICAgKiBhbmQgZGF0YSBhcmUga25vd24uXG4gICAgICovICAgIGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQodCwgZSkge1xuICAgICAgICAvLyBJZiBhIGRvY3VtZW50IGlzIHN3aXRjaGluZyBzdGF0ZSBmcm9tIGJlaW5nIGFuIGludmFsaWQgb3IgZGVsZXRlZFxuICAgICAgICAvLyBkb2N1bWVudCB0byBhIHZhbGlkIChGT1VORF9ET0NVTUVOVCkgZG9jdW1lbnQsIGVpdGhlciBkdWUgdG8gcmVjZWl2aW5nIGFuXG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIFdhdGNoIG9yIGR1ZSB0byBhcHBseWluZyBhIGxvY2FsIHNldCBtdXRhdGlvbiBvbiB0b3BcbiAgICAgICAgLy8gb2YgYSBkZWxldGVkIGRvY3VtZW50LCBvdXIgYmVzdCBndWVzcyBhYm91dCBpdHMgY3JlYXRlVGltZSB3b3VsZCBiZSB0aGVcbiAgICAgICAgLy8gdmVyc2lvbiBhdCB3aGljaCB0aGUgZG9jdW1lbnQgdHJhbnNpdGlvbmVkIHRvIGEgRk9VTkRfRE9DVU1FTlQuXG4gICAgICAgIHJldHVybiAhdGhpcy5jcmVhdGVUaW1lLmlzRXF1YWwob2UubWluKCkpIHx8IDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovICE9PSB0aGlzLmRvY3VtZW50VHlwZSAmJiAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovICE9PSB0aGlzLmRvY3VtZW50VHlwZSB8fCAodGhpcy5jcmVhdGVUaW1lID0gdCksIFxuICAgICAgICB0aGlzLnZlcnNpb24gPSB0LCB0aGlzLmRvY3VtZW50VHlwZSA9IDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovICwgdGhpcy5kYXRhID0gZSwgXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8gLCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndCBleGlzdCBhdCB0aGUgZ2l2ZW5cbiAgICAgKiB2ZXJzaW9uLlxuICAgICAqLyAgICBjb252ZXJ0VG9Ob0RvY3VtZW50KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbiA9IHQsIHRoaXMuZG9jdW1lbnRUeXBlID0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8gLCBcbiAgICAgICAgdGhpcy5kYXRhID0gZGUuZW1wdHkoKSwgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyAsIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYXQgYSBnaXZlbiB2ZXJzaW9uIGJ1dFxuICAgICAqIHRoYXQgaXRzIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cbiAgICAgKi8gICAgY29udmVydFRvVW5rbm93bkRvY3VtZW50KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbiA9IHQsIHRoaXMuZG9jdW1lbnRUeXBlID0gMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLyAsIFxuICAgICAgICB0aGlzLmRhdGEgPSBkZS5lbXB0eSgpLCB0aGlzLmRvY3VtZW50U3RhdGUgPSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi8gLCBcbiAgICAgICAgdGhpcztcbiAgICB9XG4gICAgc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovICwgdGhpcztcbiAgICB9XG4gICAgc2V0SGFzTG9jYWxNdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U3RhdGUgPSAxIC8qIERvY3VtZW50U3RhdGUuSEFTX0xPQ0FMX01VVEFUSU9OUyAqLyAsIHRoaXMudmVyc2lvbiA9IG9lLm1pbigpLCBcbiAgICAgICAgdGhpcztcbiAgICB9XG4gICAgc2V0UmVhZFRpbWUodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVGltZSA9IHQsIHRoaXM7XG4gICAgfVxuICAgIGdldCBoYXNMb2NhbE11dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovID09PSB0aGlzLmRvY3VtZW50U3RhdGU7XG4gICAgfVxuICAgIGdldCBoYXNDb21taXR0ZWRNdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi8gPT09IHRoaXMuZG9jdW1lbnRTdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGhhc1BlbmRpbmdXcml0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0xvY2FsTXV0YXRpb25zIHx8IHRoaXMuaGFzQ29tbWl0dGVkTXV0YXRpb25zO1xuICAgIH1cbiAgICBpc1ZhbGlkRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovICE9PSB0aGlzLmRvY3VtZW50VHlwZTtcbiAgICB9XG4gICAgaXNGb3VuZERvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi8gPT09IHRoaXMuZG9jdW1lbnRUeXBlO1xuICAgIH1cbiAgICBpc05vRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLyA9PT0gdGhpcy5kb2N1bWVudFR5cGU7XG4gICAgfVxuICAgIGlzVW5rbm93bkRvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLyA9PT0gdGhpcy5kb2N1bWVudFR5cGU7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIHdlICYmIHRoaXMua2V5LmlzRXF1YWwodC5rZXkpICYmIHRoaXMudmVyc2lvbi5pc0VxdWFsKHQudmVyc2lvbikgJiYgdGhpcy5kb2N1bWVudFR5cGUgPT09IHQuZG9jdW1lbnRUeXBlICYmIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gdC5kb2N1bWVudFN0YXRlICYmIHRoaXMuZGF0YS5pc0VxdWFsKHQuZGF0YSk7XG4gICAgfVxuICAgIG11dGFibGVDb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IHdlKHRoaXMua2V5LCB0aGlzLmRvY3VtZW50VHlwZSwgdGhpcy52ZXJzaW9uLCB0aGlzLnJlYWRUaW1lLCB0aGlzLmNyZWF0ZVRpbWUsIHRoaXMuZGF0YS5jbG9uZSgpLCB0aGlzLmRvY3VtZW50U3RhdGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBEb2N1bWVudCgke3RoaXMua2V5fSwgJHt0aGlzLnZlcnNpb259LCAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGF0YS52YWx1ZSl9LCB7Y3JlYXRlVGltZTogJHt0aGlzLmNyZWF0ZVRpbWV9fSksIHtkb2N1bWVudFR5cGU6ICR7dGhpcy5kb2N1bWVudFR5cGV9fSksIHtkb2N1bWVudFN0YXRlOiAke3RoaXMuZG9jdW1lbnRTdGF0ZX19KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgbWUge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUgPSBudWxsLCBuID0gW10sIHIgPSBbXSwgcyA9IG51bGwsIGkgPSBudWxsLCBvID0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhdGggPSB0LCB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGUsIHRoaXMub3JkZXJCeSA9IG4sIHRoaXMuZmlsdGVycyA9IHIsIHRoaXMubGltaXQgPSBzLCBcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gaSwgdGhpcy5lbmRBdCA9IG8sIHRoaXMuUyA9IG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgVGFyZ2V0IHdpdGggYSBwYXRoIGFuZCBvcHRpb25hbCBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxuICogUGF0aCBtdXN0IGN1cnJlbnRseSBiZSBlbXB0eSBpZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeS5cbiAqXG4gKiBOT1RFOiB5b3Ugc2hvdWxkIGFsd2F5cyBjb25zdHJ1Y3QgYFRhcmdldGAgZnJvbSBgUXVlcnkudG9UYXJnZXRgIGluc3RlYWQgb2ZcbiAqIHVzaW5nIHRoaXMgZmFjdG9yeSBtZXRob2QsIGJlY2F1c2UgYFF1ZXJ5YCBwcm92aWRlcyBhbiBpbXBsaWNpdCBgb3JkZXJCeWBcbiAqIHByb3BlcnR5LlxuICovIGZ1bmN0aW9uIHBlKHQsIGUgPSBudWxsLCBuID0gW10sIHIgPSBbXSwgcyA9IG51bGwsIGkgPSBudWxsLCBvID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgbWUodCwgZSwgbiwgciwgcywgaSwgbyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFF1ZXJ5IGVuY2Fwc3VsYXRlcyBhbGwgdGhlIHF1ZXJ5IGF0dHJpYnV0ZXMgd2Ugc3VwcG9ydCBpbiB0aGUgU0RLLiBJdCBjYW5cbiAqIGJlIHJ1biBhZ2FpbnN0IHRoZSBMb2NhbFN0b3JlLCBhcyB3ZWxsIGFzIGJlIGNvbnZlcnRlZCB0byBhIGBUYXJnZXRgIHRvXG4gKiBxdWVyeSB0aGUgUmVtb3RlU3RvcmUgcmVzdWx0cy5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5jbGFzcyB5ZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBRdWVyeSB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cbiAgICAgKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHQsIGUgPSBudWxsLCBuID0gW10sIHIgPSBbXSwgcyA9IG51bGwsIGkgPSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8gLCBvID0gbnVsbCwgdSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gdCwgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBlLCB0aGlzLmV4cGxpY2l0T3JkZXJCeSA9IG4sIHRoaXMuZmlsdGVycyA9IHIsIFxuICAgICAgICB0aGlzLmxpbWl0ID0gcywgdGhpcy5saW1pdFR5cGUgPSBpLCB0aGlzLnN0YXJ0QXQgPSBvLCB0aGlzLmVuZEF0ID0gdSwgdGhpcy5xID0gbnVsbCwgXG4gICAgICAgIC8vIFRoZSBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIG9mIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5PID0gbnVsbCwgdGhpcy5zdGFydEF0LCB0aGlzLmVuZEF0O1xuICAgIH1cbn1cblxuLyoqIENyZWF0ZXMgYSBuZXcgUXVlcnkgZm9yIGEgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgYXQgYHBhdGhgICovIGZ1bmN0aW9uIGdlKHQpIHtcbiAgICByZXR1cm4gdC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID4gMCA/IHQuZXhwbGljaXRPcmRlckJ5WzBdLmZpZWxkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gX2UodCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0LmZpbHRlcnMpIHtcbiAgICAgICAgY29uc3QgdCA9IGUuZ2V0Rmlyc3RJbmVxdWFsaXR5RmllbGQoKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHQpIHJldHVybiB0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGZvciBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHNcbiAqIHdpdGhpbiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBncm91cC5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgYSBjb2xsZWN0aW9uIGdyb3VwIHJhdGhlciB0aGFuIGEgc3BlY2lmaWNcbiAqIGNvbGxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHZlKHQpIHtcbiAgICByZXR1cm4gbnVsbCAhPT0gdC5jb2xsZWN0aW9uR3JvdXA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW1wbGljaXQgb3JkZXIgYnkgY29uc3RyYWludCB0aGF0IGlzIHVzZWQgdG8gZXhlY3V0ZSB0aGUgUXVlcnksXG4gKiB3aGljaCBjYW4gYmUgZGlmZmVyZW50IGZyb20gdGhlIG9yZGVyIGJ5IGNvbnN0cmFpbnRzIHRoZSB1c2VyIHByb3ZpZGVkIChlLmcuXG4gKiB0aGUgU0RLIGFuZCBiYWNrZW5kIGFsd2F5cyBvcmRlcnMgYnkgYF9fbmFtZV9fYCkuXG4gKi8gZnVuY3Rpb24gYmUodCkge1xuICAgIGNvbnN0IGUgPSBJKHQpO1xuICAgIGlmIChudWxsID09PSBlLnEpIHtcbiAgICAgICAgZS5xID0gW107XG4gICAgICAgIGNvbnN0IHQgPSBfZShlKSwgbiA9IGdlKGUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gdCAmJiBudWxsID09PSBuKSBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gaW1wbGljaXRseSBhZGQga2V5IG9yZGVyaW5nLCB3ZSBtdXN0IGFsc28gYWRkIHRoZVxuICAgICAgICAvLyBpbmVxdWFsaXR5IGZpbHRlciBmaWVsZCBmb3IgaXQgdG8gYmUgYSB2YWxpZCBxdWVyeS5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBkZWZhdWx0IGluZXF1YWxpdHkgZmllbGQgYW5kIGtleSBvcmRlcmluZyBpcyBhc2NlbmRpbmcuXG4gICAgICAgIHQuaXNLZXlGaWVsZCgpIHx8IGUucS5wdXNoKG5ldyBzZSh0KSksIGUucS5wdXNoKG5ldyBzZShudC5rZXlGaWVsZCgpLCBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8pKTsgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdCA9ICExO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIGUuZXhwbGljaXRPcmRlckJ5KSBlLnEucHVzaChuKSwgbi5maWVsZC5pc0tleUZpZWxkKCkgJiYgKHQgPSAhMCk7XG4gICAgICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGltcGxpY2l0IGtleSBvcmRlcmluZyBhbHdheXMgbWF0Y2hlcyB0aGUgbGFzdFxuICAgICAgICAgICAgICAgIC8vIGV4cGxpY2l0IG9yZGVyIGJ5XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA+IDAgPyBlLmV4cGxpY2l0T3JkZXJCeVtlLmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggLSAxXS5kaXIgOiBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi87XG4gICAgICAgICAgICAgICAgZS5xLnB1c2gobmV3IHNlKG50LmtleUZpZWxkKCksIHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZS5xO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSB0byBpdCdzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24uXG4gKi8gZnVuY3Rpb24gRWUodCkge1xuICAgIGNvbnN0IGUgPSBJKHQpO1xuICAgIGlmICghZS5PKSBpZiAoXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovID09PSBlLmxpbWl0VHlwZSkgZS5PID0gcGUoZS5wYXRoLCBlLmNvbGxlY3Rpb25Hcm91cCwgYmUoZSksIGUuZmlsdGVycywgZS5saW1pdCwgZS5zdGFydEF0LCBlLmVuZEF0KTsgZWxzZSB7XG4gICAgICAgIC8vIEZsaXAgdGhlIG9yZGVyQnkgZGlyZWN0aW9ucyBzaW5jZSB3ZSB3YW50IHRoZSBsYXN0IHJlc3VsdHNcbiAgICAgICAgY29uc3QgdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgYmUoZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLyA9PT0gbi5kaXIgPyBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8gOiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcbiAgICAgICAgICAgIHQucHVzaChuZXcgc2Uobi5maWVsZCwgZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc3dhcCB0aGUgY3Vyc29ycyB0byBtYXRjaCB0aGUgbm93LWZsaXBwZWQgcXVlcnkgb3JkZXJpbmcuXG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IGUuZW5kQXQgPyBuZXcgUXQoZS5lbmRBdC5wb3NpdGlvbiwgZS5lbmRBdC5pbmNsdXNpdmUpIDogbnVsbCwgciA9IGUuc3RhcnRBdCA/IG5ldyBRdChlLnN0YXJ0QXQucG9zaXRpb24sIGUuc3RhcnRBdC5pbmNsdXNpdmUpIDogbnVsbDtcbiAgICAgICAgLy8gTm93IHJldHVybiBhcyBhIExpbWl0VHlwZS5GaXJzdCBxdWVyeS5cbiAgICAgICAgZS5PID0gcGUoZS5wYXRoLCBlLmNvbGxlY3Rpb25Hcm91cCwgdCwgZS5maWx0ZXJzLCBlLmxpbWl0LCBuLCByKTtcbiAgICB9XG4gICAgcmV0dXJuIGUuTztcbn1cblxuZnVuY3Rpb24gSWUodCwgZSkge1xuICAgIGUuZ2V0Rmlyc3RJbmVxdWFsaXR5RmllbGQoKSwgX2UodCk7XG4gICAgY29uc3QgbiA9IHQuZmlsdGVycy5jb25jYXQoWyBlIF0pO1xuICAgIHJldHVybiBuZXcgeWUodC5wYXRoLCB0LmNvbGxlY3Rpb25Hcm91cCwgdC5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgbiwgdC5saW1pdCwgdC5saW1pdFR5cGUsIHQuc3RhcnRBdCwgdC5lbmRBdCk7XG59XG5cbmZ1bmN0aW9uIFRlKHQsIGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICBpZiAodC5saW1pdCAhPT0gZS5saW1pdCkgcmV0dXJuICExO1xuICAgICAgICBpZiAodC5vcmRlckJ5Lmxlbmd0aCAhPT0gZS5vcmRlckJ5Lmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQub3JkZXJCeS5sZW5ndGg7IG4rKykgaWYgKCFpZSh0Lm9yZGVyQnlbbl0sIGUub3JkZXJCeVtuXSkpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKHQuZmlsdGVycy5sZW5ndGggIT09IGUuZmlsdGVycy5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0LmZpbHRlcnMubGVuZ3RoOyBuKyspIGlmICghWXQodC5maWx0ZXJzW25dLCBlLmZpbHRlcnNbbl0pKSByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiB0LmNvbGxlY3Rpb25Hcm91cCA9PT0gZS5jb2xsZWN0aW9uR3JvdXAgJiYgISF0LnBhdGguaXNFcXVhbChlLnBhdGgpICYmICEhenQodC5zdGFydEF0LCBlLnN0YXJ0QXQpICYmIHp0KHQuZW5kQXQsIGUuZW5kQXQpO1xuICAgIH0oRWUodCksIEVlKGUpKSAmJiB0LmxpbWl0VHlwZSA9PT0gZS5saW1pdFR5cGU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYW4gRG91YmxlVmFsdWUgZm9yIGB2YWx1ZWAgdGhhdCBpcyBlbmNvZGVkIGJhc2VkIHRoZSBzZXJpYWxpemVyJ3NcbiAqIGB1c2VQcm90bzNKc29uYCBzZXR0aW5nLlxuICovXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIEludGVnZXJWYWx1ZSBpZiBpdCBjYW4gc2FmZWx5IHJlcHJlc2VudCB0aGUgdmFsdWUsXG4gKiBvdGhlcndpc2UgYSBEb3VibGVWYWx1ZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gQWUodCwgZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIE51bWJlci5pc0ludGVnZXIodCkgJiYgIWx0KHQpICYmIHQgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgdCA+PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9KGUpID8gXG4gICAgLyoqXG4gKiBSZXR1cm5zIGFuIEludGVnZXJWYWx1ZSBmb3IgYHZhbHVlYC5cbiAqL1xuICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVnZXJWYWx1ZTogXCJcIiArIHRcbiAgICAgICAgfTtcbiAgICB9KGUpIDogZnVuY3Rpb24odCwgZSkge1xuICAgICAgICBpZiAodC5rKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oZSkpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IFwiTmFOXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZSA9PT0gMSAvIDApIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IFwiSW5maW5pdHlcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlID09PSAtMSAvIDApIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IFwiLUluZmluaXR5XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvdWJsZVZhbHVlOiBsdChlKSA/IFwiLTBcIiA6IGVcbiAgICAgICAgfTtcbiAgICB9KHQsIGUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFVzZWQgdG8gcmVwcmVzZW50IGEgZmllbGQgdHJhbnNmb3JtIG9uIGEgbXV0YXRpb24uICovIGNsYXNzIFJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHN0cnVjdHVyYWwgdHlwZSBvZiBgVHJhbnNmb3JtT3BlcmF0aW9uYCBpcyB1bmlxdWUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzU0NTFcbiAgICAgICAgdGhpcy5fID0gdm9pZCAwO1xuICAgIH1cbn1cblxuLyoqIFRyYW5zZm9ybXMgYSB2YWx1ZSBpbnRvIGEgc2VydmVyLWdlbmVyYXRlZCB0aW1lc3RhbXAuICovIGNsYXNzIFBlIGV4dGVuZHMgUmUge31cblxuLyoqIFRyYW5zZm9ybXMgYW4gYXJyYXkgdmFsdWUgdmlhIGEgdW5pb24gb3BlcmF0aW9uLiAqLyBjbGFzcyBWZSBleHRlbmRzIFJlIHtcbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMuZWxlbWVudHMgPSB0O1xuICAgIH1cbn1cblxuLyoqIFRyYW5zZm9ybXMgYW4gYXJyYXkgdmFsdWUgdmlhIGEgcmVtb3ZlIG9wZXJhdGlvbi4gKi8gY2xhc3MgJGUgZXh0ZW5kcyBSZSB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICBzdXBlcigpLCB0aGlzLmVsZW1lbnRzID0gdDtcbiAgICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgYmFja2VuZCBzZW1hbnRpY3MgZm9yIGxvY2FsbHkgY29tcHV0ZWQgTlVNRVJJQ19BREQgKGluY3JlbWVudClcbiAqIHRyYW5zZm9ybXMuIENvbnZlcnRzIGFsbCBmaWVsZCB2YWx1ZXMgdG8gaW50ZWdlcnMgb3IgZG91YmxlcywgYnV0IHVubGlrZSB0aGVcbiAqIGJhY2tlbmQgZG9lcyBub3QgY2FwIGludGVnZXIgdmFsdWVzIGF0IDJeNjMuIEluc3RlYWQsIEphdmFTY3JpcHQgbnVtYmVyXG4gKiBhcml0aG1ldGljIGlzIHVzZWQgYW5kIHByZWNpc2lvbiBsb3NzIGNhbiBvY2N1ciBmb3IgdmFsdWVzIGdyZWF0ZXIgdGhhbiAyXjUzLlxuICovIGNsYXNzIE5lIGV4dGVuZHMgUmUge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgc3VwZXIoKSwgdGhpcy5DID0gdCwgdGhpcy5MID0gZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQSBmaWVsZCBwYXRoIGFuZCB0aGUgVHJhbnNmb3JtT3BlcmF0aW9uIHRvIHBlcmZvcm0gdXBvbiBpdC4gKi8gY2xhc3MgRGUge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IHQsIHRoaXMudHJhbnNmb3JtID0gZTtcbiAgICB9XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHByZWNvbmRpdGlvbiBmb3IgYSBtdXRhdGlvbi4gVGhpcyBmb2xsb3dzIHRoZSBtb2RlbCB0aGF0IHRoZVxuICogYmFja2VuZCBhY2NlcHRzIHdpdGggdGhlIHNwZWNpYWwgY2FzZSBvZiBhbiBleHBsaWNpdCBcImVtcHR5XCIgcHJlY29uZGl0aW9uXG4gKiAobWVhbmluZyBubyBwcmVjb25kaXRpb24pLlxuICovIGNsYXNzIEZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHQsIHRoaXMuZXhpc3RzID0gZTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZW1wdHkgUHJlY29uZGl0aW9uLiAqLyAgICBzdGF0aWMgbm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgUHJlY29uZGl0aW9uIHdpdGggYW4gZXhpc3RzIGZsYWcuICovICAgIHN0YXRpYyBleGlzdHModCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlKHZvaWQgMCwgdCk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiBiYXNlZCBvbiBhIHZlcnNpb24gYSBkb2N1bWVudCBleGlzdHMgYXQuICovICAgIHN0YXRpYyB1cGRhdGVUaW1lKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZSh0KTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGlzIFByZWNvbmRpdGlvbiBpcyBlbXB0eS4gKi8gICAgZ2V0IGlzTm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy51cGRhdGVUaW1lICYmIHZvaWQgMCA9PT0gdGhpcy5leGlzdHM7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leGlzdHMgPT09IHQuZXhpc3RzICYmICh0aGlzLnVwZGF0ZVRpbWUgPyAhIXQudXBkYXRlVGltZSAmJiB0aGlzLnVwZGF0ZVRpbWUuaXNFcXVhbCh0LnVwZGF0ZVRpbWUpIDogIXQudXBkYXRlVGltZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbXV0YXRpb24gZGVzY3JpYmVzIGEgc2VsZi1jb250YWluZWQgY2hhbmdlIHRvIGEgZG9jdW1lbnQuIE11dGF0aW9ucyBjYW5cbiAqIGNyZWF0ZSwgcmVwbGFjZSwgZGVsZXRlLCBhbmQgdXBkYXRlIHN1YnNldHMgb2YgZG9jdW1lbnRzLlxuICpcbiAqIE11dGF0aW9ucyBub3Qgb25seSBhY3Qgb24gdGhlIHZhbHVlIG9mIHRoZSBkb2N1bWVudCBidXQgYWxzbyBpdHMgdmVyc2lvbi5cbiAqXG4gKiBGb3IgbG9jYWwgbXV0YXRpb25zIChtdXRhdGlvbnMgdGhhdCBoYXZlbid0IGJlZW4gY29tbWl0dGVkIHlldCksIHdlIHByZXNlcnZlXG4gKiB0aGUgZXhpc3RpbmcgdmVyc2lvbiBmb3IgU2V0IGFuZCBQYXRjaCBtdXRhdGlvbnMuIEZvciBEZWxldGUgbXV0YXRpb25zLCB3ZVxuICogcmVzZXQgdGhlIHZlcnNpb24gdG8gMC5cbiAqXG4gKiBIZXJlJ3MgdGhlIGV4cGVjdGVkIHRyYW5zaXRpb24gdGFibGUuXG4gKlxuICogTVVUQVRJT04gICAgICAgICAgIEFQUExJRUQgVE8gICAgICAgICAgICBSRVNVTFRTIElOXG4gKlxuICogU2V0TXV0YXRpb24gICAgICAgIERvY3VtZW50KHYzKSAgICAgICAgICBEb2N1bWVudCh2MylcbiAqIFNldE11dGF0aW9uICAgICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgRG9jdW1lbnQodjApXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIERvY3VtZW50KHYwKVxuICogUGF0Y2hNdXRhdGlvbiAgICAgIERvY3VtZW50KHYzKSAgICAgICAgICBEb2N1bWVudCh2MylcbiAqIFBhdGNoTXV0YXRpb24gICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MylcbiAqIFBhdGNoTXV0YXRpb24gICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgVW5rbm93bkRvY3VtZW50KHYzKVxuICogRGVsZXRlTXV0YXRpb24gICAgIERvY3VtZW50KHYzKSAgICAgICAgICBOb0RvY3VtZW50KHYwKVxuICogRGVsZXRlTXV0YXRpb24gICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBOb0RvY3VtZW50KHYwKVxuICogRGVsZXRlTXV0YXRpb24gICAgIEludmFsaWREb2N1bWVudCh2MCkgICBOb0RvY3VtZW50KHYwKVxuICpcbiAqIEZvciBhY2tub3dsZWRnZWQgbXV0YXRpb25zLCB3ZSB1c2UgdGhlIHVwZGF0ZVRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgYXNcbiAqIHRoZSByZXN1bHRpbmcgdmVyc2lvbiBmb3IgU2V0IGFuZCBQYXRjaCBtdXRhdGlvbnMuIEFzIGRlbGV0ZXMgaGF2ZSBub1xuICogZXhwbGljaXQgdXBkYXRlIHRpbWUsIHdlIHVzZSB0aGUgY29tbWl0VGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSBmb3JcbiAqIERlbGV0ZSBtdXRhdGlvbnMuXG4gKlxuICogSWYgYSBtdXRhdGlvbiBpcyBhY2tub3dsZWRnZWQgYnkgdGhlIGJhY2tlbmQgYnV0IGZhaWxzIHRoZSBwcmVjb25kaXRpb24gY2hlY2tcbiAqIGxvY2FsbHksIHdlIHRyYW5zaXRpb24gdG8gYW4gYFVua25vd25Eb2N1bWVudGAgYW5kIHJlbHkgb24gV2F0Y2ggdG8gc2VuZCB1c1xuICogdGhlIHVwZGF0ZWQgdmVyc2lvbi5cbiAqXG4gKiBGaWVsZCB0cmFuc2Zvcm1zIGFyZSB1c2VkIG9ubHkgd2l0aCBQYXRjaCBhbmQgU2V0IE11dGF0aW9ucy4gV2UgdXNlIHRoZVxuICogYHVwZGF0ZVRyYW5zZm9ybXNgIG1lc3NhZ2UgdG8gc3RvcmUgdHJhbnNmb3JtcywgcmF0aGVyIHRoYW4gdGhlIGB0cmFuc2Zvcm1zYHNcbiAqIG1lc3NhZ2VzLlxuICpcbiAqICMjIFN1YmNsYXNzaW5nIE5vdGVzXG4gKlxuICogRXZlcnkgdHlwZSBvZiBtdXRhdGlvbiBuZWVkcyB0byBpbXBsZW1lbnQgaXRzIG93biBhcHBseVRvUmVtb3RlRG9jdW1lbnQoKSBhbmRcbiAqIGFwcGx5VG9Mb2NhbFZpZXcoKSB0byBpbXBsZW1lbnQgdGhlIGFjdHVhbCBiZWhhdmlvciBvZiBhcHBseWluZyB0aGUgbXV0YXRpb25cbiAqIHRvIHNvbWUgc291cmNlIGRvY3VtZW50IChzZWUgYHNldE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KClgIGZvciBhblxuICogZXhhbXBsZSkuXG4gKi8gY2xhc3MgeGUge31cblxuLyoqXG4gKiBBIG11dGF0aW9uIHRoYXQgY3JlYXRlcyBvciByZXBsYWNlcyB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoIHRoZVxuICogb2JqZWN0IHZhbHVlIGNvbnRlbnRzLlxuICovIGNsYXNzIFNlIGV4dGVuZHMgeGUge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4sIHIgPSBbXSkge1xuICAgICAgICBzdXBlcigpLCB0aGlzLmtleSA9IHQsIHRoaXMudmFsdWUgPSBlLCB0aGlzLnByZWNvbmRpdGlvbiA9IG4sIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gciwgXG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLztcbiAgICB9XG4gICAgZ2V0RmllbGRNYXNrKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IG1vZGlmaWVzIGZpZWxkcyBvZiB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoIHRoZVxuICogZ2l2ZW4gdmFsdWVzLiBUaGUgdmFsdWVzIGFyZSBhcHBsaWVkIHRocm91Z2ggYSBmaWVsZCBtYXNrOlxuICpcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBib3RoIHRoZSBtYXNrIGFuZCB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZFxuICogICAgaXMgdXBkYXRlZC5cbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBuZWl0aGVyIHRoZSBtYXNrIG5vciB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgZmllbGQgaXMgdW5tb2RpZmllZC5cbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiB0aGUgbWFzayBidXQgbm90IGluIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXG4gKiAgICBpcyBkZWxldGVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIG5vdCBpbiB0aGUgbWFzayBidXQgaXMgaW4gdGhlIHZhbHVlcywgdGhlIHZhbHVlcyBtYXAgaXNcbiAqICAgIGlnbm9yZWQuXG4gKi8gY2xhc3MgcWUgZXh0ZW5kcyB4ZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgciwgcyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMua2V5ID0gdCwgdGhpcy5kYXRhID0gZSwgdGhpcy5maWVsZE1hc2sgPSBuLCB0aGlzLnByZWNvbmRpdGlvbiA9IHIsIFxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IHMsIHRoaXMudHlwZSA9IDEgLyogTXV0YXRpb25UeXBlLlBhdGNoICovO1xuICAgIH1cbiAgICBnZXRGaWVsZE1hc2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkTWFzaztcbiAgICB9XG59XG5cbi8qKiBBIG11dGF0aW9uIHRoYXQgZGVsZXRlcyB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleS4gKi8gY2xhc3MgT2UgZXh0ZW5kcyB4ZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcigpLCB0aGlzLmtleSA9IHQsIHRoaXMucHJlY29uZGl0aW9uID0gZSwgdGhpcy50eXBlID0gMiAvKiBNdXRhdGlvblR5cGUuRGVsZXRlICovICwgXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbXV0YXRpb24gdGhhdCB2ZXJpZmllcyB0aGUgZXhpc3RlbmNlIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGhcbiAqIHRoZSBwcm92aWRlZCBwcmVjb25kaXRpb24uXG4gKlxuICogVGhlIGB2ZXJpZnlgIG9wZXJhdGlvbiBpcyBvbmx5IHVzZWQgaW4gVHJhbnNhY3Rpb25zLCBhbmQgdGhpcyBjbGFzcyBzZXJ2ZXNcbiAqIHByaW1hcmlseSB0byBmYWNpbGl0YXRlIHNlcmlhbGl6YXRpb24gaW50byBwcm90b3MuXG4gKi8gY2xhc3Mga2UgZXh0ZW5kcyB4ZSB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcigpLCB0aGlzLmtleSA9IHQsIHRoaXMucHJlY29uZGl0aW9uID0gZSwgdGhpcy50eXBlID0gMyAvKiBNdXRhdGlvblR5cGUuVmVyaWZ5ICovICwgXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjb25zdCBDZSA9ICgoKSA9PiB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgICAgYXNjOiBcIkFTQ0VORElOR1wiLFxuICAgICAgICBkZXNjOiBcIkRFU0NFTkRJTkdcIlxuICAgIH07XG4gICAgcmV0dXJuIHQ7XG59KSgpLCBMZSA9ICgoKSA9PiB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgICAgXCI8XCI6IFwiTEVTU19USEFOXCIsXG4gICAgICAgIFwiPD1cIjogXCJMRVNTX1RIQU5fT1JfRVFVQUxcIixcbiAgICAgICAgXCI+XCI6IFwiR1JFQVRFUl9USEFOXCIsXG4gICAgICAgIFwiPj1cIjogXCJHUkVBVEVSX1RIQU5fT1JfRVFVQUxcIixcbiAgICAgICAgXCI9PVwiOiBcIkVRVUFMXCIsXG4gICAgICAgIFwiIT1cIjogXCJOT1RfRVFVQUxcIixcbiAgICAgICAgXCJhcnJheS1jb250YWluc1wiOiBcIkFSUkFZX0NPTlRBSU5TXCIsXG4gICAgICAgIGluOiBcIklOXCIsXG4gICAgICAgIFwibm90LWluXCI6IFwiTk9UX0lOXCIsXG4gICAgICAgIFwiYXJyYXktY29udGFpbnMtYW55XCI6IFwiQVJSQVlfQ09OVEFJTlNfQU5ZXCJcbiAgICB9O1xuICAgIHJldHVybiB0O1xufSkoKSwgTWUgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAgIGFuZDogXCJBTkRcIixcbiAgICAgICAgb3I6IFwiT1JcIlxuICAgIH07XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIEpzb25PYmplY3QgdmFsdWVzIGZvciB0aGUgRGF0YXN0b3JlIEFQSSBzdWl0YWJsZSBmb3JcbiAqIHNlbmRpbmcgdG8gZWl0aGVyIEdSUEMgc3R1YiBtZXRob2RzIG9yIHZpYSB0aGUgSlNPTi9IVFRQIFJFU1QgQVBJLlxuICpcbiAqIFRoZSBzZXJpYWxpemVyIHN1cHBvcnRzIGJvdGggUHJvdG9idWYuanMgYW5kIFByb3RvMyBKU09OIGZvcm1hdHMuIEJ5XG4gKiBzZXR0aW5nIGB1c2VQcm90bzNKc29uYCB0byB0cnVlLCB0aGUgc2VyaWFsaXplciB3aWxsIHVzZSB0aGUgUHJvdG8zIEpTT05cbiAqIGZvcm1hdC5cbiAqXG4gKiBGb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgUHJvdG8zIEpTT04gZm9ybWF0IGNoZWNrXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqXG4gKiBUT0RPKGtsaW10KTogV2UgY2FuIHJlbW92ZSB0aGUgZGF0YWJhc2VJZCBhcmd1bWVudCBpZiB3ZSBrZWVwIHRoZSBmdWxsXG4gKiByZXNvdXJjZSBuYW1lIGluIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgVWUge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gdCwgdGhpcy5rID0gZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIGZvciBhIG51bWJlciAob3IgbnVsbCkgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvXG4gKiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIHByb3RvLlxuICogRE8gTk9UIFVTRSBUSElTIEZPUiBBTllUSElORyBFTFNFLlxuICogVGhpcyBtZXRob2QgY2hlYXRzLiBJdCdzIHR5cGVkIGFzIHJldHVybmluZyBcIm51bWJlclwiIGJlY2F1c2UgdGhhdCdzIHdoYXRcbiAqIG91ciBnZW5lcmF0ZWQgcHJvdG8gaW50ZXJmYWNlcyBzYXkgSW50MzJWYWx1ZSBtdXN0IGJlLiBCdXQgR1JQQyBhY3R1YWxseVxuICogZXhwZWN0cyBhIHsgdmFsdWU6IDxudW1iZXI+IH0gc3RydWN0LlxuICovXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBEYXRlIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxuICovXG5mdW5jdGlvbiBqZSh0LCBlKSB7XG4gICAgaWYgKHQuaykge1xuICAgICAgICByZXR1cm4gYCR7bmV3IERhdGUoMWUzICogZS5zZWNvbmRzKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcLlxcZCovLCBcIlwiKS5yZXBsYWNlKFwiWlwiLCBcIlwiKX0uJHsoXCIwMDAwMDAwMDBcIiArIGUubmFub3NlY29uZHMpLnNsaWNlKC05KX1aYDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogXCJcIiArIGUuc2Vjb25kcyxcbiAgICAgICAgbmFub3M6IGUubmFub3NlY29uZHNcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYnl0ZXMgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbiBhIHByb3RvLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIEJlKHQsIGUpIHtcbiAgICByZXR1cm4gdC5rID8gZS50b0Jhc2U2NCgpIDogZS50b1VpbnQ4QXJyYXkoKTtcbn1cblxuZnVuY3Rpb24gUWUodCwgZSkge1xuICAgIHJldHVybiBqZSh0LCBlLnRvVGltZXN0YW1wKCkpO1xufVxuXG5mdW5jdGlvbiB6ZSh0KSB7XG4gICAgcmV0dXJuIEUoISF0KSwgb2UuZnJvbVRpbWVzdGFtcChmdW5jdGlvbih0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBBdCh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWdChlLnNlY29uZHMsIGUubmFub3MpO1xuICAgIH0odCkpO1xufVxuXG5mdW5jdGlvbiBXZSh0LCBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0dChbIFwicHJvamVjdHNcIiwgdC5wcm9qZWN0SWQsIFwiZGF0YWJhc2VzXCIsIHQuZGF0YWJhc2UgXSk7XG4gICAgfSh0KS5jaGlsZChcImRvY3VtZW50c1wiKS5jaGlsZChlKS5jYW5vbmljYWxTdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gR2UodCwgZSkge1xuICAgIHJldHVybiBXZSh0LmRhdGFiYXNlSWQsIGUucGF0aCk7XG59XG5cbmZ1bmN0aW9uIEtlKHQsIGUpIHtcbiAgICBjb25zdCBuID0gZnVuY3Rpb24odCkge1xuICAgICAgICBjb25zdCBlID0gdHQuZnJvbVN0cmluZyh0KTtcbiAgICAgICAgcmV0dXJuIEUoY24oZSkpLCBlO1xuICAgIH0oZSk7XG4gICAgaWYgKG4uZ2V0KDEpICE9PSB0LmRhdGFiYXNlSWQucHJvamVjdElkKSB0aHJvdyBuZXcgVShQLCBcIlRyaWVkIHRvIGRlc2VyaWFsaXplIGtleSBmcm9tIGRpZmZlcmVudCBwcm9qZWN0OiBcIiArIG4uZ2V0KDEpICsgXCIgdnMgXCIgKyB0LmRhdGFiYXNlSWQucHJvamVjdElkKTtcbiAgICBpZiAobi5nZXQoMykgIT09IHQuZGF0YWJhc2VJZC5kYXRhYmFzZSkgdGhyb3cgbmV3IFUoUCwgXCJUcmllZCB0byBkZXNlcmlhbGl6ZSBrZXkgZnJvbSBkaWZmZXJlbnQgZGF0YWJhc2U6IFwiICsgbi5nZXQoMykgKyBcIiB2cyBcIiArIHQuZGF0YWJhc2VJZC5kYXRhYmFzZSk7XG4gICAgcmV0dXJuIG5ldyBydCgoRSgociA9IG4pLmxlbmd0aCA+IDQgJiYgXCJkb2N1bWVudHNcIiA9PT0gci5nZXQoNCkpLCByLnBvcEZpcnN0KDUpKSk7XG4gICAgdmFyIHI7XG4gICAgLyoqIENyZWF0ZXMgYSBEb2N1bWVudCBwcm90byBmcm9tIGtleSBhbmQgZmllbGRzIChidXQgbm8gY3JlYXRlL3VwZGF0ZSB0aW1lKSAqL31cblxuZnVuY3Rpb24gWWUodCwgZSkge1xuICAgIHJldHVybiBXZSh0LmRhdGFiYXNlSWQsIGUpO1xufVxuXG5mdW5jdGlvbiBIZSh0KSB7XG4gICAgcmV0dXJuIG5ldyB0dChbIFwicHJvamVjdHNcIiwgdC5kYXRhYmFzZUlkLnByb2plY3RJZCwgXCJkYXRhYmFzZXNcIiwgdC5kYXRhYmFzZUlkLmRhdGFiYXNlIF0pLmNhbm9uaWNhbFN0cmluZygpO1xufVxuXG5mdW5jdGlvbiBKZSh0LCBlLCBuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogR2UodCwgZSksXG4gICAgICAgIGZpZWxkczogbi52YWx1ZS5tYXBWYWx1ZS5maWVsZHNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBYZSh0LCBlKSB7XG4gICAgcmV0dXJuIFwiZm91bmRcIiBpbiBlID8gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICBFKCEhZS5mb3VuZCksIGUuZm91bmQubmFtZSwgZS5mb3VuZC51cGRhdGVUaW1lO1xuICAgICAgICBjb25zdCBuID0gS2UodCwgZS5mb3VuZC5uYW1lKSwgciA9IHplKGUuZm91bmQudXBkYXRlVGltZSksIHMgPSBlLmZvdW5kLmNyZWF0ZVRpbWUgPyB6ZShlLmZvdW5kLmNyZWF0ZVRpbWUpIDogb2UubWluKCksIGkgPSBuZXcgZGUoe1xuICAgICAgICAgICAgbWFwVmFsdWU6IHtcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGUuZm91bmQuZmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd2UubmV3Rm91bmREb2N1bWVudChuLCByLCBzLCBpKTtcbiAgICB9KHQsIGUpIDogXCJtaXNzaW5nXCIgaW4gZSA/IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgRSghIWUubWlzc2luZyksIEUoISFlLnJlYWRUaW1lKTtcbiAgICAgICAgY29uc3QgbiA9IEtlKHQsIGUubWlzc2luZyksIHIgPSB6ZShlLnJlYWRUaW1lKTtcbiAgICAgICAgcmV0dXJuIHdlLm5ld05vRG9jdW1lbnQobiwgcik7XG4gICAgfSh0LCBlKSA6IGIoKTtcbn1cblxuZnVuY3Rpb24gWmUodCwgZSkge1xuICAgIGxldCBuO1xuICAgIGlmIChlIGluc3RhbmNlb2YgU2UpIG4gPSB7XG4gICAgICAgIHVwZGF0ZTogSmUodCwgZS5rZXksIGUudmFsdWUpXG4gICAgfTsgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIE9lKSBuID0ge1xuICAgICAgICBkZWxldGU6IEdlKHQsIGUua2V5KVxuICAgIH07IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBxZSkgbiA9IHtcbiAgICAgICAgdXBkYXRlOiBKZSh0LCBlLmtleSwgZS5kYXRhKSxcbiAgICAgICAgdXBkYXRlTWFzazogdW4oZS5maWVsZE1hc2spXG4gICAgfTsgZWxzZSB7XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBrZSkpIHJldHVybiBiKCk7XG4gICAgICAgIG4gPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IEdlKHQsIGUua2V5KVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZS5maWVsZFRyYW5zZm9ybXMubGVuZ3RoID4gMCAmJiAobi51cGRhdGVUcmFuc2Zvcm1zID0gZS5maWVsZFRyYW5zZm9ybXMubWFwKCh0ID0+IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgY29uc3QgbiA9IGUudHJhbnNmb3JtO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIFBlKSByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRQYXRoOiBlLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgc2V0VG9TZXJ2ZXJWYWx1ZTogXCJSRVFVRVNUX1RJTUVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIFZlKSByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRQYXRoOiBlLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgYXBwZW5kTWlzc2luZ0VsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBuLmVsZW1lbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgJGUpIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGUuZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tQXJyYXk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IG4uZWxlbWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBOZSkgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcbiAgICAgICAgICAgIGluY3JlbWVudDogbi5MXG4gICAgICAgIH07XG4gICAgICAgIHRocm93IGIoKTtcbiAgICB9KDAsIHQpKSkpLCBlLnByZWNvbmRpdGlvbi5pc05vbmUgfHwgKG4uY3VycmVudERvY3VtZW50ID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBlLnVwZGF0ZVRpbWUgPyB7XG4gICAgICAgICAgICB1cGRhdGVUaW1lOiBRZSh0LCBlLnVwZGF0ZVRpbWUpXG4gICAgICAgIH0gOiB2b2lkIDAgIT09IGUuZXhpc3RzID8ge1xuICAgICAgICAgICAgZXhpc3RzOiBlLmV4aXN0c1xuICAgICAgICB9IDogYigpO1xuICAgIH0odCwgZS5wcmVjb25kaXRpb24pKSwgbjtcbn1cblxuZnVuY3Rpb24gdG4odCwgZSkge1xuICAgIC8vIERpc3NlY3QgdGhlIHBhdGggaW50byBwYXJlbnQsIGNvbGxlY3Rpb25JZCwgYW5kIG9wdGlvbmFsIGtleSBmaWx0ZXIuXG4gICAgY29uc3QgbiA9IHtcbiAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiB7fVxuICAgIH0sIHIgPSBlLnBhdGg7XG4gICAgbnVsbCAhPT0gZS5jb2xsZWN0aW9uR3JvdXAgPyAobi5wYXJlbnQgPSBZZSh0LCByKSwgbi5zdHJ1Y3R1cmVkUXVlcnkuZnJvbSA9IFsge1xuICAgICAgICBjb2xsZWN0aW9uSWQ6IGUuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICBhbGxEZXNjZW5kYW50czogITBcbiAgICB9IF0pIDogKG4ucGFyZW50ID0gWWUodCwgci5wb3BMYXN0KCkpLCBuLnN0cnVjdHVyZWRRdWVyeS5mcm9tID0gWyB7XG4gICAgICAgIGNvbGxlY3Rpb25JZDogci5sYXN0U2VnbWVudCgpXG4gICAgfSBdKTtcbiAgICBjb25zdCBzID0gZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoMCA9PT0gdC5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIG9uKEt0LmNyZWF0ZSh0LCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xuICAgIH0oZS5maWx0ZXJzKTtcbiAgICBzICYmIChuLnN0cnVjdHVyZWRRdWVyeS53aGVyZSA9IHMpO1xuICAgIGNvbnN0IGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgwID09PSB0Lmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdC5tYXAoKHQgPT4gXG4gICAgICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcbiAgICAgICAgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWVsZDogc24odC5maWVsZCksXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBlbih0LmRpcilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuICAgICAgICAodCkpKTtcbiAgICB9KGUub3JkZXJCeSk7XG4gICAgaSAmJiAobi5zdHJ1Y3R1cmVkUXVlcnkub3JkZXJCeSA9IGkpO1xuICAgIGNvbnN0IG8gPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LmsgfHwgaHQoZSkgPyBlIDoge1xuICAgICAgICAgICAgdmFsdWU6IGVcbiAgICAgICAgfTtcbiAgICB9KHQsIGUubGltaXQpO1xuICAgIHZhciB1O1xuICAgIHJldHVybiBudWxsICE9PSBvICYmIChuLnN0cnVjdHVyZWRRdWVyeS5saW1pdCA9IG8pLCBlLnN0YXJ0QXQgJiYgKG4uc3RydWN0dXJlZFF1ZXJ5LnN0YXJ0QXQgPSB7XG4gICAgICAgIGJlZm9yZTogKHUgPSBlLnN0YXJ0QXQpLmluY2x1c2l2ZSxcbiAgICAgICAgdmFsdWVzOiB1LnBvc2l0aW9uXG4gICAgfSksIGUuZW5kQXQgJiYgKG4uc3RydWN0dXJlZFF1ZXJ5LmVuZEF0ID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmVmb3JlOiAhdC5pbmNsdXNpdmUsXG4gICAgICAgICAgICB2YWx1ZXM6IHQucG9zaXRpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuICAgIChlLmVuZEF0KSksIG47XG59XG5cbmZ1bmN0aW9uIGVuKHQpIHtcbiAgICByZXR1cm4gQ2VbdF07XG59XG5cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIG5uKHQpIHtcbiAgICByZXR1cm4gTGVbdF07XG59XG5cbmZ1bmN0aW9uIHJuKHQpIHtcbiAgICByZXR1cm4gTWVbdF07XG59XG5cbmZ1bmN0aW9uIHNuKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZFBhdGg6IHQuY2Fub25pY2FsU3RyaW5nKClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBvbih0KSB7XG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBHdCA/IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLyA9PT0gdC5vcCkge1xuICAgICAgICAgICAgaWYgKFV0KHQudmFsdWUpKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzbih0LmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiSVNfTkFOXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKE10KHQudmFsdWUpKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzbih0LmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiSVNfTlVMTFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovID09PSB0Lm9wKSB7XG4gICAgICAgICAgICBpZiAoVXQodC52YWx1ZSkpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNuKHQuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogXCJJU19OT1RfTkFOXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKE10KHQudmFsdWUpKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzbih0LmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiSVNfTk9UX05VTExcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IHNuKHQuZmllbGQpLFxuICAgICAgICAgICAgICAgIG9wOiBubih0Lm9wKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0odCkgOiB0IGluc3RhbmNlb2YgS3QgPyBmdW5jdGlvbih0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0LmdldEZpbHRlcnMoKS5tYXAoKHQgPT4gb24odCkpKTtcbiAgICAgICAgaWYgKDEgPT09IGUubGVuZ3RoKSByZXR1cm4gZVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZUZpbHRlcjoge1xuICAgICAgICAgICAgICAgIG9wOiBybih0Lm9wKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSh0KSA6IGIoKTtcbn1cblxuZnVuY3Rpb24gdW4odCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdC5maWVsZHMuZm9yRWFjaCgodCA9PiBlLnB1c2godC5jYW5vbmljYWxTdHJpbmcoKSkpKSwge1xuICAgICAgICBmaWVsZFBhdGhzOiBlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY24odCkge1xuICAgIC8vIFJlc291cmNlIG5hbWVzIGhhdmUgYXQgbGVhc3QgNCBjb21wb25lbnRzIChwcm9qZWN0IElELCBkYXRhYmFzZSBJRClcbiAgICByZXR1cm4gdC5sZW5ndGggPj0gNCAmJiBcInByb2plY3RzXCIgPT09IHQuZ2V0KDApICYmIFwiZGF0YWJhc2VzXCIgPT09IHQuZ2V0KDIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiBhbih0KSB7XG4gICAgcmV0dXJuIG5ldyBVZSh0LCAvKiB1c2VQcm90bzNKc29uPSAqLyAhMCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgaGVscGVyIGZvciBydW5uaW5nIGRlbGF5ZWQgdGFza3MgZm9sbG93aW5nIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYgY3VydmVcbiAqIGJldHdlZW4gYXR0ZW1wdHMuXG4gKlxuICogRWFjaCBkZWxheSBpcyBtYWRlIHVwIG9mIGEgXCJiYXNlXCIgZGVsYXkgd2hpY2ggZm9sbG93cyB0aGUgZXhwb25lbnRpYWxcbiAqIGJhY2tvZmYgY3VydmUsIGFuZCBhICsvLSA1MCUgXCJqaXR0ZXJcIiB0aGF0IGlzIGNhbGN1bGF0ZWQgYW5kIGFkZGVkIHRvIHRoZVxuICogYmFzZSBkZWxheS4gVGhpcyBwcmV2ZW50cyBjbGllbnRzIGZyb20gYWNjaWRlbnRhbGx5IHN5bmNocm9uaXppbmcgdGhlaXJcbiAqIGRlbGF5cyBjYXVzaW5nIHNwaWtlcyBvZiBsb2FkIHRvIHRoZSBiYWNrZW5kLlxuICovXG5jbGFzcyBobiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIEFzeW5jUXVldWUgdG8gcnVuIGJhY2tvZmYgb3BlcmF0aW9ucyBvbi5cbiAgICAgKi9cbiAgICB0LCBcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgdG8gdXNlIHdoZW4gc2NoZWR1bGluZyBiYWNrb2ZmIG9wZXJhdGlvbnMgb24gdGhlIEFzeW5jUXVldWUuXG4gICAgICovXG4gICAgZSwgXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgZGVsYXkgKHVzZWQgYXMgdGhlIGJhc2UgZGVsYXkgb24gdGhlIGZpcnN0IHJldHJ5IGF0dGVtcHQpLlxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXG4gICAgICogbGl0dGxlIGFzIDAuNSppbml0aWFsRGVsYXlNcy5cbiAgICAgKi9cbiAgICBuID0gMWUzXG4gICAgLyoqXG4gICAgICogVGhlIG11bHRpcGxpZXIgdG8gdXNlIHRvIGRldGVybWluZSB0aGUgZXh0ZW5kZWQgYmFzZSBkZWxheSBhZnRlciBlYWNoXG4gICAgICogYXR0ZW1wdC5cbiAgICAgKi8gLCByID0gMS41XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gYmFzZSBkZWxheSBhZnRlciB3aGljaCBubyBmdXJ0aGVyIGJhY2tvZmYgaXMgcGVyZm9ybWVkLlxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXG4gICAgICogbXVjaCBhcyAxLjUqbWF4RGVsYXlNcy5cbiAgICAgKi8gLCBzID0gNmU0KSB7XG4gICAgICAgIHRoaXMuTSA9IHQsIHRoaXMudGltZXJJZCA9IGUsIHRoaXMuVSA9IG4sIHRoaXMuaiA9IHIsIHRoaXMuQiA9IHMsIHRoaXMuVyA9IDAsIHRoaXMuRyA9IG51bGwsIFxuICAgICAgICAvKiogVGhlIGxhc3QgYmFja29mZiBhdHRlbXB0LCBhcyBlcG9jaCBtaWxsaXNlY29uZHMuICovXG4gICAgICAgIHRoaXMuSyA9IERhdGUubm93KCksIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5LlxuICAgICAqXG4gICAgICogVGhlIHZlcnkgbmV4dCBiYWNrb2ZmQW5kV2FpdCgpIHdpbGwgaGF2ZSBubyBkZWxheS4gSWYgaXQgaXMgY2FsbGVkIGFnYWluXG4gICAgICogKGkuZS4gZHVlIHRvIGFuIGVycm9yKSwgaW5pdGlhbERlbGF5TXMgKHBsdXMgaml0dGVyKSB3aWxsIGJlIHVzZWQsIGFuZFxuICAgICAqIHN1YnNlcXVlbnQgb25lcyB3aWxsIGluY3JlYXNlIGFjY29yZGluZyB0byB0aGUgYmFja29mZkZhY3Rvci5cbiAgICAgKi8gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuVyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byB0aGUgbWF4aW11bSBkZWxheSAoZS5nLiBmb3IgdXNlIGFmdGVyIGFcbiAgICAgKiBSRVNPVVJDRV9FWEhBVVNURUQgZXJyb3IpLlxuICAgICAqLyAgICBZKCkge1xuICAgICAgICB0aGlzLlcgPSB0aGlzLkI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgY3VycmVudERlbGF5TXMsIGFuZCBpbmNyZWFzZXMgdGhlXG4gICAgICogZGVsYXkgZm9yIGFueSBzdWJzZXF1ZW50IGF0dGVtcHRzLiBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGJhY2tvZmYgb3BlcmF0aW9uXG4gICAgICogYWxyZWFkeSwgaXQgd2lsbCBiZSBjYW5jZWxlZC5cbiAgICAgKi8gICAgSCh0KSB7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvbi5cbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgLy8gRmlyc3Qgc2NoZWR1bGUgdXNpbmcgdGhlIGN1cnJlbnQgYmFzZSAod2hpY2ggbWF5IGJlIDAgYW5kIHNob3VsZCBiZVxuICAgICAgICAvLyBob25vcmVkIGFzIHN1Y2gpLlxuICAgICAgICBjb25zdCBlID0gTWF0aC5mbG9vcih0aGlzLlcgKyB0aGlzLkooKSksIG4gPSBNYXRoLm1heCgwLCBEYXRlLm5vdygpIC0gdGhpcy5LKSwgciA9IE1hdGgubWF4KDAsIGUgLSBuKTtcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBsYXN0QXR0ZW1wdFRpbWUgYmVpbmcgaW4gdGhlIGZ1dHVyZSBkdWUgdG8gYSBjbG9jayBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgciA+IDAgJiYgeShcIkV4cG9uZW50aWFsQmFja29mZlwiLCBgQmFja2luZyBvZmYgZm9yICR7cn0gbXMgKGJhc2UgZGVsYXk6ICR7dGhpcy5XfSBtcywgZGVsYXkgd2l0aCBqaXR0ZXI6ICR7ZX0gbXMsIGxhc3QgYXR0ZW1wdDogJHtufSBtcyBhZ28pYCksIFxuICAgICAgICB0aGlzLkcgPSB0aGlzLk0uZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy50aW1lcklkLCByLCAoKCkgPT4gKHRoaXMuSyA9IERhdGUubm93KCksIFxuICAgICAgICB0KCkpKSksIFxuICAgICAgICAvLyBBcHBseSBiYWNrb2ZmIGZhY3RvciB0byBkZXRlcm1pbmUgbmV4dCBkZWxheSBhbmQgZW5zdXJlIGl0IGlzIHdpdGhpblxuICAgICAgICAvLyBib3VuZHMuXG4gICAgICAgIHRoaXMuVyAqPSB0aGlzLmosIHRoaXMuVyA8IHRoaXMuVSAmJiAodGhpcy5XID0gdGhpcy5VKSwgdGhpcy5XID4gdGhpcy5CICYmICh0aGlzLlcgPSB0aGlzLkIpO1xuICAgIH1cbiAgICBYKCkge1xuICAgICAgICBudWxsICE9PSB0aGlzLkcgJiYgKHRoaXMuRy5za2lwRGVsYXkoKSwgdGhpcy5HID0gbnVsbCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgbnVsbCAhPT0gdGhpcy5HICYmICh0aGlzLkcuY2FuY2VsKCksIHRoaXMuRyA9IG51bGwpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWy1jdXJyZW50QmFzZU1zLzIsIGN1cnJlbnRCYXNlTXMvMl0gKi8gICAgSigpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpIC0gLjUpICogdGhpcy5XO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGF0YXN0b3JlIGFuZCBpdHMgcmVsYXRlZCBtZXRob2RzIGFyZSBhIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBHb29nbGVcbiAqIENsb3VkIERhdGFzdG9yZSBncnBjIEFQSSwgd2hpY2ggcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgaXMgbW9yZSBjb252ZW5pZW50XG4gKiBmb3IgdGhlIHJlc3Qgb2YgdGhlIGNsaWVudCBTREsgYXJjaGl0ZWN0dXJlIHRvIGNvbnN1bWUuXG4gKi9cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgRGF0YXN0b3JlIHRoYXQgZXhwb3NlcyBhZGRpdGlvbmFsIHN0YXRlIGZvciBpbnRlcm5hbFxuICogY29uc3VtcHRpb24uXG4gKi9cbmNsYXNzIGxuIGV4dGVuZHMgY2xhc3Mge30ge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4sIHIpIHtcbiAgICAgICAgc3VwZXIoKSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSB0LCB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMgPSBlLCB0aGlzLmNvbm5lY3Rpb24gPSBuLCBcbiAgICAgICAgdGhpcy5DID0gciwgdGhpcy5aID0gITE7XG4gICAgfVxuICAgIHR0KCkge1xuICAgICAgICBpZiAodGhpcy5aKSB0aHJvdyBuZXcgVShTLCBcIlRoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiB0ZXJtaW5hdGVkLlwiKTtcbiAgICB9XG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIGF1dGggYW5kIEFwcENoZWNrIHRva2Vucy4gKi8gICAgSSh0LCBlLCBuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR0KCksIFByb21pc2UuYWxsKFsgdGhpcy5hdXRoQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSwgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmdldFRva2VuKCkgXSkudGhlbigoKFtyLCBzXSkgPT4gdGhpcy5jb25uZWN0aW9uLkkodCwgZSwgbiwgciwgcykpKS5jYXRjaCgodCA9PiB7XG4gICAgICAgICAgICB0aHJvdyBcIkZpcmViYXNlRXJyb3JcIiA9PT0gdC5uYW1lID8gKHQuY29kZSA9PT0gRiAmJiAodGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCksIFxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpKSwgdCkgOiBuZXcgVShSLCB0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKiBJbnZva2VzIHRoZSBwcm92aWRlZCBSUEMgd2l0aCBzdHJlYW1lZCByZXN1bHRzIHdpdGggYXV0aCBhbmQgQXBwQ2hlY2sgdG9rZW5zLiAqLyAgICBQKHQsIGUsIG4sIHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHQoKSwgUHJvbWlzZS5hbGwoWyB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLCB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSBdKS50aGVuKCgoW3MsIGldKSA9PiB0aGlzLmNvbm5lY3Rpb24uUCh0LCBlLCBuLCBzLCBpLCByKSkpLmNhdGNoKCh0ID0+IHtcbiAgICAgICAgICAgIHRocm93IFwiRmlyZWJhc2VFcnJvclwiID09PSB0Lm5hbWUgPyAodC5jb2RlID09PSBGICYmICh0aGlzLmF1dGhDcmVkZW50aWFscy5pbnZhbGlkYXRlVG9rZW4oKSwgXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCkpLCB0KSA6IG5ldyBVKFIsIHQudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICB0aGlzLlogPSAhMDtcbiAgICB9XG59XG5cbi8vIFRPRE8oZmlyZXN0b3JleHApOiBNYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgRGF0YXN0b3JlIGluc3RhbmNlIHBlclxuLy8gZmlyZXN0b3JlLWV4cCBjbGllbnQuXG5hc3luYyBmdW5jdGlvbiBmbih0LCBlKSB7XG4gICAgY29uc3QgbiA9IEkodCksIHIgPSBIZShuLkMpICsgXCIvZG9jdW1lbnRzXCIsIHMgPSB7XG4gICAgICAgIHdyaXRlczogZS5tYXAoKHQgPT4gWmUobi5DLCB0KSkpXG4gICAgfTtcbiAgICBhd2FpdCBuLkkoXCJDb21taXRcIiwgciwgcyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRuKHQsIGUpIHtcbiAgICBjb25zdCBuID0gSSh0KSwgciA9IEhlKG4uQykgKyBcIi9kb2N1bWVudHNcIiwgcyA9IHtcbiAgICAgICAgZG9jdW1lbnRzOiBlLm1hcCgodCA9PiBHZShuLkMsIHQpKSlcbiAgICB9LCBpID0gYXdhaXQgbi5QKFwiQmF0Y2hHZXREb2N1bWVudHNcIiwgciwgcywgZS5sZW5ndGgpLCBvID0gbmV3IE1hcDtcbiAgICBpLmZvckVhY2goKHQgPT4ge1xuICAgICAgICBjb25zdCBlID0gWGUobi5DLCB0KTtcbiAgICAgICAgby5zZXQoZS5rZXkudG9TdHJpbmcoKSwgZSk7XG4gICAgfSkpO1xuICAgIGNvbnN0IHUgPSBbXTtcbiAgICByZXR1cm4gZS5mb3JFYWNoKCh0ID0+IHtcbiAgICAgICAgY29uc3QgZSA9IG8uZ2V0KHQudG9TdHJpbmcoKSk7XG4gICAgICAgIEUoISFlKSwgdS5wdXNoKGUpO1xuICAgIH0pKSwgdTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd24odCwgZSkge1xuICAgIGNvbnN0IG4gPSBJKHQpLCByID0gdG4obi5DLCBFZShlKSk7XG4gICAgcmV0dXJuIChhd2FpdCBuLlAoXCJSdW5RdWVyeVwiLCByLnBhcmVudCwge1xuICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IHIuc3RydWN0dXJlZFF1ZXJ5XG4gICAgfSkpLmZpbHRlcigodCA9PiAhIXQuZG9jdW1lbnQpKS5tYXAoKHQgPT4gZnVuY3Rpb24odCwgZSwgbikge1xuICAgICAgICBjb25zdCByID0gS2UodCwgZS5uYW1lKSwgcyA9IHplKGUudXBkYXRlVGltZSksIGkgPSBlLmNyZWF0ZVRpbWUgPyB6ZShlLmNyZWF0ZVRpbWUpIDogb2UubWluKCksIG8gPSBuZXcgZGUoe1xuICAgICAgICAgICAgbWFwVmFsdWU6IHtcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGUuZmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB1ID0gd2UubmV3Rm91bmREb2N1bWVudChyLCBzLCBpLCBvKTtcbiAgICAgICAgcmV0dXJuIG4gJiYgdS5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSwgbiA/IHUuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCkgOiB1O1xuICAgIH0obi5DLCB0LmRvY3VtZW50LCB2b2lkIDApKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1uKHQsIGUpIHtcbiAgICBjb25zdCBuID0gSSh0KSwgciA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRuKHQsIGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnk6IHtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbnM6IFsge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDoge30sXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcImNvdW50X2FsaWFzXCJcbiAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiBuLnN0cnVjdHVyZWRRdWVyeVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogbi5wYXJlbnRcbiAgICAgICAgfTtcbiAgICB9KG4uQywgRWUoZSkpLCBzID0gci5wYXJlbnQ7XG4gICAgbi5jb25uZWN0aW9uLnYgfHwgZGVsZXRlIHIucGFyZW50O1xuICAgIHJldHVybiAoYXdhaXQgbi5QKFwiUnVuQWdncmVnYXRpb25RdWVyeVwiLCBzLCByLCAvKmV4cGVjdGVkUmVzcG9uc2VDb3VudD0qLyAxKSkuZmlsdGVyKCh0ID0+ICEhdC5yZXN1bHQpKS5tYXAoKHQgPT4gdC5yZXN1bHQuYWdncmVnYXRlRmllbGRzKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNvbnN0IHBuID0gbmV3IE1hcDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBtYXAgdGhhdCBlbnN1cmVzIG9ubHkgb25lIERhdGFzdG9yZSBleGlzdHMgcGVyIEZpcmVzdG9yZVxuICogaW5zdGFuY2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhbiBpbml0aWFsaXplZCBhbmQgc3RhcnRlZCBEYXRhc3RvcmUgZm9yIHRoZSBnaXZlbiBGaXJlc3RvcmVcbiAqIGluc3RhbmNlLiBDYWxsZXJzIG11c3QgaW52b2tlIHJlbW92ZUNvbXBvbmVudHMoKSB3aGVuIHRoZSBGaXJlc3RvcmVcbiAqIGluc3RhbmNlIGlzIHRlcm1pbmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIHluKHQpIHtcbiAgICBpZiAodC5fdGVybWluYXRlZCkgdGhyb3cgbmV3IFUoUywgXCJUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC5cIik7XG4gICAgaWYgKCFwbi5oYXModCkpIHtcbiAgICAgICAgeShcIkNvbXBvbmVudFByb3ZpZGVyXCIsIFwiSW5pdGlhbGl6aW5nIERhdGFzdG9yZVwiKTtcbiAgICAgICAgY29uc3QgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHQodCwgZmV0Y2guYmluZChudWxsKSk7XG4gICAgICAgIH0oKGUgPSB0Ll9kYXRhYmFzZUlkLCBuID0gdC5hcHAub3B0aW9ucy5hcHBJZCB8fCBcIlwiLCByID0gdC5fcGVyc2lzdGVuY2VLZXksIHMgPSB0Ll9mcmVlemVTZXR0aW5ncygpLCBcbiAgICAgICAgbmV3IEooZSwgbiwgciwgcy5ob3N0LCBzLnNzbCwgcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nLCBzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZywgcy51c2VGZXRjaFN0cmVhbXMpKSksIG8gPSBhbih0Ll9kYXRhYmFzZUlkKSwgdSA9IGZ1bmN0aW9uKHQsIGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbG4odCwgZSwgbiwgcik7XG4gICAgICAgIH0odC5fYXV0aENyZWRlbnRpYWxzLCB0Ll9hcHBDaGVja0NyZWRlbnRpYWxzLCBpLCBvKTtcbiAgICAgICAgcG4uc2V0KHQsIHUpO1xuICAgIH1cbiAgICB2YXIgZSwgbiwgciwgcztcbiAgICAvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAgICByZXR1cm4gcG4uZ2V0KHQpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGNvbXBvbmVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBpbnN0YW5jZS4gTXVzdCBiZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGBGaXJlc3RvcmVgIGluc3RhbmNlIGlzIHRlcm1pbmF0ZWQuXG4gKi9cbi8qKlxuICogQSBjb25jcmV0ZSB0eXBlIGRlc2NyaWJpbmcgYWxsIHRoZSB2YWx1ZXMgdGhhdCBjYW4gYmUgYXBwbGllZCB2aWEgYVxuICogdXNlci1zdXBwbGllZCBgRmlyZXN0b3JlU2V0dGluZ3NgIG9iamVjdC4gVGhpcyBpcyBhIHNlcGFyYXRlIHR5cGUgc28gdGhhdFxuICogZGVmYXVsdHMgY2FuIGJlIHN1cHBsaWVkIGFuZCB0aGUgdmFsdWUgY2FuIGJlIGNoZWNrZWQgZm9yIGVxdWFsaXR5LlxuICovXG5jbGFzcyBnbiB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gdC5ob3N0KSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0LnNzbCkgdGhyb3cgbmV3IFUoUCwgXCJDYW4ndCBwcm92aWRlIHNzbCBvcHRpb24gaWYgaG9zdCBvcHRpb24gaXMgbm90IHNldFwiKTtcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IFwiZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tXCIsIHRoaXMuc3NsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHRoaXMuaG9zdCA9IHQuaG9zdCwgdGhpcy5zc2wgPSBudWxsID09PSAoZSA9IHQuc3NsKSB8fCB2b2lkIDAgPT09IGUgfHwgZTtcbiAgICAgICAgaWYgKHRoaXMuY3JlZGVudGlhbHMgPSB0LmNyZWRlbnRpYWxzLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSAhIXQuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgXG4gICAgICAgIHZvaWQgMCA9PT0gdC5jYWNoZVNpemVCeXRlcykgdGhpcy5jYWNoZVNpemVCeXRlcyA9IDQxOTQzMDQwOyBlbHNlIHtcbiAgICAgICAgICAgIGlmICgtMSAhPT0gdC5jYWNoZVNpemVCeXRlcyAmJiB0LmNhY2hlU2l6ZUJ5dGVzIDwgMTA0ODU3NikgdGhyb3cgbmV3IFUoUCwgXCJjYWNoZVNpemVCeXRlcyBtdXN0IGJlIGF0IGxlYXN0IDEwNDg1NzZcIik7XG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gdC5jYWNoZVNpemVCeXRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgPSAhIXQuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSAhIXQuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBcbiAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPSAhIXQudXNlRmV0Y2hTdHJlYW1zLCBmdW5jdGlvbih0LCBlLCBuLCByKSB7XG4gICAgICAgICAgICBpZiAoITAgPT09IGUgJiYgITAgPT09IHIpIHRocm93IG5ldyBVKFAsIGAke3R9IGFuZCAke259IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLmApO1xuICAgICAgICB9KFwiZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZ1wiLCB0LmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcsIFwiZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nXCIsIHQuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nKTtcbiAgICB9XG4gICAgaXNFcXVhbCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3QgPT09IHQuaG9zdCAmJiB0aGlzLnNzbCA9PT0gdC5zc2wgJiYgdGhpcy5jcmVkZW50aWFscyA9PT0gdC5jcmVkZW50aWFscyAmJiB0aGlzLmNhY2hlU2l6ZUJ5dGVzID09PSB0LmNhY2hlU2l6ZUJ5dGVzICYmIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9PT0gdC5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nICYmIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID09PSB0LmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyAmJiB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPT09IHQuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAmJiB0aGlzLnVzZUZldGNoU3RyZWFtcyA9PT0gdC51c2VGZXRjaFN0cmVhbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgQ2xvdWQgRmlyZXN0b3JlIHNlcnZpY2UgaW50ZXJmYWNlLlxuICpcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKi8gY2xhc3MgX24ge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgcikge1xuICAgICAgICB0aGlzLl9hdXRoQ3JlZGVudGlhbHMgPSB0LCB0aGlzLl9hcHBDaGVja0NyZWRlbnRpYWxzID0gZSwgdGhpcy5fZGF0YWJhc2VJZCA9IG4sIFxuICAgICAgICB0aGlzLl9hcHAgPSByLCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaXQncyBhIEZpcmVzdG9yZSBvciBGaXJlc3RvcmUgTGl0ZSBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZmlyZXN0b3JlLWxpdGVcIiwgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSBcIihsaXRlKVwiLCB0aGlzLl9zZXR0aW5ncyA9IG5ldyBnbih7fSksIFxuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9ICExO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGBGaXJlc3RvcmVgIHNlcnZpY2VcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKi8gICAgZ2V0IGFwcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hcHApIHRocm93IG5ldyBVKFMsIFwiRmlyZXN0b3JlIHdhcyBub3QgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIEZpcmViYXNlIFNESy4gJ2FwcCcgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcDtcbiAgICB9XG4gICAgZ2V0IF9pbml0aWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzRnJvemVuO1xuICAgIH1cbiAgICBnZXQgX3Rlcm1pbmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgIT09IHRoaXMuX3Rlcm1pbmF0ZVRhc2s7XG4gICAgfVxuICAgIF9zZXRTZXR0aW5ncyh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5nc0Zyb3plbikgdGhyb3cgbmV3IFUoUywgXCJGaXJlc3RvcmUgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkIGFuZCBpdHMgc2V0dGluZ3MgY2FuIG5vIGxvbmdlciBiZSBjaGFuZ2VkLiBZb3UgY2FuIG9ubHkgbW9kaWZ5IHNldHRpbmdzIGJlZm9yZSBjYWxsaW5nIGFueSBvdGhlciBtZXRob2RzIG9uIGEgRmlyZXN0b3JlIG9iamVjdC5cIik7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gbmV3IGduKHQpLCB2b2lkIDAgIT09IHQuY3JlZGVudGlhbHMgJiYgKHRoaXMuX2F1dGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICghdCkgcmV0dXJuIG5ldyBRO1xuICAgICAgICAgICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImdhcGlcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5jbGllbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLKGUsIHQuc2Vzc2lvbkluZGV4IHx8IFwiMFwiLCB0LmlhbVRva2VuIHx8IG51bGwsIHQuYXV0aFRva2VuRmFjdG9yeSB8fCBudWxsKTtcblxuICAgICAgICAgICAgICBjYXNlIFwicHJvdmlkZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5jbGllbnQ7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVShQLCBcIm1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlciBmYWlsZWQgZHVlIHRvIGludmFsaWQgY3JlZGVudGlhbCB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KHQuY3JlZGVudGlhbHMpKTtcbiAgICB9XG4gICAgX2dldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XG4gICAgfVxuICAgIF9mcmVlemVTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzRnJvemVuID0gITAsIHRoaXMuX3NldHRpbmdzO1xuICAgIH1cbiAgICBfZGVsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzayB8fCAodGhpcy5fdGVybWluYXRlVGFzayA9IHRoaXMuX3Rlcm1pbmF0ZSgpKSwgdGhpcy5fdGVybWluYXRlVGFzaztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBGaXJlc3RvcmVgIGluc3RhbmNlLiAqLyAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHA6IHRoaXMuX2FwcCxcbiAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHRoaXMuX2RhdGFiYXNlSWQsXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5fc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhbGwgY29tcG9uZW50cyB1c2VkIGJ5IHRoaXMgY2xpZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgbWV0aG9kIHRvIGNsZWFuIHVwIHRoZWlyIG93biBkZXBlbmRlbmNpZXMsIGJ1dCBtdXN0IGFsc28gY2FsbCB0aGlzXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogT25seSBldmVyIGNhbGxlZCBvbmNlLlxuICAgICAqLyAgICBfdGVybWluYXRlKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgY29uc3QgZSA9IHBuLmdldCh0KTtcbiAgICAgICAgICAgIGUgJiYgKHkoXCJDb21wb25lbnRQcm92aWRlclwiLCBcIlJlbW92aW5nIERhdGFzdG9yZVwiKSwgcG4uZGVsZXRlKHQpLCBlLnRlcm1pbmF0ZSgpKTtcbiAgICAgICAgfSh0aGlzKSwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2bih0LCBlLCBuKSB7XG4gICAgbiB8fCAobiA9IFwiKGRlZmF1bHQpXCIpO1xuICAgIGNvbnN0IHIgPSBfZ2V0UHJvdmlkZXIodCwgXCJmaXJlc3RvcmUvbGl0ZVwiKTtcbiAgICBpZiAoci5pc0luaXRpYWxpemVkKG4pKSB0aHJvdyBuZXcgVShTLCBcIkZpcmVzdG9yZSBjYW4gb25seSBiZSBpbml0aWFsaXplZCBvbmNlIHBlciBhcHAuXCIpO1xuICAgIHJldHVybiByLmluaXRpYWxpemUoe1xuICAgICAgICBvcHRpb25zOiBlLFxuICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYm4oZSwgbikge1xuICAgIGNvbnN0IHIgPSBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gZSA6IHQoKSwgcyA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBlIDogbiB8fCBcIihkZWZhdWx0KVwiLCBpID0gX2dldFByb3ZpZGVyKHIsIFwiZmlyZXN0b3JlL2xpdGVcIikuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgaWRlbnRpZmllcjogc1xuICAgIH0pO1xuICAgIGlmICghaS5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgdCA9IGEoXCJmaXJlc3RvcmVcIik7XG4gICAgICAgIHQgJiYgRW4oaSwgLi4udCk7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG4vKipcbiAqIE1vZGlmeSB0aGlzIGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIEZpcmVzdG9yZSBlbXVsYXRvci5cbiAqXG4gKiBOb3RlOiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55XG4gKiBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgdG8gY29uZmlndXJlIHRvIGNvbm5lY3QgdG8gdGhlXG4gKiBlbXVsYXRvci5cbiAqIEBwYXJhbSBob3N0IC0gdGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpLlxuICogQHBhcmFtIHBvcnQgLSB0aGUgZW11bGF0b3IgcG9ydCAoZXg6IDkwMDApLlxuICogQHBhcmFtIG9wdGlvbnMubW9ja1VzZXJUb2tlbiAtIHRoZSBtb2NrIGF1dGggdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmdcbiAqIFNlY3VyaXR5IFJ1bGVzLlxuICovIGZ1bmN0aW9uIEVuKHQsIGUsIG4sIHIgPSB7fSkge1xuICAgIHZhciBzO1xuICAgIGNvbnN0IGkgPSAodCA9IGN0KHQsIF9uKSkuX2dldFNldHRpbmdzKCk7XG4gICAgaWYgKFwiZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tXCIgIT09IGkuaG9zdCAmJiBpLmhvc3QgIT09IGUgJiYgXyhcIkhvc3QgaGFzIGJlZW4gc2V0IGluIGJvdGggc2V0dGluZ3MoKSBhbmQgdXNlRW11bGF0b3IoKSwgZW11bGF0b3IgaG9zdCB3aWxsIGJlIHVzZWRcIiksIFxuICAgIHQuX3NldFNldHRpbmdzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaSksIHtcbiAgICAgICAgaG9zdDogYCR7ZX06JHtufWAsXG4gICAgICAgIHNzbDogITFcbiAgICB9KSksIHIubW9ja1VzZXJUb2tlbikge1xuICAgICAgICBsZXQgZSwgbjtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIubW9ja1VzZXJUb2tlbikgZSA9IHIubW9ja1VzZXJUb2tlbiwgbiA9IGQuTU9DS19VU0VSOyBlbHNlIHtcbiAgICAgICAgICAgIC8vIExldCBjcmVhdGVNb2NrVXNlclRva2VuIHZhbGlkYXRlIGZpcnN0IChjYXRjaGVzIGNvbW1vbiBtaXN0YWtlcyBsaWtlXG4gICAgICAgICAgICAvLyBpbnZhbGlkIGZpZWxkIFwidWlkXCIgYW5kIG1pc3NpbmcgZmllbGQgXCJzdWJcIiAvIFwidXNlcl9pZFwiLilcbiAgICAgICAgICAgIGUgPSBoKHIubW9ja1VzZXJUb2tlbiwgbnVsbCA9PT0gKHMgPSB0Ll9hcHApIHx8IHZvaWQgMCA9PT0gcyA/IHZvaWQgMCA6IHMub3B0aW9ucy5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgaSA9IHIubW9ja1VzZXJUb2tlbi5zdWIgfHwgci5tb2NrVXNlclRva2VuLnVzZXJfaWQ7XG4gICAgICAgICAgICBpZiAoIWkpIHRocm93IG5ldyBVKFAsIFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcbiAgICAgICAgICAgIG4gPSBuZXcgZChpKTtcbiAgICAgICAgfVxuICAgICAgICB0Ll9hdXRoQ3JlZGVudGlhbHMgPSBuZXcgeihuZXcgQihlLCBuKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRlcm1pbmF0ZXMgdGhlIHByb3ZpZGVkIGBGaXJlc3RvcmVgIGluc3RhbmNlLlxuICpcbiAqIEFmdGVyIGNhbGxpbmcgYHRlcm1pbmF0ZSgpYCBvbmx5IHRoZSBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBmdW5jdGlvbnNcbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuIFRlcm1pbmF0aW9uXG4gKiBkb2VzIG5vdCBjYW5jZWwgYW55IHBlbmRpbmcgd3JpdGVzLCBhbmQgYW55IHByb21pc2VzIHRoYXQgYXJlIGF3YWl0aW5nIGFcbiAqIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3aWxsIG5vdCBiZSByZXNvbHZlZC5cbiAqXG4gKiBUbyByZXN0YXJ0IGFmdGVyIHRlcm1pbmF0aW9uLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYEZpcmVzdG9yZWAgd2l0aFxuICoge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9LlxuICpcbiAqIE5vdGU6IFVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgaXMgbm90IHJlcXVpcmVkLiBUaGlzXG4gKiBmdW5jdGlvbiBpcyB1c2VmdWwgb25seSB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIHRoaXMgaW5zdGFuY2UgdG8gcmVsZWFzZSBhbGwgb2ZcbiAqIGl0cyByZXNvdXJjZXMgb3IgaW4gY29tYmluYXRpb24gd2l0aCB7QGxpbmsgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZX0gdG9cbiAqIGVuc3VyZSB0aGF0IGFsbCBsb2NhbCBzdGF0ZSBpcyBkZXN0cm95ZWQgYmV0d2VlbiB0ZXN0IHJ1bnMuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSBgRmlyZXN0b3JlYCBpbnN0YW5jZSB0byB0ZXJtaW5hdGUuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluc3RhbmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxuICogdGVybWluYXRlZC5cbiAqLyBmdW5jdGlvbiBJbih0KSB7XG4gICAgcmV0dXJuIHQgPSBjdCh0LCBfbiksIGUodC5hcHAsIFwiZmlyZXN0b3JlL2xpdGVcIiksIHQuX2RlbGV0ZSgpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhZ2dyZWdhdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYnkgRmlyZXN0b3JlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jbGFzcyBUbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkFnZ3JlZ2F0ZUZpZWxkXCI7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSByZXN1bHRzIG9mIGV4ZWN1dGluZyBhbiBhZ2dyZWdhdGlvbiBxdWVyeS5cbiAqLyBjbGFzcyBBbiB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBlLCBcbiAgICAgICAgLyoqIEEgdHlwZSBzdHJpbmcgdG8gdW5pcXVlbHkgaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuICovXG4gICAgICAgIHRoaXMudHlwZSA9IFwiQWdncmVnYXRlUXVlcnlTbmFwc2hvdFwiLCB0aGlzLnF1ZXJ5ID0gdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXG4gICAgICogcXVlcnkuXG4gICAgICpcbiAgICAgKiBUaGUga2V5cyBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgdGhlXG4gICAgICogYEFnZ3JlZ2F0ZVNwZWNgIG9iamVjdCBzcGVjaWZpZWQgdG8gdGhlIGFnZ3JlZ2F0aW9uIG1ldGhvZCwgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiB3aWxsIGJlIHRoZSBjb3JyZXNwb25kaW5nIGFnZ3JlZ2F0aW9uIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRzIG9mIHRoZSBhZ2dyZWdhdGlvbnMgcGVyZm9ybWVkIG92ZXIgdGhlIHVuZGVybHlpbmdcbiAgICAgKiBxdWVyeS5cbiAgICAgKi8gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb3VudFF1ZXJ5UnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biB0aGUgY291bnQgYWdncmVnYXRpb25cbiAqIHF1ZXJpZXMuXG4gKi8gY2xhc3MgUm4ge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHQsIHRoaXMuZGF0YXN0b3JlID0gZSwgdGhpcy51c2VyRGF0YVdyaXRlciA9IG47XG4gICAgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgcmV0dXJuIG1uKHRoaXMuZGF0YXN0b3JlLCB0aGlzLnF1ZXJ5Ll9xdWVyeSkudGhlbigodCA9PiB7XG4gICAgICAgICAgICBFKHZvaWQgMCAhPT0gdFswXSk7XG4gICAgICAgICAgICBjb25zdCBlID0gT2JqZWN0LmVudHJpZXModFswXSkuZmlsdGVyKCgoW3QsIGVdKSA9PiBcImNvdW50X2FsaWFzXCIgPT09IHQpKS5tYXAoKChbdCwgZV0pID0+IHRoaXMudXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKGUpKSlbMF07XG4gICAgICAgICAgICByZXR1cm4gRShcIm51bWJlclwiID09IHR5cGVvZiBlKSwgUHJvbWlzZS5yZXNvbHZlKG5ldyBBbih0aGlzLnF1ZXJ5LCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgRG9jdW1lbnRSZWZlcmVuY2VgIHJlZmVycyB0byBhIGRvY3VtZW50IGxvY2F0aW9uIGluIGEgRmlyZXN0b3JlIGRhdGFiYXNlXG4gKiBhbmQgY2FuIGJlIHVzZWQgdG8gd3JpdGUsIHJlYWQsIG9yIGxpc3RlbiB0byB0aGUgbG9jYXRpb24uIFRoZSBkb2N1bWVudCBhdFxuICogdGhlIHJlZmVyZW5jZWQgbG9jYXRpb24gbWF5IG9yIG1heSBub3QgZXhpc3QuXG4gKi8gY2xhc3MgUG4ge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IodCwgXG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZSwgbikge1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGUsIHRoaXMuX2tleSA9IG4sIFxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBcImRvY3VtZW50XCIsIHRoaXMuZmlyZXN0b3JlID0gdDtcbiAgICB9XG4gICAgZ2V0IF9wYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkb2N1bWVudCdzIGlkZW50aWZpZXIgd2l0aGluIGl0cyBjb2xsZWN0aW9uLlxuICAgICAqLyAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgZG9jdW1lbnQgKHJlbGF0aXZlXG4gICAgICogdG8gdGhlIHJvb3Qgb2YgdGhlIGRhdGFiYXNlKS5cbiAgICAgKi8gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGJlbG9uZ3MgdG8uXG4gICAgICovICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJG4odGhpcy5maXJlc3RvcmUsIHRoaXMuY29udmVydGVyLCB0aGlzLl9rZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgIH1cbiAgICB3aXRoQ29udmVydGVyKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbih0aGlzLmZpcmVzdG9yZSwgdCwgdGhpcy5fa2V5KTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBgUXVlcnlgIHJlZmVycyB0byBhIHF1ZXJ5IHdoaWNoIHlvdSBjYW4gcmVhZCBvciBsaXN0ZW4gdG8uIFlvdSBjYW4gYWxzb1xuICogY29uc3RydWN0IHJlZmluZWQgYFF1ZXJ5YCBvYmplY3RzIGJ5IGFkZGluZyBmaWx0ZXJzIGFuZCBvcmRlcmluZy5cbiAqLyBjbGFzcyBWbiB7XG4gICAgLy8gVGhpcyBpcyB0aGUgbGl0ZSB2ZXJzaW9uIG9mIHRoZSBRdWVyeSBjbGFzcyBpbiB0aGUgbWFpbiBTREsuXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXG4gICAgY29uc3RydWN0b3IodCwgXG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZSwgbikge1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGUsIHRoaXMuX3F1ZXJ5ID0gbiwgXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXG4gICAgICAgIHRoaXMudHlwZSA9IFwicXVlcnlcIiwgdGhpcy5maXJlc3RvcmUgPSB0O1xuICAgIH1cbiAgICB3aXRoQ29udmVydGVyKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWbih0aGlzLmZpcmVzdG9yZSwgdCwgdGhpcy5fcXVlcnkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGBDb2xsZWN0aW9uUmVmZXJlbmNlYCBvYmplY3QgY2FuIGJlIHVzZWQgZm9yIGFkZGluZyBkb2N1bWVudHMsIGdldHRpbmdcbiAqIGRvY3VtZW50IHJlZmVyZW5jZXMsIGFuZCBxdWVyeWluZyBmb3IgZG9jdW1lbnRzICh1c2luZyB7QGxpbmsgcXVlcnl9KS5cbiAqLyBjbGFzcyAkbiBleHRlbmRzIFZuIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHtcbiAgICAgICAgc3VwZXIodCwgZSwgbmV3IHllKG4pKSwgdGhpcy5fcGF0aCA9IG4sIFxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBcImNvbGxlY3Rpb25cIjtcbiAgICB9XG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uJ3MgaWRlbnRpZmllci4gKi8gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgY29sbGVjdGlvbiAocmVsYXRpdmVcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxuICAgICAqLyAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjb250YWluaW5nIGBEb2N1bWVudFJlZmVyZW5jZWAgaWYgdGhpcyBpcyBhXG4gICAgICogc3ViY29sbGVjdGlvbi4gSWYgdGhpcyBpc24ndCBhIHN1YmNvbGxlY3Rpb24sIHRoZSByZWZlcmVuY2UgaXMgbnVsbC5cbiAgICAgKi8gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX3BhdGgucG9wTGFzdCgpO1xuICAgICAgICByZXR1cm4gdC5pc0VtcHR5KCkgPyBudWxsIDogbmV3IFBuKHRoaXMuZmlyZXN0b3JlLCBcbiAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgcnQodCkpO1xuICAgIH1cbiAgICB3aXRoQ29udmVydGVyKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkbih0aGlzLmZpcmVzdG9yZSwgdCwgdGhpcy5fcGF0aCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBObih0LCBlLCAuLi5uKSB7XG4gICAgaWYgKHQgPSBsKHQpLCBzdChcImNvbGxlY3Rpb25cIiwgXCJwYXRoXCIsIGUpLCB0IGluc3RhbmNlb2YgX24pIHtcbiAgICAgICAgY29uc3QgciA9IHR0LmZyb21TdHJpbmcoZSwgLi4ubik7XG4gICAgICAgIHJldHVybiBvdChyKSwgbmV3ICRuKHQsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgcik7XG4gICAgfVxuICAgIHtcbiAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIFBuIHx8IHQgaW5zdGFuY2VvZiAkbikpIHRocm93IG5ldyBVKFAsIFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZVwiKTtcbiAgICAgICAgY29uc3QgciA9IHQuX3BhdGguY2hpbGQodHQuZnJvbVN0cmluZyhlLCAuLi5uKSk7XG4gICAgICAgIHJldHVybiBvdChyKSwgbmV3ICRuKHQuZmlyZXN0b3JlLCBcbiAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCByKTtcbiAgICB9XG59XG5cbi8vIFRPRE8oZmlyZXN0b3JlbGl0ZSk6IENvbnNpZGVyIHVzaW5nIEVycm9yRmFjdG9yeSAtXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2Jsb2IvMDEzMWUxZi9wYWNrYWdlcy91dGlsL3NyYy9lcnJvcnMudHMjTDEwNlxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBRdWVyeWAgaW5zdGFuY2UgdGhhdCBpbmNsdWRlcyBhbGwgZG9jdW1lbnRzIGluIHRoZVxuICogZGF0YWJhc2UgdGhhdCBhcmUgY29udGFpbmVkIGluIGEgY29sbGVjdGlvbiBvciBzdWJjb2xsZWN0aW9uIHdpdGggdGhlXG4gKiBnaXZlbiBgY29sbGVjdGlvbklkYC5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gQSByZWZlcmVuY2UgdG8gdGhlIHJvb3QgYEZpcmVzdG9yZWAgaW5zdGFuY2UuXG4gKiBAcGFyYW0gY29sbGVjdGlvbklkIC0gSWRlbnRpZmllcyB0aGUgY29sbGVjdGlvbnMgdG8gcXVlcnkgb3Zlci4gRXZlcnlcbiAqIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoaXMgSUQgYXMgdGhlIGxhc3Qgc2VnbWVudCBvZiBpdHMgcGF0aFxuICogd2lsbCBiZSBpbmNsdWRlZC4gQ2Fubm90IGNvbnRhaW4gYSBzbGFzaC5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGBRdWVyeWAuXG4gKi8gZnVuY3Rpb24gRG4odCwgZSkge1xuICAgIGlmICh0ID0gY3QodCwgX24pLCBzdChcImNvbGxlY3Rpb25Hcm91cFwiLCBcImNvbGxlY3Rpb24gaWRcIiwgZSksIGUuaW5kZXhPZihcIi9cIikgPj0gMCkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtlfScgcGFzc2VkIHRvIGZ1bmN0aW9uIGNvbGxlY3Rpb25Hcm91cCgpLiBDb2xsZWN0aW9uIElEcyBtdXN0IG5vdCBjb250YWluICcvJy5gKTtcbiAgICByZXR1cm4gbmV3IFZuKHQsIFxuICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gbmV3IHllKHR0LmVtcHR5UGF0aCgpLCB0KTtcbiAgICB9KGUpKTtcbn1cblxuZnVuY3Rpb24gRm4odCwgZSwgLi4ubikge1xuICAgIGlmICh0ID0gbCh0KSwgXG4gICAgLy8gV2UgYWxsb3cgb21pc3Npb24gb2YgJ3BhdGhTdHJpbmcnIGJ1dCBleHBsaWNpdGx5IHByb2hpYml0IHBhc3NpbmcgaW4gYm90aFxuICAgIC8vICd1bmRlZmluZWQnIGFuZCAnbnVsbCcuXG4gICAgMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAoZSA9IGd0Lk4oKSksIHN0KFwiZG9jXCIsIFwicGF0aFwiLCBlKSwgdCBpbnN0YW5jZW9mIF9uKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0dC5mcm9tU3RyaW5nKGUsIC4uLm4pO1xuICAgICAgICByZXR1cm4gaXQociksIG5ldyBQbih0LCBcbiAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgcnQocikpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBQbiB8fCB0IGluc3RhbmNlb2YgJG4pKSB0aHJvdyBuZXcgVShQLCBcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGNvbGxlY3Rpb24oKSB0byBiZSBhIENvbGxlY3Rpb25SZWZlcmVuY2UsIGEgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmVcIik7XG4gICAgICAgIGNvbnN0IHIgPSB0Ll9wYXRoLmNoaWxkKHR0LmZyb21TdHJpbmcoZSwgLi4ubikpO1xuICAgICAgICByZXR1cm4gaXQociksIG5ldyBQbih0LmZpcmVzdG9yZSwgdCBpbnN0YW5jZW9mICRuID8gdC5jb252ZXJ0ZXIgOiBudWxsLCBuZXcgcnQocikpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHJlZmVyZW5jZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgcmVmZXJlbmNlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXG4gKi8gZnVuY3Rpb24geG4odCwgZSkge1xuICAgIHJldHVybiB0ID0gbCh0KSwgZSA9IGwoZSksICh0IGluc3RhbmNlb2YgUG4gfHwgdCBpbnN0YW5jZW9mICRuKSAmJiAoZSBpbnN0YW5jZW9mIFBuIHx8IGUgaW5zdGFuY2VvZiAkbikgJiYgKHQuZmlyZXN0b3JlID09PSBlLmZpcmVzdG9yZSAmJiB0LnBhdGggPT09IGUucGF0aCAmJiB0LmNvbnZlcnRlciA9PT0gZS5jb252ZXJ0ZXIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcXVlcmllcyBwb2ludCB0byB0aGUgc2FtZSBjb2xsZWN0aW9uIGFuZCBhcHBseVxuICogdGhlIHNhbWUgY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxuICogRmlyZXN0b3JlIGRhdGFiYXNlLlxuICovIGZ1bmN0aW9uIFNuKHQsIGUpIHtcbiAgICByZXR1cm4gdCA9IGwodCksIGUgPSBsKGUpLCB0IGluc3RhbmNlb2YgVm4gJiYgZSBpbnN0YW5jZW9mIFZuICYmICh0LmZpcmVzdG9yZSA9PT0gZS5maXJlc3RvcmUgJiYgVGUodC5fcXVlcnksIGUuX3F1ZXJ5KSAmJiB0LmNvbnZlcnRlciA9PT0gZS5jb252ZXJ0ZXIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiBieXRlcy5cbiAqLyBjbGFzcyBxbiB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuX2J5dGVTdHJpbmcgPSB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIEJhc2U2NCBzdHJpbmcsIGNvbnZlcnRpbmcgaXQgdG9cbiAgICAgKiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiYXNlNjQgLSBUaGUgQmFzZTY0IHN0cmluZyB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcW4oSXQuZnJvbUJhc2U2NFN0cmluZyh0KSk7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVKFAsIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCBkYXRhIGZyb20gQmFzZTY0IHN0cmluZzogXCIgKyB0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIFVpbnQ4QXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgVWludDhBcnJheSB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovICAgIHN0YXRpYyBmcm9tVWludDhBcnJheSh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcW4oSXQuZnJvbVVpbnQ4QXJyYXkodCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGFzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqLyAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9CYXNlNjQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBpbiBhIG5ldyBgVWludDhBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVWludDhBcnJheSBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqLyAgICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ieXRlU3RyaW5nLnRvVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQnl0ZXNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQnl0ZXNgIG9iamVjdC5cbiAgICAgKi8gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIkJ5dGVzKGJhc2U2NDogXCIgKyB0aGlzLnRvQmFzZTY0KCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgQnl0ZXNgIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCeXRlc2Agb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy5pc0VxdWFsKHQuX2J5dGVTdHJpbmcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgRmllbGRQYXRoYCByZWZlcnMgdG8gYSBmaWVsZCBpbiBhIGRvY3VtZW50LiBUaGUgcGF0aCBtYXkgY29uc2lzdCBvZiBhXG4gKiBzaW5nbGUgZmllbGQgbmFtZSAocmVmZXJyaW5nIHRvIGEgdG9wLWxldmVsIGZpZWxkIGluIHRoZSBkb2N1bWVudCksIG9yIGFcbiAqIGxpc3Qgb2YgZmllbGQgbmFtZXMgKHJlZmVycmluZyB0byBhIG5lc3RlZCBmaWVsZCBpbiB0aGUgZG9jdW1lbnQpLlxuICpcbiAqIENyZWF0ZSBhIGBGaWVsZFBhdGhgIGJ5IHByb3ZpZGluZyBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxuICogbmFtZSBpcyBwcm92aWRlZCwgdGhlIHBhdGggd2lsbCBwb2ludCB0byBhIG5lc3RlZCBmaWVsZCBpbiBhIGRvY3VtZW50LlxuICovIGNsYXNzIE9uIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYEZpZWxkUGF0aGAgZnJvbSB0aGUgcHJvdmlkZWQgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcbiAgICAgKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lcyAtIEEgbGlzdCBvZiBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi50KSB7XG4gICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdC5sZW5ndGg7ICsrZSkgaWYgKDAgPT09IHRbZV0ubGVuZ3RoKSB0aHJvdyBuZXcgVShQLCBcIkludmFsaWQgZmllbGQgbmFtZSBhdCBhcmd1bWVudCAkKGkgKyAxKS4gRmllbGQgbmFtZXMgbXVzdCBub3QgYmUgZW1wdHkuXCIpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhdGggPSBuZXcgbnQodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEZpZWxkUGF0aGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqLyAgICBpc0VxdWFsKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUGF0aC5pc0VxdWFsKHQuX2ludGVybmFsUGF0aCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHNlbnRpbmVsIGBGaWVsZFBhdGhgIHRvIHJlZmVyIHRvIHRoZSBJRCBvZiBhIGRvY3VtZW50LlxuICogSXQgY2FuIGJlIHVzZWQgaW4gcXVlcmllcyB0byBzb3J0IG9yIGZpbHRlciBieSB0aGUgZG9jdW1lbnQgSUQuXG4gKi8gZnVuY3Rpb24ga24oKSB7XG4gICAgcmV0dXJuIG5ldyBPbihcIl9fbmFtZV9fXCIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTZW50aW5lbCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIHdyaXRpbmcgZG9jdW1lbnQgZmllbGRzIHdpdGggYHNldCgpYFxuICogb3IgYHVwZGF0ZSgpYC5cbiAqLyBjbGFzcyBDbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIF9tZXRob2ROYW1lIC0gVGhlIHB1YmxpYyBBUEkgZW5kcG9pbnQgdGhhdCByZXR1cm5zIHRoaXMgY2xhc3MuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5fbWV0aG9kTmFtZSA9IHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWMgbG9jYXRpb24gaW4gRmlyZXN0b3JlLiBUaGVcbiAqIGxvY2F0aW9uIGlzIHJlcHJlc2VudGVkIGFzIGxhdGl0dWRlL2xvbmdpdHVkZSBwYWlyLlxuICpcbiAqIExhdGl0dWRlIHZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIG9mIFstOTAsIDkwXS5cbiAqIExvbmdpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTE4MCwgMTgwXS5cbiAqLyBjbGFzcyBMbiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbW11dGFibGUgYEdlb1BvaW50YCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgbGF0aXR1ZGUgYW5kXG4gICAgICogbG9uZ2l0dWRlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gbGF0aXR1ZGUgLSBUaGUgbGF0aXR1ZGUgYXMgbnVtYmVyIGJldHdlZW4gLTkwIGFuZCA5MC5cbiAgICAgKiBAcGFyYW0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBpZiAoIWlzRmluaXRlKHQpIHx8IHQgPCAtOTAgfHwgdCA+IDkwKSB0aHJvdyBuZXcgVShQLCBcIkxhdGl0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtOTAgYW5kIDkwLCBidXQgd2FzOiBcIiArIHQpO1xuICAgICAgICBpZiAoIWlzRmluaXRlKGUpIHx8IGUgPCAtMTgwIHx8IGUgPiAxODApIHRocm93IG5ldyBVKFAsIFwiTG9uZ2l0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAsIGJ1dCB3YXM6IFwiICsgZSk7XG4gICAgICAgIHRoaXMuX2xhdCA9IHQsIHRoaXMuX2xvbmcgPSBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGF0aXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxuICAgICAqLyAgICBnZXQgbGF0aXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsb25naXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxuICAgICAqLyAgICBnZXQgbG9uZ2l0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBHZW9Qb2ludGAgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgR2VvUG9pbnRgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ID09PSB0Ll9sYXQgJiYgdGhpcy5fbG9uZyA9PT0gdC5fbG9uZztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEdlb1BvaW50LiAqLyAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXRpdHVkZTogdGhpcy5fbGF0LFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiB0aGlzLl9sb25nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdHVhbGx5IHByaXZhdGUgdG8gSlMgY29uc3VtZXJzIG9mIG91ciBBUEksIHNvIHRoaXMgZnVuY3Rpb24gaXMgcHJlZml4ZWRcbiAgICAgKiB3aXRoIGFuIHVuZGVyc2NvcmUuXG4gICAgICovICAgIF9jb21wYXJlVG8odCkge1xuICAgICAgICByZXR1cm4gX3QodGhpcy5fbGF0LCB0Ll9sYXQpIHx8IF90KHRoaXMuX2xvbmcsIHQuX2xvbmcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY29uc3QgTW4gPSAvXl9fLipfXyQvO1xuXG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGRvY3VtZW50IGRhdGEgKGUuZy4gZm9yIGEgc2V0RGF0YSBjYWxsKS4gKi8gY2xhc3MgVW4ge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdCwgdGhpcy5maWVsZE1hc2sgPSBlLCB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IG47XG4gICAgfVxuICAgIHRvTXV0YXRpb24odCwgZSkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdGhpcy5maWVsZE1hc2sgPyBuZXcgcWUodCwgdGhpcy5kYXRhLCB0aGlzLmZpZWxkTWFzaywgZSwgdGhpcy5maWVsZFRyYW5zZm9ybXMpIDogbmV3IFNlKHQsIHRoaXMuZGF0YSwgZSwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xuICAgIH1cbn1cblxuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBcInVwZGF0ZVwiIGRhdGEgKGkuZS4gZm9yIGFuIHVwZGF0ZURhdGEgY2FsbCkuICovIGNsYXNzIGpuIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBcbiAgICAvLyBUaGUgZmllbGRNYXNrIGRvZXMgbm90IGluY2x1ZGUgZG9jdW1lbnQgdHJhbnNmb3Jtcy5cbiAgICBlLCBuKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHQsIHRoaXMuZmllbGRNYXNrID0gZSwgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBuO1xuICAgIH1cbiAgICB0b011dGF0aW9uKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBxZSh0LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBlLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBCbih0KSB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIDAgLyogVXNlckRhdGFTb3VyY2UuU2V0ICovIDpcbiAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgY2FzZSAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovIDpcbiAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgY2FzZSAxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLyA6XG4gICAgICAgIHJldHVybiAhMDtcblxuICAgICAgY2FzZSAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovIDpcbiAgICAgIGNhc2UgNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovIDpcbiAgICAgICAgcmV0dXJuICExO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBiKCk7XG4gICAgfVxufVxuXG4vKiogQSBcImNvbnRleHRcIiBvYmplY3QgcGFzc2VkIGFyb3VuZCB3aGlsZSBwYXJzaW5nIHVzZXIgZGF0YS4gKi8gY2xhc3MgUW4ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgUGFyc2VDb250ZXh0IHdpdGggdGhlIGdpdmVuIHNvdXJjZSBhbmQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyAtIFRoZSBzZXR0aW5ncyBmb3IgdGhlIHBhcnNlci5cbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSBJRCBvZiB0aGUgRmlyZXN0b3JlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBWYWx1ZSBwcm90by5cbiAgICAgKiBAcGFyYW0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAtIFdoZXRoZXIgdG8gaWdub3JlIHVuZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICogcmF0aGVyIHRoYW4gdGhyb3cuXG4gICAgICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIEEgbXV0YWJsZSBsaXN0IG9mIGZpZWxkIHRyYW5zZm9ybXMgZW5jb3VudGVyZWRcbiAgICAgKiB3aGlsZSBwYXJzaW5nIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBmaWVsZE1hc2sgLSBBIG11dGFibGUgbGlzdCBvZiBmaWVsZCBwYXRocyBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nXG4gICAgICogdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKiBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdywgc28gcGF0aCBjYW4gYmVcbiAgICAgKiBudWxsIHRvIGluZGljYXRlIHRoZSBjb250ZXh0IHJlcHJlc2VudHMgYW55IGxvY2F0aW9uIHdpdGhpbiBhbiBhcnJheSAoaW5cbiAgICAgKiB3aGljaCBjYXNlIGNlcnRhaW4gZmVhdHVyZXMgd2lsbCBub3Qgd29yayBhbmQgZXJyb3JzIHdpbGwgYmUgc29tZXdoYXRcbiAgICAgKiBjb21wcm9taXNlZCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgciwgcywgaSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gdCwgdGhpcy5kYXRhYmFzZUlkID0gZSwgdGhpcy5DID0gbiwgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gciwgXG4gICAgICAgIC8vIE1pbm9yIGhhY2s6IElmIGZpZWxkVHJhbnNmb3JtcyBpcyB1bmRlZmluZWQsIHdlIGFzc3VtZSB0aGlzIGlzIGFuXG4gICAgICAgIC8vIGV4dGVybmFsIGNhbGwgYW5kIHdlIG5lZWQgdG8gdmFsaWRhdGUgdGhlIGVudGlyZSBwYXRoLlxuICAgICAgICB2b2lkIDAgPT09IHMgJiYgdGhpcy5ldCgpLCB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IHMgfHwgW10sIHRoaXMuZmllbGRNYXNrID0gaSB8fCBbXTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnBhdGg7XG4gICAgfVxuICAgIGdldCBudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MubnQ7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGNvbnRleHQgd2l0aCB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIG92ZXJ3cml0dGVuLiAqLyAgICBydCh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNldHRpbmdzKSwgdCksIHRoaXMuZGF0YWJhc2VJZCwgdGhpcy5DLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIHRoaXMuZmllbGRUcmFuc2Zvcm1zLCB0aGlzLmZpZWxkTWFzayk7XG4gICAgfVxuICAgIHN0KHQpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGNvbnN0IG4gPSBudWxsID09PSAoZSA9IHRoaXMucGF0aCkgfHwgdm9pZCAwID09PSBlID8gdm9pZCAwIDogZS5jaGlsZCh0KSwgciA9IHRoaXMucnQoe1xuICAgICAgICAgICAgcGF0aDogbixcbiAgICAgICAgICAgIGl0OiAhMVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHIub3QodCksIHI7XG4gICAgfVxuICAgIHV0KHQpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGNvbnN0IG4gPSBudWxsID09PSAoZSA9IHRoaXMucGF0aCkgfHwgdm9pZCAwID09PSBlID8gdm9pZCAwIDogZS5jaGlsZCh0KSwgciA9IHRoaXMucnQoe1xuICAgICAgICAgICAgcGF0aDogbixcbiAgICAgICAgICAgIGl0OiAhMVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHIuZXQoKSwgcjtcbiAgICB9XG4gICAgY3QodCkge1xuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdzsgc28gbWFrZSBwYXRoXG4gICAgICAgIC8vIHVuZGVmaW5lZC5cbiAgICAgICAgcmV0dXJuIHRoaXMucnQoe1xuICAgICAgICAgICAgcGF0aDogdm9pZCAwLFxuICAgICAgICAgICAgaXQ6ICEwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdCh0KSB7XG4gICAgICAgIHJldHVybiBocih0LCB0aGlzLnNldHRpbmdzLm1ldGhvZE5hbWUsIHRoaXMuc2V0dGluZ3MuaHQgfHwgITEsIHRoaXMucGF0aCwgdGhpcy5zZXR0aW5ncy5sdCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zICd0cnVlJyBpZiAnZmllbGRQYXRoJyB3YXMgdHJhdmVyc2VkIHdoZW4gY3JlYXRpbmcgdGhpcyBjb250ZXh0LiAqLyAgICBjb250YWlucyh0KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgIT09IHRoaXMuZmllbGRNYXNrLmZpbmQoKGUgPT4gdC5pc1ByZWZpeE9mKGUpKSkgfHwgdm9pZCAwICE9PSB0aGlzLmZpZWxkVHJhbnNmb3Jtcy5maW5kKChlID0+IHQuaXNQcmVmaXhPZihlLmZpZWxkKSkpO1xuICAgIH1cbiAgICBldCgpIHtcbiAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogUmVtb3ZlIG51bGwgY2hlY2sgb25jZSB3ZSBoYXZlIHByb3BlciBwYXRocyBmb3IgZmllbGRzXG4gICAgICAgIC8vIHdpdGhpbiBhcnJheXMuXG4gICAgICAgIGlmICh0aGlzLnBhdGgpIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5wYXRoLmxlbmd0aDsgdCsrKSB0aGlzLm90KHRoaXMucGF0aC5nZXQodCkpO1xuICAgIH1cbiAgICBvdCh0KSB7XG4gICAgICAgIGlmICgwID09PSB0Lmxlbmd0aCkgdGhyb3cgdGhpcy5hdChcIkRvY3VtZW50IGZpZWxkcyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgaWYgKEJuKHRoaXMubnQpICYmIE1uLnRlc3QodCkpIHRocm93IHRoaXMuYXQoJ0RvY3VtZW50IGZpZWxkcyBjYW5ub3QgYmVnaW4gYW5kIGVuZCB3aXRoIFwiX19cIicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHBhcnNpbmcgcmF3IHVzZXIgaW5wdXQgKHByb3ZpZGVkIHZpYSB0aGUgQVBJKSBpbnRvIGludGVybmFsIG1vZGVsXG4gKiBjbGFzc2VzLlxuICovIGNsYXNzIHpuIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBuKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IHQsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9IGUsIHRoaXMuQyA9IG4gfHwgYW4odCk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRvcC1sZXZlbCBwYXJzZSBjb250ZXh0LiAqLyAgICBmdCh0LCBlLCBuLCByID0gITEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRbih7XG4gICAgICAgICAgICBudDogdCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IGUsXG4gICAgICAgICAgICBsdDogbixcbiAgICAgICAgICAgIHBhdGg6IG50LmVtcHR5UGF0aCgpLFxuICAgICAgICAgICAgaXQ6ICExLFxuICAgICAgICAgICAgaHQ6IHJcbiAgICAgICAgfSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLkMsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBXbih0KSB7XG4gICAgY29uc3QgZSA9IHQuX2ZyZWV6ZVNldHRpbmdzKCksIG4gPSBhbih0Ll9kYXRhYmFzZUlkKTtcbiAgICByZXR1cm4gbmV3IHpuKHQuX2RhdGFiYXNlSWQsICEhZS5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBuKTtcbn1cblxuLyoqIFBhcnNlIGRvY3VtZW50IGRhdGEgZnJvbSBhIHNldCgpIGNhbGwuICovIGZ1bmN0aW9uIEduKHQsIGUsIG4sIHIsIHMsIGkgPSB7fSkge1xuICAgIGNvbnN0IG8gPSB0LmZ0KGkubWVyZ2UgfHwgaS5tZXJnZUZpZWxkcyA/IDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi8gOiAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLyAsIGUsIG4sIHMpO1xuICAgIG9yKFwiRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczpcIiwgbywgcik7XG4gICAgY29uc3QgdSA9IHNyKHIsIG8pO1xuICAgIGxldCBjLCBhO1xuICAgIGlmIChpLm1lcmdlKSBjID0gbmV3IGZlKG8uZmllbGRNYXNrKSwgYSA9IG8uZmllbGRUcmFuc2Zvcm1zOyBlbHNlIGlmIChpLm1lcmdlRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByIG9mIGkubWVyZ2VGaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB1cihlLCByLCBuKTtcbiAgICAgICAgICAgIGlmICghby5jb250YWlucyhzKSkgdGhyb3cgbmV3IFUoUCwgYEZpZWxkICcke3N9JyBpcyBzcGVjaWZpZWQgaW4geW91ciBmaWVsZCBtYXNrIGJ1dCBtaXNzaW5nIGZyb20geW91ciBpbnB1dCBkYXRhLmApO1xuICAgICAgICAgICAgbHIodCwgcykgfHwgdC5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBuZXcgZmUodCksIGEgPSBvLmZpZWxkVHJhbnNmb3Jtcy5maWx0ZXIoKHQgPT4gYy5jb3ZlcnModC5maWVsZCkpKTtcbiAgICB9IGVsc2UgYyA9IG51bGwsIGEgPSBvLmZpZWxkVHJhbnNmb3JtcztcbiAgICByZXR1cm4gbmV3IFVuKG5ldyBkZSh1KSwgYywgYSk7XG59XG5cbmNsYXNzIEtuIGV4dGVuZHMgQ24ge1xuICAgIF90b0ZpZWxkVHJhbnNmb3JtKHQpIHtcbiAgICAgICAgaWYgKDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi8gIT09IHQubnQpIHRocm93IDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovID09PSB0Lm50ID8gdC5hdChgJHt0aGlzLl9tZXRob2ROYW1lfSgpIGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgdXBkYXRlIGRhdGFgKSA6IHQuYXQoYCR7dGhpcy5fbWV0aG9kTmFtZX0oKSBjYW5ub3QgYmUgdXNlZCB3aXRoIHNldCgpIHVubGVzcyB5b3UgcGFzcyB7bWVyZ2U6dHJ1ZX1gKTtcbiAgICAgICAgLy8gTm8gdHJhbnNmb3JtIHRvIGFkZCBmb3IgYSBkZWxldGUsIGJ1dCB3ZSBuZWVkIHRvIGFkZCBpdCB0byBvdXJcbiAgICAgICAgLy8gZmllbGRNYXNrIHNvIGl0IGdldHMgZGVsZXRlZC5cbiAgICAgICAgcmV0dXJuIHQuZmllbGRNYXNrLnB1c2godC5wYXRoKSwgbnVsbDtcbiAgICB9XG4gICAgaXNFcXVhbCh0KSB7XG4gICAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgS247XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjaGlsZCBjb250ZXh0IGZvciBwYXJzaW5nIFNlcmlhbGl6YWJsZUZpZWxkVmFsdWVzLlxuICpcbiAqIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gY2FsbGluZyBgUGFyc2VDb250ZXh0LmNvbnRleHRXaXRoYCBiZWNhdXNlIGl0IGtlZXBzXG4gKiB0aGUgZmllbGRUcmFuc2Zvcm1zIGFuZCBmaWVsZE1hc2sgc2VwYXJhdGUuXG4gKlxuICogVGhlIGNyZWF0ZWQgY29udGV4dCBoYXMgaXRzIGBkYXRhU291cmNlYCBzZXQgdG8gYFVzZXJEYXRhU291cmNlLkFyZ3VtZW50YC5cbiAqIEFsdGhvdWdoIHRoZXNlIHZhbHVlcyBhcmUgdXNlZCB3aXRoIHdyaXRlcywgYW55IGVsZW1lbnRzIGluIHRoZXNlIEZpZWxkVmFsdWVzXG4gKiBhcmUgbm90IGNvbnNpZGVyZWQgd3JpdGVzIHNpbmNlIHRoZXkgY2Fubm90IGNvbnRhaW4gYW55IEZpZWxkVmFsdWUgc2VudGluZWxzLFxuICogZXRjLlxuICpcbiAqIEBwYXJhbSBmaWVsZFZhbHVlIC0gVGhlIHNlbnRpbmVsIEZpZWxkVmFsdWUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIGNoaWxkXG4gKiAgICAgY29udGV4dC5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIHBhcmVudCBjb250ZXh0LlxuICogQHBhcmFtIGFycmF5RWxlbWVudCAtIFdoZXRoZXIgb3Igbm90IHRoZSBGaWVsZFZhbHVlIGhhcyBhbiBhcnJheS5cbiAqLyBmdW5jdGlvbiBZbih0LCBlLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBRbih7XG4gICAgICAgIG50OiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovICxcbiAgICAgICAgbHQ6IGUuc2V0dGluZ3MubHQsXG4gICAgICAgIG1ldGhvZE5hbWU6IHQuX21ldGhvZE5hbWUsXG4gICAgICAgIGl0OiBuXG4gICAgfSwgZS5kYXRhYmFzZUlkLCBlLkMsIGUuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XG59XG5cbmNsYXNzIEhuIGV4dGVuZHMgQ24ge1xuICAgIF90b0ZpZWxkVHJhbnNmb3JtKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZSh0LnBhdGgsIG5ldyBQZSk7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIEhuO1xuICAgIH1cbn1cblxuY2xhc3MgSm4gZXh0ZW5kcyBDbiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcih0KSwgdGhpcy5kdCA9IGU7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IFluKHRoaXMsIHQsIFxuICAgICAgICAvKmFycmF5PSovICEwKSwgbiA9IHRoaXMuZHQubWFwKCh0ID0+IHJyKHQsIGUpKSksIHIgPSBuZXcgVmUobik7XG4gICAgICAgIHJldHVybiBuZXcgRGUodC5wYXRoLCByKTtcbiAgICB9XG4gICAgaXNFcXVhbCh0KSB7XG4gICAgICAgIC8vIFRPRE8obXJzY2htaWR0KTogSW1wbGVtZW50IGlzRXF1YWxzXG4gICAgICAgIHJldHVybiB0aGlzID09PSB0O1xuICAgIH1cbn1cblxuY2xhc3MgWG4gZXh0ZW5kcyBDbiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcih0KSwgdGhpcy5kdCA9IGU7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IFluKHRoaXMsIHQsIFxuICAgICAgICAvKmFycmF5PSovICEwKSwgbiA9IHRoaXMuZHQubWFwKCh0ID0+IHJyKHQsIGUpKSksIHIgPSBuZXcgJGUobik7XG4gICAgICAgIHJldHVybiBuZXcgRGUodC5wYXRoLCByKTtcbiAgICB9XG4gICAgaXNFcXVhbCh0KSB7XG4gICAgICAgIC8vIFRPRE8obXJzY2htaWR0KTogSW1wbGVtZW50IGlzRXF1YWxzXG4gICAgICAgIHJldHVybiB0aGlzID09PSB0O1xuICAgIH1cbn1cblxuY2xhc3MgWm4gZXh0ZW5kcyBDbiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgICBzdXBlcih0KSwgdGhpcy53dCA9IGU7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBOZSh0LkMsIEFlKHQuQywgdGhpcy53dCkpO1xuICAgICAgICByZXR1cm4gbmV3IERlKHQucGF0aCwgZSk7XG4gICAgfVxuICAgIGlzRXF1YWwodCkge1xuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IEltcGxlbWVudCBpc0VxdWFsc1xuICAgICAgICByZXR1cm4gdGhpcyA9PT0gdDtcbiAgICB9XG59XG5cbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGFuIHVwZGF0ZSgpIGNhbGwuICovIGZ1bmN0aW9uIHRyKHQsIGUsIG4sIHIpIHtcbiAgICBjb25zdCBzID0gdC5mdCgxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLyAsIGUsIG4pO1xuICAgIG9yKFwiRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczpcIiwgcywgcik7XG4gICAgY29uc3QgaSA9IFtdLCBvID0gZGUuZW1wdHkoKTtcbiAgICBFdChyLCAoKHQsIHIpID0+IHtcbiAgICAgICAgY29uc3QgdSA9IGFyKGUsIHQsIG4pO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgciA9IGwocik7XG4gICAgICAgIGNvbnN0IGMgPSBzLnV0KHUpO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIEtuKSBcbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBmaWVsZCBtYXNrLCBidXQgZG9uJ3QgYWRkIGFueXRoaW5nIHRvIHVwZGF0ZURhdGEuXG4gICAgICAgIGkucHVzaCh1KTsgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gcnIociwgYyk7XG4gICAgICAgICAgICBudWxsICE9IHQgJiYgKGkucHVzaCh1KSwgby5zZXQodSwgdCkpO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHUgPSBuZXcgZmUoaSk7XG4gICAgcmV0dXJuIG5ldyBqbihvLCB1LCBzLmZpZWxkVHJhbnNmb3Jtcyk7XG59XG5cbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGEgbGlzdCBvZiBmaWVsZC92YWx1ZSBhcmd1bWVudHMuICovIGZ1bmN0aW9uIGVyKHQsIGUsIG4sIHIsIHMsIGkpIHtcbiAgICBjb25zdCBvID0gdC5mdCgxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLyAsIGUsIG4pLCB1ID0gWyB1cihlLCByLCBuKSBdLCBjID0gWyBzIF07XG4gICAgaWYgKGkubGVuZ3RoICUgMiAhPSAwKSB0aHJvdyBuZXcgVShQLCBgRnVuY3Rpb24gJHtlfSgpIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGF0IGFsdGVybmF0ZSBiZXR3ZWVuIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXMuYCk7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCBpLmxlbmd0aDsgdCArPSAyKSB1LnB1c2godXIoZSwgaVt0XSkpLCBjLnB1c2goaVt0ICsgMV0pO1xuICAgIGNvbnN0IGEgPSBbXSwgaCA9IGRlLmVtcHR5KCk7XG4gICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIHRvIHBpY2sgdGhlIGxhc3QgdmFsdWUgZm9yIGEgZmllbGQgaWYgdGhlXG4gICAgLy8gdXNlciBzcGVjaWZpZWQgdGhlIGZpZWxkIG11bHRpcGxlIHRpbWVzLlxuICAgIGZvciAobGV0IHQgPSB1Lmxlbmd0aCAtIDE7IHQgPj0gMDsgLS10KSBpZiAoIWxyKGEsIHVbdF0pKSB7XG4gICAgICAgIGNvbnN0IGUgPSB1W3RdO1xuICAgICAgICBsZXQgbiA9IGNbdF07XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgICAgICBuID0gbChuKTtcbiAgICAgICAgY29uc3QgciA9IG8udXQoZSk7XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgS24pIFxuICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cbiAgICAgICAgYS5wdXNoKGUpOyBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBycihuLCByKTtcbiAgICAgICAgICAgIG51bGwgIT0gdCAmJiAoYS5wdXNoKGUpLCBoLnNldChlLCB0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZiA9IG5ldyBmZShhKTtcbiAgICByZXR1cm4gbmV3IGpuKGgsIGYsIG8uZmllbGRUcmFuc2Zvcm1zKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIFwicXVlcnkgdmFsdWVcIiAoZS5nLiB2YWx1ZSBpbiBhIHdoZXJlIGZpbHRlciBvciBhIHZhbHVlIGluIGEgY3Vyc29yXG4gKiBib3VuZCkuXG4gKlxuICogQHBhcmFtIGFsbG93QXJyYXlzIC0gV2hldGhlciB0aGUgcXVlcnkgdmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBtYXkgZGlyZWN0bHlcbiAqIGNvbnRhaW4gYWRkaXRpb25hbCBhcnJheXMgKGUuZy4gdGhlIG9wZXJhbmQgb2YgYW4gYGluYCBxdWVyeSkuXG4gKi8gZnVuY3Rpb24gbnIodCwgZSwgbiwgciA9ICExKSB7XG4gICAgcmV0dXJuIHJyKG4sIHQuZnQociA/IDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLyA6IDMgLyogVXNlckRhdGFTb3VyY2UuQXJndW1lbnQgKi8gLCBlKSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHVzZXIgZGF0YSB0byBQcm90b2J1ZiBWYWx1ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gRGF0YSB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gY29udGV4dCAtIEEgY29udGV4dCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHBhdGggYmVpbmcgcGFyc2VkLFxuICogdGhlIHNvdXJjZSBvZiB0aGUgZGF0YSBiZWluZyBwYXJzZWQsIGV0Yy5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHZhbHVlIHdhcyBhIEZpZWxkVmFsdWUgc2VudGluZWxcbiAqIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIHBhcnNlZCBkYXRhLlxuICovIGZ1bmN0aW9uIHJyKHQsIGUpIHtcbiAgICBpZiAoaXIoXG4gICAgLy8gVW53cmFwIHRoZSBBUEkgdHlwZSBmcm9tIHRoZSBDb21wYXQgU0RLLiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBBUEkgdHlwZVxuICAgIC8vIGZyb20gZmlyZXN0b3JlLWV4cC5cbiAgICB0ID0gbCh0KSkpIHJldHVybiBvcihcIlVuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOlwiLCBlLCB0KSwgc3IodCwgZSk7XG4gICAgaWYgKHQgaW5zdGFuY2VvZiBDbikgXG4gICAgLy8gRmllbGRWYWx1ZXMgdXN1YWxseSBwYXJzZSBpbnRvIHRyYW5zZm9ybXMgKGV4Y2VwdCBkZWxldGVGaWVsZCgpKVxuICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSB0aGlzIGZpZWxkIGluIG91ciBwYXJzZWQgZGF0YVxuICAgIC8vIChhcyBkb2luZyBzbyB3aWxsIG92ZXJ3cml0ZSB0aGUgZmllbGQgZGlyZWN0bHkgcHJpb3IgdG8gdGhlIHRyYW5zZm9ybVxuICAgIC8vIHRyeWluZyB0byB0cmFuc2Zvcm0gaXQpLiBTbyB3ZSBkb24ndCBhZGQgdGhpcyBsb2NhdGlvbiB0b1xuICAgIC8vIGNvbnRleHQuZmllbGRNYXNrIGFuZCB3ZSByZXR1cm4gbnVsbCBhcyBvdXIgcGFyc2luZyByZXN1bHQuXG4gICAgLyoqXG4gKiBcIlBhcnNlc1wiIHRoZSBwcm92aWRlZCBGaWVsZFZhbHVlSW1wbCwgYWRkaW5nIGFueSBuZWNlc3NhcnkgdHJhbnNmb3JtcyB0b1xuICogY29udGV4dC5maWVsZFRyYW5zZm9ybXMuXG4gKi9cbiAgICByZXR1cm4gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAvLyBTZW50aW5lbHMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggd3JpdGVzLCBhbmQgbm90IHdpdGhpbiBhcnJheXMuXG4gICAgICAgIGlmICghQm4oZS5udCkpIHRocm93IGUuYXQoYCR7dC5fbWV0aG9kTmFtZX0oKSBjYW4gb25seSBiZSB1c2VkIHdpdGggdXBkYXRlKCkgYW5kIHNldCgpYCk7XG4gICAgICAgIGlmICghZS5wYXRoKSB0aHJvdyBlLmF0KGAke3QuX21ldGhvZE5hbWV9KCkgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW5zaWRlIGFycmF5c2ApO1xuICAgICAgICBjb25zdCBuID0gdC5fdG9GaWVsZFRyYW5zZm9ybShlKTtcbiAgICAgICAgbiAmJiBlLmZpZWxkVHJhbnNmb3Jtcy5wdXNoKG4pO1xuICAgIH1cbiAgICAvKipcbiAqIEhlbHBlciB0byBwYXJzZSBhIHNjYWxhciB2YWx1ZSAoaS5lLiBub3QgYW4gT2JqZWN0LCBBcnJheSwgb3IgRmllbGRWYWx1ZSlcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlXG4gKi8gKHQsIGUpLCBudWxsO1xuICAgIGlmICh2b2lkIDAgPT09IHQgJiYgZS5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKSBcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgdW5kZWZpbmVkIGl0IGNhbiBuZXZlciBwYXJ0aWNpcGF0ZSBpbiB0aGUgZmllbGRNYXNrLCBzb1xuICAgIC8vIGRvbid0IGhhbmRsZSB0aGlzIGJlbG93LiBJZiBgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllc2AgaXMgZmFsc2UsXG4gICAgLy8gYHBhcnNlU2NhbGFyVmFsdWVgIHdpbGwgcmVqZWN0IGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoXG4gICAgLy8gSWYgY29udGV4dC5wYXRoIGlzIG51bGwgd2UgYXJlIGluc2lkZSBhbiBhcnJheSBhbmQgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIGZpZWxkIG1hc2sgcGF0aHMgbW9yZSBncmFudWxhciB0aGFuIHRoZSB0b3AtbGV2ZWwgYXJyYXkuXG4gICAgZS5wYXRoICYmIGUuZmllbGRNYXNrLnB1c2goZS5wYXRoKSwgdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IEluY2x1ZGUgdGhlIHBhdGggY29udGFpbmluZyB0aGUgYXJyYXkgaW4gdGhlIGVycm9yXG4gICAgICAgIC8vIG1lc3NhZ2UuXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIElOIHF1ZXJpZXMsIHRoZSBwYXJzZWQgZGF0YSBpcyBhbiBhcnJheSAocmVwcmVzZW50aW5nXG4gICAgICAgIC8vIHRoZSBzZXQgb2YgdmFsdWVzIHRvIGJlIGluY2x1ZGVkIGZvciB0aGUgSU4gcXVlcnkpIHRoYXQgbWF5IGRpcmVjdGx5XG4gICAgICAgIC8vIGNvbnRhaW4gYWRkaXRpb25hbCBhcnJheXMgKGVhY2ggcmVwcmVzZW50aW5nIGFuIGluZGl2aWR1YWwgZmllbGRcbiAgICAgICAgLy8gdmFsdWUpLCBzbyB3ZSBkaXNhYmxlIHRoaXMgdmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGUuc2V0dGluZ3MuaXQgJiYgNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovICE9PSBlLm50KSB0aHJvdyBlLmF0KFwiTmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBbXTtcbiAgICAgICAgICAgIGxldCByID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHQgPSBycihzLCBlLmN0KHIpKTtcbiAgICAgICAgICAgICAgICBudWxsID09IHQgJiYgKFxuICAgICAgICAgICAgICAgIC8vIEp1c3QgaW5jbHVkZSBudWxscyBpbiB0aGUgYXJyYXkgZm9yIGZpZWxkcyBiZWluZyByZXBsYWNlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbC5cbiAgICAgICAgICAgICAgICB0ID0ge1xuICAgICAgICAgICAgICAgICAgICBudWxsVmFsdWU6IFwiTlVMTF9WQUxVRVwiXG4gICAgICAgICAgICAgICAgfSksIG4ucHVzaCh0KSwgcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhcnJheVZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0odCwgZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIGlmIChudWxsID09PSAodCA9IGwodCkpKSByZXR1cm4ge1xuICAgICAgICAgICAgbnVsbFZhbHVlOiBcIk5VTExfVkFMVUVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgdCkgcmV0dXJuIEFlKGUuQywgdCk7XG4gICAgICAgIGlmIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvb2xlYW5WYWx1ZTogdFxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiB0XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IFZ0LmZyb21EYXRlKHQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZTogamUoZS5DLCBuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFZ0KSB7XG4gICAgICAgICAgICAvLyBGaXJlc3RvcmUgYmFja2VuZCB0cnVuY2F0ZXMgcHJlY2lzaW9uIGRvd24gdG8gbWljcm9zZWNvbmRzLiBUbyBlbnN1cmVcbiAgICAgICAgICAgIC8vIG9mZmxpbmUgbW9kZSB3b3JrcyB0aGUgc2FtZSB3aXRoIHJlZ2FyZHMgdG8gdHJ1bmNhdGlvbiwgcGVyZm9ybSB0aGVcbiAgICAgICAgICAgIC8vIHRydW5jYXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgYmFja2VuZCB0byBkbyB0aGF0LlxuICAgICAgICAgICAgY29uc3QgbiA9IG5ldyBWdCh0LnNlY29uZHMsIDFlMyAqIE1hdGguZmxvb3IodC5uYW5vc2Vjb25kcyAvIDFlMykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZTogamUoZS5DLCBuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIExuKSByZXR1cm4ge1xuICAgICAgICAgICAgZ2VvUG9pbnRWYWx1ZToge1xuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiB0LmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogdC5sb25naXR1ZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBxbikgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzVmFsdWU6IEJlKGUuQywgdC5fYnl0ZVN0cmluZylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBQbikge1xuICAgICAgICAgICAgY29uc3QgbiA9IGUuZGF0YWJhc2VJZCwgciA9IHQuZmlyZXN0b3JlLl9kYXRhYmFzZUlkO1xuICAgICAgICAgICAgaWYgKCFyLmlzRXF1YWwobikpIHRocm93IGUuYXQoYERvY3VtZW50IHJlZmVyZW5jZSBpcyBmb3IgZGF0YWJhc2UgJHtyLnByb2plY3RJZH0vJHtyLmRhdGFiYXNlfSBidXQgc2hvdWxkIGJlIGZvciBkYXRhYmFzZSAke24ucHJvamVjdElkfS8ke24uZGF0YWJhc2V9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZVZhbHVlOiBXZSh0LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCB8fCBlLmRhdGFiYXNlSWQsIHQuX2tleS5wYXRoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlLmF0KGBVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTogJHt1dCh0KX1gKTtcbiAgICB9XG4gICAgLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgbG9va3MgbGlrZSBhIEpTT04gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICogaW50byBhIHN0cnVjdC4gTm9ybWFsIGNsYXNzL3Byb3RvdHlwZSBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlXG4gKiBKU09OIG9iamVjdHMgc2luY2UgdGhleSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgc3RydWN0IHZhbHVlLiBBcnJheXMsIERhdGVzLFxuICogR2VvUG9pbnRzLCBldGMuIGFyZSBub3QgY29uc2lkZXJlZCB0byBsb29rIGxpa2UgSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgbWFwXG4gKiB0byBzcGVjaWZpYyBGaWVsZFZhbHVlIHR5cGVzIG90aGVyIHRoYW4gT2JqZWN0VmFsdWUuXG4gKi8gKHQsIGUpO1xufVxuXG5mdW5jdGlvbiBzcih0LCBlKSB7XG4gICAgY29uc3QgbiA9IHt9O1xuICAgIHJldHVybiAhZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKGNvbnN0IGUgaW4gdCkgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBlKSkgcmV0dXJuICExO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIC8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4gICAgLyoqIENvbnZlcnRzIGEgQmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYmluYXJ5IHN0cmluZy4gKi8gKHQpID8gRXQodCwgKCh0LCByKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBycihyLCBlLnN0KHQpKTtcbiAgICAgICAgbnVsbCAhPSBzICYmIChuW3RdID0gcyk7XG4gICAgfSkpIDogXG4gICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IG9iamVjdCwgd2UgZXhwbGljaXRseSBhZGQgaXQgdG8gdGhlIHVwZGF0ZVxuICAgIC8vIG1hc2sgdG8gZW5zdXJlIHRoYXQgdGhlIHNlcnZlciBjcmVhdGVzIGEgbWFwIGVudHJ5LlxuICAgIGUucGF0aCAmJiBlLnBhdGgubGVuZ3RoID4gMCAmJiBlLmZpZWxkTWFzay5wdXNoKGUucGF0aCksIHtcbiAgICAgICAgbWFwVmFsdWU6IHtcbiAgICAgICAgICAgIGZpZWxkczogblxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXIodCkge1xuICAgIHJldHVybiAhKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgbnVsbCA9PT0gdCB8fCB0IGluc3RhbmNlb2YgQXJyYXkgfHwgdCBpbnN0YW5jZW9mIERhdGUgfHwgdCBpbnN0YW5jZW9mIFZ0IHx8IHQgaW5zdGFuY2VvZiBMbiB8fCB0IGluc3RhbmNlb2YgcW4gfHwgdCBpbnN0YW5jZW9mIFBuIHx8IHQgaW5zdGFuY2VvZiBDbik7XG59XG5cbmZ1bmN0aW9uIG9yKHQsIGUsIG4pIHtcbiAgICBpZiAoIWlyKG4pIHx8ICFmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIG51bGwgIT09IHQgJiYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBudWxsID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpO1xuICAgIH0obikpIHtcbiAgICAgICAgY29uc3QgciA9IHV0KG4pO1xuICAgICAgICB0aHJvdyBcImFuIG9iamVjdFwiID09PSByID8gZS5hdCh0ICsgXCIgYSBjdXN0b20gb2JqZWN0XCIpIDogZS5hdCh0ICsgXCIgXCIgKyByKTtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgY2FsbHMgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpIGJ1dCB3cmFwcyBhbnkgZXJyb3IgdGhyb3duLlxuICovIGZ1bmN0aW9uIHVyKHQsIGUsIG4pIHtcbiAgICBpZiAoKFxuICAgIC8vIElmIHJlcXVpcmVkLCByZXBsYWNlIHRoZSBGaWVsZFBhdGggQ29tcGF0IGNsYXNzIHdpdGggd2l0aCB0aGUgZmlyZXN0b3JlLWV4cFxuICAgIC8vIEZpZWxkUGF0aC5cbiAgICBlID0gbChlKSkgaW5zdGFuY2VvZiBPbikgcmV0dXJuIGUuX2ludGVybmFsUGF0aDtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIGFyKHQsIGUpO1xuICAgIHRocm93IGhyKFwiRmllbGQgcGF0aCBhcmd1bWVudHMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciBcIiwgdCwgXG4gICAgLyogaGFzQ29udmVydGVyPSAqLyAhMSwgXG4gICAgLyogcGF0aD0gKi8gdm9pZCAwLCBuKTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIGFueSBjaGFyYWN0ZXJzIGluIGEgZmllbGQgcGF0aCBzdHJpbmcgdGhhdCBhcmUgcmVzZXJ2ZWQuXG4gKi8gY29uc3QgY3IgPSBuZXcgUmVnRXhwKFwiW35cXFxcKi9cXFxcW1xcXFxdXVwiKTtcblxuLyoqXG4gKiBXcmFwcyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCB0aGUgbWV0aG9kIHRoYXRcbiAqIHdhcyB0aHJvd24uXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWNseSB2aXNpYmxlIG1ldGhvZCBuYW1lXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBkb3Qtc2VwYXJhdGVkIHN0cmluZyBmb3JtIG9mIGEgZmllbGQgcGF0aCB3aGljaCB3aWxsIGJlXG4gKiBzcGxpdCBvbiBkb3RzLlxuICogQHBhcmFtIHRhcmdldERvYyAtIFRoZSBkb2N1bWVudCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWVsZCBwYXRoIHdpbGwgYmVcbiAqIGV2YWx1YXRlZC5cbiAqLyBmdW5jdGlvbiBhcih0LCBlLCBuKSB7XG4gICAgaWYgKGUuc2VhcmNoKGNyKSA+PSAwKSB0aHJvdyBocihgSW52YWxpZCBmaWVsZCBwYXRoICgke2V9KS4gUGF0aHMgbXVzdCBub3QgY29udGFpbiAnficsICcqJywgJy8nLCAnWycsIG9yICddJ2AsIHQsIFxuICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gITEsIFxuICAgIC8qIHBhdGg9ICovIHZvaWQgMCwgbik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPbiguLi5lLnNwbGl0KFwiLlwiKSkuX2ludGVybmFsUGF0aDtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IGhyKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7ZX0pLiBQYXRocyBtdXN0IG5vdCBiZSBlbXB0eSwgYmVnaW4gd2l0aCAnLicsIGVuZCB3aXRoICcuJywgb3IgY29udGFpbiAnLi4nYCwgdCwgXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gITEsIFxuICAgICAgICAvKiBwYXRoPSAqLyB2b2lkIDAsIG4pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaHIodCwgZSwgbiwgciwgcykge1xuICAgIGNvbnN0IGkgPSByICYmICFyLmlzRW1wdHkoKSwgbyA9IHZvaWQgMCAhPT0gcztcbiAgICBsZXQgdSA9IGBGdW5jdGlvbiAke2V9KCkgY2FsbGVkIHdpdGggaW52YWxpZCBkYXRhYDtcbiAgICBuICYmICh1ICs9IFwiICh2aWEgYHRvRmlyZXN0b3JlKClgKVwiKSwgdSArPSBcIi4gXCI7XG4gICAgbGV0IGMgPSBcIlwiO1xuICAgIHJldHVybiAoaSB8fCBvKSAmJiAoYyArPSBcIiAoZm91bmRcIiwgaSAmJiAoYyArPSBgIGluIGZpZWxkICR7cn1gKSwgbyAmJiAoYyArPSBgIGluIGRvY3VtZW50ICR7c31gKSwgXG4gICAgYyArPSBcIilcIiksIG5ldyBVKFAsIHUgKyB0ICsgYyk7XG59XG5cbi8qKiBDaGVja3MgYGhheXN0YWNrYCBpZiBGaWVsZFBhdGggYG5lZWRsZWAgaXMgcHJlc2VudC4gUnVucyBpbiBPKG4pLiAqLyBmdW5jdGlvbiBscih0LCBlKSB7XG4gICAgcmV0dXJuIHQuc29tZSgodCA9PiB0LmlzRXF1YWwoZSkpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxuICogZGF0YWJhc2UuIFRoZSBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvXG4gKiBnZXQgYSBzcGVjaWZpYyBmaWVsZC5cbiAqXG4gKiBGb3IgYSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwb2ludHMgdG8gYSBub24tZXhpc3RpbmcgZG9jdW1lbnQsIGFueSBkYXRhXG4gKiBhY2Nlc3Mgd2lsbCByZXR1cm4gJ3VuZGVmaW5lZCcuIFlvdSBjYW4gdXNlIHRoZSBgZXhpc3RzKClgIG1ldGhvZCB0b1xuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cbiAqLyBjbGFzcyBmciB7XG4gICAgLy8gTm90ZTogVGhpcyBjbGFzcyBpcyBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIERvY3VtZW50U25hcHNob3QgaW5cbiAgICAvLyB0aGUgbGVnYWN5IFNESy4gVGhlIGNoYW5nZXMgYXJlOlxuICAgIC8vIC0gTm8gc3VwcG9ydCBmb3IgU25hcHNob3RNZXRhZGF0YS5cbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90T3B0aW9ucy5cbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciBwcm90ZWN0ZWQgKi9cbiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBuLCByLCBzKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IHQsIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gZSwgdGhpcy5fa2V5ID0gbiwgdGhpcy5fZG9jdW1lbnQgPSByLCBcbiAgICAgICAgdGhpcy5fY29udmVydGVyID0gcztcbiAgICB9XG4gICAgLyoqIFByb3BlcnR5IG9mIHRoZSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwcm92aWRlcyB0aGUgZG9jdW1lbnQncyBJRC4gKi8gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBEb2N1bWVudFJlZmVyZW5jZWAgZm9yIHRoZSBkb2N1bWVudCBpbmNsdWRlZCBpbiB0aGUgYERvY3VtZW50U25hcHNob3RgLlxuICAgICAqLyAgICBnZXQgcmVmKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBuKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fY29udmVydGVyLCB0aGlzLl9rZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBhdCB0aGUgc25hcHNob3QncyBsb2NhdGlvbiBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBleGlzdHMuXG4gICAgICovICAgIGV4aXN0cygpIHtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IHRoaXMuX2RvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcbiAgICAgKiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGBcbiAgICAgKiBpZiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi8gICAgZGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHVzZSB0aGUgY29udmVydGVyIGFuZCBjcmVhdGUgYSBuZXcgRG9jdW1lbnRTbmFwc2hvdFxuICAgICAgICAgICAgICAgIC8vIGlmIGEgY29udmVydGVyIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgZHIodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgdGhpcy5fa2V5LCB0aGlzLl9kb2N1bWVudCwgXG4gICAgICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHRoaXMuX2RvY3VtZW50LmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxuICAgICAqIGRvY3VtZW50IG9yIGZpZWxkIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xuICAgICAqIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgZmllbGQgbG9jYXRpb24gb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcbiAgICAgKiBmaWVsZCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIC8vIFdlIGFyZSB1c2luZyBgYW55YCBoZXJlIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGNhc3QgYnkgb3VyIHVzZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZ2V0KHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChwcihcIkRvY3VtZW50U25hcHNob3QuZ2V0XCIsIHQpKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBlKSByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UgYXMgcGFydCBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnQgaXMgZ3VhcmFudGVlZCB0byBleGlzdFxuICogYW5kIGl0cyBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvIGdldCBhXG4gKiBzcGVjaWZpYyBmaWVsZC5cbiAqXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIG9mZmVycyB0aGUgc2FtZSBBUEkgc3VyZmFjZSBhcyBhXG4gKiBgRG9jdW1lbnRTbmFwc2hvdGAuIFNpbmNlIHF1ZXJ5IHJlc3VsdHMgY29udGFpbiBvbmx5IGV4aXN0aW5nIGRvY3VtZW50cywgdGhlXG4gKiBgZXhpc3RzYCBwcm9wZXJ0eSB3aWxsIGFsd2F5cyBiZSB0cnVlIGFuZCBgZGF0YSgpYCB3aWxsIG5ldmVyIHJldHVyblxuICogJ3VuZGVmaW5lZCcuXG4gKi8gY2xhc3MgZHIgZXh0ZW5kcyBmciB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGF0YSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGBRdWVyeVNuYXBzaG90YCBjb250YWlucyB6ZXJvIG9yIG1vcmUgYERvY3VtZW50U25hcHNob3RgIG9iamVjdHNcbiAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnRzIGNhbiBiZSBhY2Nlc3NlZCBhcyBhblxuICogYXJyYXkgdmlhIHRoZSBgZG9jc2AgcHJvcGVydHkgb3IgZW51bWVyYXRlZCB1c2luZyB0aGUgYGZvckVhY2hgIG1ldGhvZC4gVGhlXG4gKiBudW1iZXIgb2YgZG9jdW1lbnRzIGNhbiBiZSBkZXRlcm1pbmVkIHZpYSB0aGUgYGVtcHR5YCBhbmQgYHNpemVgXG4gKiBwcm9wZXJ0aWVzLlxuICovIGNsYXNzIHdyIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgdGhpcy5fZG9jcyA9IGUsIHRoaXMucXVlcnkgPSB0O1xuICAgIH1cbiAgICAvKiogQW4gYXJyYXkgb2YgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi8gICAgZ2V0IGRvY3MoKSB7XG4gICAgICAgIHJldHVybiBbIC4uLnRoaXMuX2RvY3MgXTtcbiAgICB9XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqIFRydWUgaWYgdGhlcmUgYXJlIG5vIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqLyAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAwID09PSB0aGlzLmRvY3MubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIGEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgZm9yXG4gICAgICogZWFjaCBkb2N1bWVudCBpbiB0aGUgc25hcHNob3QuXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBUaGUgYHRoaXNgIGJpbmRpbmcgZm9yIHRoZSBjYWxsYmFjay5cbiAgICAgKi8gICAgZm9yRWFjaCh0LCBlKSB7XG4gICAgICAgIHRoaXMuX2RvY3MuZm9yRWFjaCh0LCBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBzbmFwc2hvdHMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQSBzbmFwc2hvdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHJpZ2h0IC0gQSBzbmFwc2hvdCB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc25hcHNob3RzIGFyZSBlcXVhbC5cbiAqLyBmdW5jdGlvbiBtcih0LCBlKSB7XG4gICAgcmV0dXJuIHQgPSBsKHQpLCBlID0gbChlKSwgdCBpbnN0YW5jZW9mIGZyICYmIGUgaW5zdGFuY2VvZiBmciA/IHQuX2ZpcmVzdG9yZSA9PT0gZS5fZmlyZXN0b3JlICYmIHQuX2tleS5pc0VxdWFsKGUuX2tleSkgJiYgKG51bGwgPT09IHQuX2RvY3VtZW50ID8gbnVsbCA9PT0gZS5fZG9jdW1lbnQgOiB0Ll9kb2N1bWVudC5pc0VxdWFsKGUuX2RvY3VtZW50KSkgJiYgdC5fY29udmVydGVyID09PSBlLl9jb252ZXJ0ZXIgOiB0IGluc3RhbmNlb2Ygd3IgJiYgZSBpbnN0YW5jZW9mIHdyICYmIChTbih0LnF1ZXJ5LCBlLnF1ZXJ5KSAmJiB2dCh0LmRvY3MsIGUuZG9jcywgbXIpKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCBjYWxscyBgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpYCBidXQgd3JhcHMgYW55IGVycm9yIHRocm93bi5cbiAqLyBmdW5jdGlvbiBwcih0LCBlKSB7XG4gICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBhcih0LCBlKSA6IGUgaW5zdGFuY2VvZiBPbiA/IGUuX2ludGVybmFsUGF0aCA6IGUuX2RlbGVnYXRlLl9pbnRlcm5hbFBhdGg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGBBcHBsaWFibGVDb25zdHJhaW50YCBpcyBhbiBhYnN0cmFjdGlvbiBvZiBhIGNvbnN0cmFpbnQgdGhhdCBjYW4gYmUgYXBwbGllZFxuICogdG8gYSBGaXJlc3RvcmUgcXVlcnkuXG4gKi9cbmNsYXNzIHlyIHt9XG5cbi8qKlxuICogQSBgUXVlcnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXG4gKiBGaXJlc3RvcmUgcXVlcnkuIGBRdWVyeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgd2hlcmV9LFxuICoge0BsaW5rIG9yZGVyQnl9LCB7QGxpbmsgc3RhcnRBdH0sIHtAbGluayBzdGFydEFmdGVyfSwge0BsaW5rXG4gKiBlbmRCZWZvcmV9LCB7QGxpbmsgZW5kQXR9LCB7QGxpbmsgbGltaXR9LCB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZFxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcbiAqIGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlDb25zdHJhaW50YC5cbiAqLyBjbGFzcyBnciBleHRlbmRzIHlyIHt9XG5cbmZ1bmN0aW9uIF9yKHQsIGUsIC4uLm4pIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGUgaW5zdGFuY2VvZiB5ciAmJiByLnB1c2goZSksIHIgPSByLmNvbmNhdChuKSwgZnVuY3Rpb24odCkge1xuICAgICAgICBjb25zdCBlID0gdC5maWx0ZXIoKHQgPT4gdCBpbnN0YW5jZW9mIEVyKSkubGVuZ3RoLCBuID0gdC5maWx0ZXIoKHQgPT4gdCBpbnN0YW5jZW9mIHZyKSkubGVuZ3RoO1xuICAgICAgICBpZiAoZSA+IDEgfHwgZSA+IDAgJiYgbiA+IDApIHRocm93IG5ldyBVKFAsIFwiSW52YWxpZFF1ZXJ5LiBXaGVuIHVzaW5nIGNvbXBvc2l0ZSBmaWx0ZXJzLCB5b3UgY2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIGZpbHRlciBhdCB0aGUgdG9wIGxldmVsLiBDb25zaWRlciBuZXN0aW5nIHRoZSBtdWx0aXBsZSBmaWx0ZXJzIHdpdGhpbiBhbiBgYW5kKC4uLilgIHN0YXRlbWVudC4gRm9yIGV4YW1wbGU6IGNoYW5nZSBgcXVlcnkocXVlcnksIHdoZXJlKC4uLiksIG9yKC4uLikpYCB0byBgcXVlcnkocXVlcnksIGFuZCh3aGVyZSguLi4pLCBvciguLi4pKSlgLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbiAgICAvKipcbiAqIENvbnZlcnRzIEZpcmVzdG9yZSdzIGludGVybmFsIHR5cGVzIHRvIHRoZSBKYXZhU2NyaXB0IHR5cGVzIHRoYXQgd2UgZXhwb3NlXG4gKiB0byB0aGUgdXNlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqLyAocik7XG4gICAgZm9yIChjb25zdCBlIG9mIHIpIHQgPSBlLl9hcHBseSh0KTtcbiAgICByZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBBIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnlcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5IGJ5IGZpbHRlcmluZyBvbiBvbmUgb3IgbW9yZSBkb2N1bWVudCBmaWVsZHMuXG4gKiBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgd2hlcmV9IGFuZCBjYW4gdGhlblxuICogYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWluc1xuICogdGhpcyBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgLlxuICovIGNsYXNzIHZyIGV4dGVuZHMgZ3Ige1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHtcbiAgICAgICAgc3VwZXIoKSwgdGhpcy5fZmllbGQgPSB0LCB0aGlzLl9vcCA9IGUsIHRoaXMuX3ZhbHVlID0gbiwgXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICAgICAgdGhpcy50eXBlID0gXCJ3aGVyZVwiO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0LCBlLCBuKSB7XG4gICAgICAgIHJldHVybiBuZXcgdnIodCwgZSwgbik7XG4gICAgfVxuICAgIF9hcHBseSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl9wYXJzZSh0KTtcbiAgICAgICAgcmV0dXJuIExyKHQuX3F1ZXJ5LCBlKSwgbmV3IFZuKHQuZmlyZXN0b3JlLCB0LmNvbnZlcnRlciwgSWUodC5fcXVlcnksIGUpKTtcbiAgICB9XG4gICAgX3BhcnNlKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IFduKHQuZmlyZXN0b3JlKSwgbiA9IGZ1bmN0aW9uKHQsIGUsIG4sIHIsIHMsIGksIG8pIHtcbiAgICAgICAgICAgIGxldCB1O1xuICAgICAgICAgICAgaWYgKHMuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyA9PT0gaSB8fCBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLyA9PT0gaSkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgUXVlcnkuIFlvdSBjYW4ndCBwZXJmb3JtICcke2l9JyBxdWVyaWVzIG9uIGRvY3VtZW50SWQoKS5gKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJpblwiIC8qIE9wZXJhdG9yLklOICovID09PSBpIHx8IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIENyKG8sIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbiBvZiBvKSBlLnB1c2goa3IociwgdCwgbikpO1xuICAgICAgICAgICAgICAgICAgICB1ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB1ID0ga3IociwgdCwgbyk7XG4gICAgICAgICAgICB9IGVsc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovICE9PSBpICYmIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovICE9PSBpICYmIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovICE9PSBpIHx8IENyKG8sIGkpLCBcbiAgICAgICAgICAgIHUgPSBucihuLCBlLCBvLCBcbiAgICAgICAgICAgIC8qIGFsbG93QXJyYXlzPSAqLyBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gPT09IGkgfHwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gPT09IGkpO1xuICAgICAgICAgICAgcmV0dXJuIEd0LmNyZWF0ZShzLCBpLCB1KTtcbiAgICAgICAgfSh0Ll9xdWVyeSwgXCJ3aGVyZVwiLCBlLCB0LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgdGhpcy5fZmllbGQsIHRoaXMuX29wLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGVuZm9yY2VzIHRoYXQgZG9jdW1lbnRzXG4gKiBtdXN0IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCBhbmQgdGhhdCB0aGUgdmFsdWUgc2hvdWxkIHNhdGlzZnkgdGhlXG4gKiByZWxhdGlvbiBjb25zdHJhaW50IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCB0byBjb21wYXJlXG4gKiBAcGFyYW0gb3BTdHIgLSBUaGUgb3BlcmF0aW9uIHN0cmluZyAoZS5nIFwiJmx0O1wiLCBcIiZsdDs9XCIsIFwiPT1cIiwgXCImbHQ7XCIsXG4gKiAgIFwiJmx0Oz1cIiwgXCIhPVwiKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgY29tcGFyaXNvblxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fS5cbiAqLyBmdW5jdGlvbiBicih0LCBlLCBuKSB7XG4gICAgY29uc3QgciA9IGUsIHMgPSBwcihcIndoZXJlXCIsIHQpO1xuICAgIHJldHVybiB2ci5fY3JlYXRlKHMsIHIsIG4pO1xufVxuXG4vKipcbiAqIEEgYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHNcbiAqIHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5IGJ5IHBlcmZvcm1pbmcgdGhlIGxvZ2ljYWwgT1Igb3IgQU5EIG9mIG11bHRpcGxlXG4gKiB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9cyBvciB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fXMuXG4gKiBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIG9yfSBvclxuICoge0BsaW5rIGFuZH0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgcXVlcnl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeVxuICogaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoZSBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YC5cbiAqIEBpbnRlcm5hbCBUT0RPIHJlbW92ZSB0aGlzIGludGVybmFsIHRhZyB3aXRoIE9SIFF1ZXJ5IHN1cHBvcnQgaW4gdGhlIHNlcnZlclxuICovIGNsYXNzIEVyIGV4dGVuZHMgeXIge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0LCBlKSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMudHlwZSA9IHQsIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHMgPSBlO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0LCBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXIodCwgZSk7XG4gICAgfVxuICAgIF9wYXJzZSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl9xdWVyeUNvbnN0cmFpbnRzLm1hcCgoZSA9PiBlLl9wYXJzZSh0KSkpLmZpbHRlcigodCA9PiB0LmdldEZpbHRlcnMoKS5sZW5ndGggPiAwKSk7XG4gICAgICAgIHJldHVybiAxID09PSBlLmxlbmd0aCA/IGVbMF0gOiBLdC5jcmVhdGUoZSwgdGhpcy5fZ2V0T3BlcmF0b3IoKSk7XG4gICAgfVxuICAgIF9hcHBseSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl9wYXJzZSh0KTtcbiAgICAgICAgcmV0dXJuIDAgPT09IGUuZ2V0RmlsdGVycygpLmxlbmd0aCA/IHQgOiAoZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgbGV0IG4gPSB0O1xuICAgICAgICAgICAgY29uc3QgciA9IGUuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHIpIExyKG4sIHQpLCBuID0gSWUobiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2tzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgZmlsdGVyIG9wZXJhdG9ycyBhcmUgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgZmlsdGVycyBhbmRcbiAgICAgICAgLy8gcmV0dXJucyB0aGUgZmlyc3Qgb25lIHRoYXQgaXMsIG9yIG51bGwgaWYgbm9uZSBhcmUuXG4gICAgICAgICh0Ll9xdWVyeSwgZSksIG5ldyBWbih0LmZpcmVzdG9yZSwgdC5jb252ZXJ0ZXIsIEllKHQuX3F1ZXJ5LCBlKSkpO1xuICAgIH1cbiAgICBfZ2V0UXVlcnlDb25zdHJhaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHM7XG4gICAgfVxuICAgIF9nZXRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIFwiYW5kXCIgPT09IHRoaXMudHlwZSA/IFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovIDogXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBwZXJmb3JtcyBhIGxvZ2ljYWwgT1JcbiAqIG9mIGFsbCB0aGUgcHJvdmlkZWQge0BsaW5rIFF1ZXJ5RmlsdGVyQ29uc3RyYWludH1zLlxuICpcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gT3B0aW9uYWwuIFRoZSB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXNcbiAqIGZvciBPUiBvcGVyYXRpb24uIFRoZXNlIG11c3QgYmUgY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sXG4gKiB7QGxpbmsgb3J9LCBvciB7QGxpbmsgYW5kfS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxuICogQGludGVybmFsIFRPRE8gcmVtb3ZlIHRoaXMgaW50ZXJuYWwgdGFnIHdpdGggT1IgUXVlcnkgc3VwcG9ydCBpbiB0aGUgc2VydmVyXG4gKi8gZnVuY3Rpb24gSXIoLi4udCkge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXG4gICAgcmV0dXJuIHQuZm9yRWFjaCgodCA9PiBVcihcIm9yXCIsIHQpKSksIEVyLl9jcmVhdGUoXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovICwgdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9IHRoYXQgcGVyZm9ybXMgYSBsb2dpY2FsIEFORFxuICogb2YgYWxsIHRoZSBwcm92aWRlZCB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMuXG4gKlxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBPcHRpb25hbC4gVGhlIHtAbGluayBRdWVyeUZpbHRlckNvbnN0cmFpbnR9c1xuICogZm9yIEFORCBvcGVyYXRpb24uIFRoZXNlIG11c3QgYmUgY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sXG4gKiB7QGxpbmsgb3J9LCBvciB7QGxpbmsgYW5kfS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxuICogQGludGVybmFsIFRPRE8gcmVtb3ZlIHRoaXMgaW50ZXJuYWwgdGFnIHdpdGggT1IgUXVlcnkgc3VwcG9ydCBpbiB0aGUgc2VydmVyXG4gKi8gZnVuY3Rpb24gVHIoLi4udCkge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXG4gICAgcmV0dXJuIHQuZm9yRWFjaCgodCA9PiBVcihcImFuZFwiLCB0KSkpLCBFci5fY3JlYXRlKFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovICwgdCk7XG59XG5cbi8qKlxuICogQSBgUXVlcnlPcmRlckJ5Q29uc3RyYWludGAgaXMgdXNlZCB0byBzb3J0IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZ1xuICoge0BsaW5rIG9yZGVyQnl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIHF1ZXJ5fSB0byBjcmVhdGUgYSBuZXcgcXVlcnlcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YC5cbiAqXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgb3JkZXJCeSBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50IGluXG4gKiB0aGUgcXVlcnkgcmVzdWx0LlxuICovIGNsYXNzIEFyIGV4dGVuZHMgZ3Ige1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgc3VwZXIoKSwgdGhpcy5fZmllbGQgPSB0LCB0aGlzLl9kaXJlY3Rpb24gPSBlLCBcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBcIm9yZGVyQnlcIjtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodCwgZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFyKHQsIGUpO1xuICAgIH1cbiAgICBfYXBwbHkodCkge1xuICAgICAgICBjb25zdCBlID0gZnVuY3Rpb24odCwgZSwgbikge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHQuc3RhcnRBdCkgdGhyb3cgbmV3IFUoUCwgXCJJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBzdGFydEF0KCkgb3Igc3RhcnRBZnRlcigpIGJlZm9yZSBjYWxsaW5nIG9yZGVyQnkoKS5cIik7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdC5lbmRBdCkgdGhyb3cgbmV3IFUoUCwgXCJJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBlbmRBdCgpIG9yIGVuZEJlZm9yZSgpIGJlZm9yZSBjYWxsaW5nIG9yZGVyQnkoKS5cIik7XG4gICAgICAgICAgICBjb25zdCByID0gbmV3IHNlKGUsIG4pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gZ2UodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgb3JkZXIgYnkuIEl0IG11c3QgbWF0Y2ggYW55IGluZXF1YWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBfZSh0KTtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbiAmJiBNcih0LCBuLCBlLmZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KHQsIHIpLCByO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICogQ3JlYXRlIGEgYEJvdW5kYCBmcm9tIGEgcXVlcnkgYW5kIGEgZG9jdW1lbnQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgQm91bmRgIHdpbGwgYWx3YXlzIGluY2x1ZGUgdGhlIGtleSBvZiB0aGUgZG9jdW1lbnRcbiAqIGFuZCBzbyBvbmx5IHRoZSBwcm92aWRlZCBkb2N1bWVudCB3aWxsIGNvbXBhcmUgZXF1YWwgdG8gdGhlIHJldHVybmVkXG4gKiBwb3NpdGlvbi5cbiAqXG4gKiBXaWxsIHRocm93IGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFsbCBmaWVsZHMgb2YgdGhlIG9yZGVyIGJ5XG4gKiBvZiB0aGUgcXVlcnkgb3IgaWYgYW55IG9mIHRoZSBmaWVsZHMgaW4gdGhlIG9yZGVyIGJ5IGFyZSBhbiB1bmNvbW1pdHRlZFxuICogc2VydmVyIHRpbWVzdGFtcC5cbiAqLyAodC5fcXVlcnksIHRoaXMuX2ZpZWxkLCB0aGlzLl9kaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gbmV3IFZuKHQuZmlyZXN0b3JlLCB0LmNvbnZlcnRlciwgZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0ZSB0aGF0IG9yZGVyQnkgZG9lcyBub3QgbGlzdCB0aGUgc2FtZSBrZXkgdHdpY2UuXG4gICAgICAgICAgICBjb25zdCBuID0gdC5leHBsaWNpdE9yZGVyQnkuY29uY2F0KFsgZSBdKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgeWUodC5wYXRoLCB0LmNvbGxlY3Rpb25Hcm91cCwgbiwgdC5maWx0ZXJzLnNsaWNlKCksIHQubGltaXQsIHQubGltaXRUeXBlLCB0LnN0YXJ0QXQsIHQuZW5kQXQpO1xuICAgICAgICB9KHQuX3F1ZXJ5LCBlKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlPcmRlckJ5Q29uc3RyYWludH0gdGhhdCBzb3J0cyB0aGUgcXVlcnkgcmVzdWx0IGJ5IHRoZVxuICogc3BlY2lmaWVkIGZpZWxkLCBvcHRpb25hbGx5IGluIGRlc2NlbmRpbmcgb3JkZXIgaW5zdGVhZCBvZiBhc2NlbmRpbmcuXG4gKlxuICogTm90ZTogRG9jdW1lbnRzIHRoYXQgZG8gbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50XG4gKiBpbiB0aGUgcXVlcnkgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgZmllbGQgdG8gc29ydCBieS5cbiAqIEBwYXJhbSBkaXJlY3Rpb25TdHIgLSBPcHRpb25hbCBkaXJlY3Rpb24gdG8gc29ydCBieSAoJ2FzYycgb3IgJ2Rlc2MnKS4gSWZcbiAqIG5vdCBzcGVjaWZpZWQsIG9yZGVyIHdpbGwgYmUgYXNjZW5kaW5nLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnR9LlxuICovIGZ1bmN0aW9uIFJyKHQsIGUgPSBcImFzY1wiKSB7XG4gICAgY29uc3QgbiA9IGUsIHIgPSBwcihcIm9yZGVyQnlcIiwgdCk7XG4gICAgcmV0dXJuIEFyLl9jcmVhdGUociwgbik7XG59XG5cbi8qKlxuICogQSBgUXVlcnlMaW1pdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbGltaXQgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnlcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5LlxuICogYFF1ZXJ5TGltaXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIGxpbWl0fSBvclxuICoge0BsaW5rIGxpbWl0VG9MYXN0fSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3XG4gKiBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlMaW1pdENvbnN0cmFpbnRgLlxuICovIGNsYXNzIFByIGV4dGVuZHMgZ3Ige1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0LCBlLCBuKSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMudHlwZSA9IHQsIHRoaXMuX2xpbWl0ID0gZSwgdGhpcy5fbGltaXRUeXBlID0gbjtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodCwgZSwgbikge1xuICAgICAgICByZXR1cm4gbmV3IFByKHQsIGUsIG4pO1xuICAgIH1cbiAgICBfYXBwbHkodCkge1xuICAgICAgICByZXR1cm4gbmV3IFZuKHQuZmlyZXN0b3JlLCB0LmNvbnZlcnRlciwgZnVuY3Rpb24odCwgZSwgbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB5ZSh0LnBhdGgsIHQuY29sbGVjdGlvbkdyb3VwLCB0LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCB0LmZpbHRlcnMuc2xpY2UoKSwgZSwgbiwgdC5zdGFydEF0LCB0LmVuZEF0KTtcbiAgICAgICAgfSh0Ll9xdWVyeSwgdGhpcy5fbGltaXQsIHRoaXMuX2xpbWl0VHlwZSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fSB0aGF0IG9ubHkgcmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmdcbiAqIGRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fS5cbiAqLyBmdW5jdGlvbiBWcih0KSB7XG4gICAgcmV0dXJuIGF0KFwibGltaXRcIiwgdCksIFByLl9jcmVhdGUoXCJsaW1pdFwiLCB0LCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9IHRoYXQgb25seSByZXR1cm5zIHRoZSBsYXN0IG1hdGNoaW5nXG4gKiBkb2N1bWVudHMuXG4gKlxuICogWW91IG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgYG9yZGVyQnlgIGNsYXVzZSBmb3IgYGxpbWl0VG9MYXN0YCBxdWVyaWVzLFxuICogb3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBkdXJpbmcgZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9LlxuICovIGZ1bmN0aW9uICRyKHQpIHtcbiAgICByZXR1cm4gYXQoXCJsaW1pdFRvTGFzdFwiLCB0KSwgUHIuX2NyZWF0ZShcImxpbWl0VG9MYXN0XCIsIHQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcbn1cblxuLyoqXG4gKiBBIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGV4Y2x1ZGUgZG9jdW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIGFcbiAqIHJlc3VsdCBzZXQgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkuXG4gKiBgUXVlcnlTdGFydEF0Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayAoc3RhcnRBdDoxKX0gb3JcbiAqIHtAbGluayAoc3RhcnRBZnRlcjoxKX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgcXVlcnl9IHRvIGNyZWF0ZSBhXG4gKiBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgLlxuICovIGNsYXNzIE5yIGV4dGVuZHMgZ3Ige1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0LCBlLCBuKSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMudHlwZSA9IHQsIHRoaXMuX2RvY09yRmllbGRzID0gZSwgdGhpcy5faW5jbHVzaXZlID0gbjtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodCwgZSwgbikge1xuICAgICAgICByZXR1cm4gbmV3IE5yKHQsIGUsIG4pO1xuICAgIH1cbiAgICBfYXBwbHkodCkge1xuICAgICAgICBjb25zdCBlID0gT3IodCwgdGhpcy50eXBlLCB0aGlzLl9kb2NPckZpZWxkcywgdGhpcy5faW5jbHVzaXZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWbih0LmZpcmVzdG9yZSwgdC5jb252ZXJ0ZXIsIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgeWUodC5wYXRoLCB0LmNvbGxlY3Rpb25Hcm91cCwgdC5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgdC5maWx0ZXJzLnNsaWNlKCksIHQubGltaXQsIHQubGltaXRUeXBlLCBlLCB0LmVuZEF0KTtcbiAgICAgICAgfSh0Ll9xdWVyeSwgZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gRHIoLi4udCkge1xuICAgIHJldHVybiBOci5fY3JlYXRlKFwic3RhcnRBdFwiLCB0LCBcbiAgICAvKmluY2x1c2l2ZT0qLyAhMCk7XG59XG5cbmZ1bmN0aW9uIEZyKC4uLnQpIHtcbiAgICByZXR1cm4gTnIuX2NyZWF0ZShcInN0YXJ0QWZ0ZXJcIiwgdCwgXG4gICAgLyppbmNsdXNpdmU9Ki8gITEpO1xufVxuXG4vKipcbiAqIEEgYFF1ZXJ5RW5kQXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGV4Y2x1ZGUgZG9jdW1lbnRzIGZyb20gdGhlIGVuZCBvZiBhXG4gKiByZXN1bHQgc2V0IHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5LlxuICogYFF1ZXJ5RW5kQXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChlbmRBdDoxKX0gb3JcbiAqIHtAbGluayAoZW5kQmVmb3JlOjEpfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3XG4gKiBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlFbmRBdENvbnN0cmFpbnRgLlxuICovIGNsYXNzIHhyIGV4dGVuZHMgZ3Ige1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0LCBlLCBuKSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMudHlwZSA9IHQsIHRoaXMuX2RvY09yRmllbGRzID0gZSwgdGhpcy5faW5jbHVzaXZlID0gbjtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodCwgZSwgbikge1xuICAgICAgICByZXR1cm4gbmV3IHhyKHQsIGUsIG4pO1xuICAgIH1cbiAgICBfYXBwbHkodCkge1xuICAgICAgICBjb25zdCBlID0gT3IodCwgdGhpcy50eXBlLCB0aGlzLl9kb2NPckZpZWxkcywgdGhpcy5faW5jbHVzaXZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWbih0LmZpcmVzdG9yZSwgdC5jb252ZXJ0ZXIsIGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgeWUodC5wYXRoLCB0LmNvbGxlY3Rpb25Hcm91cCwgdC5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgdC5maWx0ZXJzLnNsaWNlKCksIHQubGltaXQsIHQubGltaXRUeXBlLCB0LnN0YXJ0QXQsIGUpO1xuICAgICAgICB9KHQuX3F1ZXJ5LCBlKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBTciguLi50KSB7XG4gICAgcmV0dXJuIHhyLl9jcmVhdGUoXCJlbmRCZWZvcmVcIiwgdCwgXG4gICAgLyppbmNsdXNpdmU9Ki8gITEpO1xufVxuXG5mdW5jdGlvbiBxciguLi50KSB7XG4gICAgcmV0dXJuIHhyLl9jcmVhdGUoXCJlbmRBdFwiLCB0LCBcbiAgICAvKmluY2x1c2l2ZT0qLyAhMCk7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYm91bmQgZnJvbSBhIGRvY3VtZW50IG9yIGZpZWxkcyAqLyBmdW5jdGlvbiBPcih0LCBlLCBuLCByKSB7XG4gICAgaWYgKG5bMF0gPSBsKG5bMF0pLCBuWzBdIGluc3RhbmNlb2YgZnIpIHJldHVybiBmdW5jdGlvbih0LCBlLCBuLCByLCBzKSB7XG4gICAgICAgIGlmICghcikgdGhyb3cgbmV3IFUoJCwgYENhbid0IHVzZSBhIERvY3VtZW50U25hcHNob3QgdGhhdCBkb2Vzbid0IGV4aXN0IGZvciAke259KCkuYCk7XG4gICAgICAgIGNvbnN0IGkgPSBbXTtcbiAgICAgICAgLy8gQmVjYXVzZSBwZW9wbGUgZXhwZWN0IHRvIGNvbnRpbnVlL2VuZCBhIHF1ZXJ5IGF0IHRoZSBleGFjdCBkb2N1bWVudFxuICAgICAgICAvLyBwcm92aWRlZCwgd2UgbmVlZCB0byB1c2UgdGhlIGltcGxpY2l0IHNvcnQgb3JkZXIgcmF0aGVyIHRoYW4gdGhlIGV4cGxpY2l0XG4gICAgICAgIC8vIHNvcnQgb3JkZXIsIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIHRvIGNvbnRhaW4gdGhlIGRvY3VtZW50IGtleS4gVGhhdCB3YXlcbiAgICAgICAgLy8gdGhlIHBvc2l0aW9uIGJlY29tZXMgdW5hbWJpZ3VvdXMgYW5kIHRoZSBxdWVyeSBjb250aW51ZXMvZW5kcyBleGFjdGx5IGF0XG4gICAgICAgIC8vIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gV2l0aG91dCB0aGUga2V5IChieSB1c2luZyB0aGUgZXhwbGljaXQgc29ydFxuICAgICAgICAvLyBvcmRlcnMpLCBtdWx0aXBsZSBkb2N1bWVudHMgY291bGQgbWF0Y2ggdGhlIHBvc2l0aW9uLCB5aWVsZGluZyBkdXBsaWNhdGVcbiAgICAgICAgLy8gcmVzdWx0cy5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgYmUodCkpIGlmIChuLmZpZWxkLmlzS2V5RmllbGQoKSkgaS5wdXNoKEN0KGUsIHIua2V5KSk7IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdCA9IHIuZGF0YS5maWVsZChuLmZpZWxkKTtcbiAgICAgICAgICAgIGlmICgkdCh0KSkgdGhyb3cgbmV3IFUoUCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBhcmUgdHJ5aW5nIHRvIHN0YXJ0IG9yIGVuZCBhIHF1ZXJ5IHVzaW5nIGEgZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCBcIicgKyBuLmZpZWxkICsgJ1wiIGlzIGFuIHVuY29tbWl0dGVkIHNlcnZlciB0aW1lc3RhbXAuIChTaW5jZSB0aGUgdmFsdWUgb2YgdGhpcyBmaWVsZCBpcyB1bmtub3duLCB5b3UgY2Fubm90IHN0YXJ0L2VuZCBhIHF1ZXJ5IHdpdGggaXQuKScpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gbi5maWVsZC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVShQLCBgSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSBkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkICcke3R9JyAodXNlZCBhcyB0aGUgb3JkZXJCeSkgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBRdChpLCBzKTtcbiAgICB9XG4gICAgLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgZmllbGQgdmFsdWVzIHRvIGEgYEJvdW5kYCBmb3IgdGhlIGdpdmVuIHF1ZXJ5LlxuICovICh0Ll9xdWVyeSwgdC5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIGUsIG5bMF0uX2RvY3VtZW50LCByKTtcbiAgICB7XG4gICAgICAgIGNvbnN0IHMgPSBXbih0LmZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0LCBlLCBuLCByLCBzLCBpKSB7XG4gICAgICAgICAgICAvLyBVc2UgZXhwbGljaXQgb3JkZXIgYnkncyBiZWNhdXNlIGl0IGhhcyB0byBtYXRjaCB0aGUgcXVlcnkgdGhlIHVzZXIgbWFkZVxuICAgICAgICAgICAgY29uc3QgbyA9IHQuZXhwbGljaXRPcmRlckJ5O1xuICAgICAgICAgICAgaWYgKHMubGVuZ3RoID4gby5sZW5ndGgpIHRocm93IG5ldyBVKFAsIGBUb28gbWFueSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gJHtyfSgpLiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIG9yZGVyQnkoKSBjbGF1c2VzYCk7XG4gICAgICAgICAgICBjb25zdCB1ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob1tpXS5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGMpIHRocm93IG5ldyBVKFAsIGBJbnZhbGlkIHF1ZXJ5LiBFeHBlY3RlZCBhIHN0cmluZyBmb3IgZG9jdW1lbnQgSUQgaW4gJHtyfSgpLCBidXQgZ290IGEgJHt0eXBlb2YgY31gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZSh0KSAmJiAtMSAhPT0gYy5pbmRleE9mKFwiL1wiKSkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGFuZCBvcmRlcmluZyBieSBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHtyfSgpIG11c3QgYmUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0ICcke2N9JyBjb250YWlucyBhIHNsYXNoLmApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gdC5wYXRoLmNoaWxkKHR0LmZyb21TdHJpbmcoYykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ0LmlzRG9jdW1lbnRLZXkobikpIHRocm93IG5ldyBVKFAsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBhbmQgb3JkZXJpbmcgYnkgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcGFzc2VkIHRvICR7cn0oKSBtdXN0IHJlc3VsdCBpbiBhIHZhbGlkIGRvY3VtZW50IHBhdGgsIGJ1dCAnJHtufScgaXMgbm90IGJlY2F1c2UgaXQgY29udGFpbnMgYW4gb2RkIG51bWJlciBvZiBzZWdtZW50cy5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IG5ldyBydChuKTtcbiAgICAgICAgICAgICAgICAgICAgdS5wdXNoKEN0KGUsIHMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gbnIobiwgciwgYyk7XG4gICAgICAgICAgICAgICAgICAgIHUucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFF0KHUsIGkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBgZG9jdW1lbnRJZFZhbHVlYCBpbnRvIGEgYFJlZmVyZW5jZVZhbHVlYCwgdGhyb3dpbmdcbiAqIGFwcHJvcHJpYXRlIGVycm9ycyBpZiB0aGUgdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIGBEb2N1bWVudFJlZmVyZW5jZWBcbiAqIG9yIGBzdHJpbmdgLCBvciBpZiB0aGUgc3RyaW5nIGlzIG1hbGZvcm1lZC5cbiAqLyAodC5fcXVlcnksIHQuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBzLCBlLCBuLCByKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGtyKHQsIGUsIG4pIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgKG4gPSBsKG4pKSkge1xuICAgICAgICBpZiAoXCJcIiA9PT0gbikgdGhyb3cgbmV3IFUoUCwgXCJJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIHdpdGggZG9jdW1lbnRJZCgpLCB5b3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9jdW1lbnQgSUQsIGJ1dCBpdCB3YXMgYW4gZW1wdHkgc3RyaW5nLlwiKTtcbiAgICAgICAgaWYgKCF2ZShlKSAmJiAtMSAhPT0gbi5pbmRleE9mKFwiL1wiKSkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGJ5IGRvY3VtZW50SWQoKSwgeW91IG11c3QgcHJvdmlkZSBhIHBsYWluIGRvY3VtZW50IElELCBidXQgJyR7bn0nIGNvbnRhaW5zIGEgJy8nIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgY29uc3QgciA9IGUucGF0aC5jaGlsZCh0dC5mcm9tU3RyaW5nKG4pKTtcbiAgICAgICAgaWYgKCFydC5pc0RvY3VtZW50S2V5KHIpKSB0aHJvdyBuZXcgVShQLCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYnkgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcHJvdmlkZWQgbXVzdCByZXN1bHQgaW4gYSB2YWxpZCBkb2N1bWVudCBwYXRoLCBidXQgJyR7cn0nIGlzIG5vdCBiZWNhdXNlIGl0IGhhcyBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzICgke3IubGVuZ3RofSkuYCk7XG4gICAgICAgIHJldHVybiBDdCh0LCBuZXcgcnQocikpO1xuICAgIH1cbiAgICBpZiAobiBpbnN0YW5jZW9mIFBuKSByZXR1cm4gQ3QodCwgbi5fa2V5KTtcbiAgICB0aHJvdyBuZXcgVShQLCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91IG11c3QgcHJvdmlkZSBhIHZhbGlkIHN0cmluZyBvciBhIERvY3VtZW50UmVmZXJlbmNlLCBidXQgaXQgd2FzOiAke3V0KG4pfS5gKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgcGFzc2VkIGludG8gYSBkaXNqdW5jdGl2ZSBmaWx0ZXIgc2F0aXNmaWVzIGFsbFxuICogYXJyYXkgcmVxdWlyZW1lbnRzLlxuICovIGZ1bmN0aW9uIENyKHQsIGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodCkgfHwgMCA9PT0gdC5sZW5ndGgpIHRocm93IG5ldyBVKFAsIGBJbnZhbGlkIFF1ZXJ5LiBBIG5vbi1lbXB0eSBhcnJheSBpcyByZXF1aXJlZCBmb3IgJyR7ZS50b1N0cmluZygpfScgZmlsdGVycy5gKTtcbiAgICBpZiAodC5sZW5ndGggPiAxMCkgdGhyb3cgbmV3IFUoUCwgYEludmFsaWQgUXVlcnkuICcke2UudG9TdHJpbmcoKX0nIGZpbHRlcnMgc3VwcG9ydCBhIG1heGltdW0gb2YgMTAgZWxlbWVudHMgaW4gdGhlIHZhbHVlIGFycmF5LmApO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIG9wZXJhdG9yLCByZXR1cm5zIHRoZSBzZXQgb2Ygb3BlcmF0b3JzIHRoYXQgY2Fubm90IGJlIHVzZWQgd2l0aCBpdC5cbiAqXG4gKiBPcGVyYXRvcnMgaW4gYSBxdWVyeSBtdXN0IGFkaGVyZSB0byB0aGUgZm9sbG93aW5nIHNldCBvZiBydWxlczpcbiAqIDEuIE9ubHkgb25lIGFycmF5IG9wZXJhdG9yIGlzIGFsbG93ZWQuXG4gKiAyLiBPbmx5IG9uZSBkaXNqdW5jdGl2ZSBvcGVyYXRvciBpcyBhbGxvd2VkLlxuICogMy4gYE5PVF9FUVVBTGAgY2Fubm90IGJlIHVzZWQgd2l0aCBhbm90aGVyIGBOT1RfRVFVQUxgIG9wZXJhdG9yLlxuICogNC4gYE5PVF9JTmAgY2Fubm90IGJlIHVzZWQgd2l0aCBhcnJheSwgZGlzanVuY3RpdmUsIG9yIGBOT1RfRVFVQUxgIG9wZXJhdG9ycy5cbiAqXG4gKiBBcnJheSBvcGVyYXRvcnM6IGBBUlJBWV9DT05UQUlOU2AsIGBBUlJBWV9DT05UQUlOU19BTllgXG4gKiBEaXNqdW5jdGl2ZSBvcGVyYXRvcnM6IGBJTmAsIGBBUlJBWV9DT05UQUlOU19BTllgLCBgTk9UX0lOYFxuICovIGZ1bmN0aW9uIExyKHQsIGUpIHtcbiAgICBpZiAoZS5pc0luZXF1YWxpdHkoKSkge1xuICAgICAgICBjb25zdCBuID0gX2UodCksIHIgPSBlLmZpZWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gbiAmJiAhbi5pc0VxdWFsKHIpKSB0aHJvdyBuZXcgVShQLCBgSW52YWxpZCBxdWVyeS4gQWxsIHdoZXJlIGZpbHRlcnMgd2l0aCBhbiBpbmVxdWFsaXR5ICg8LCA8PSwgIT0sIG5vdC1pbiwgPiwgb3IgPj0pIG11c3QgYmUgb24gdGhlIHNhbWUgZmllbGQuIEJ1dCB5b3UgaGF2ZSBpbmVxdWFsaXR5IGZpbHRlcnMgb24gJyR7bi50b1N0cmluZygpfScgYW5kICcke3IudG9TdHJpbmcoKX0nYCk7XG4gICAgICAgIGNvbnN0IHMgPSBnZSh0KTtcbiAgICAgICAgbnVsbCAhPT0gcyAmJiBNcih0LCByLCBzKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIHQpIGZvciAoY29uc3QgdCBvZiBuLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSkgaWYgKGUuaW5kZXhPZih0Lm9wKSA+PSAwKSByZXR1cm4gdC5vcDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSh0LmZpbHRlcnMsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovIDpcbiAgICAgICAgICAgIHJldHVybiBbIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8gLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyBdO1xuXG4gICAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gOlxuICAgICAgICAgICAgcmV0dXJuIFsgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovICwgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8gLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyBdO1xuXG4gICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gOlxuICAgICAgICAgICAgcmV0dXJuIFsgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8gLCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyBdO1xuXG4gICAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLyA6XG4gICAgICAgICAgICByZXR1cm4gWyBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gLCBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLyAsIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyAsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovIF07XG5cbiAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovIDpcbiAgICAgICAgICAgIHJldHVybiBbIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyAsIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovICwgXCJpblwiIC8qIE9wZXJhdG9yLklOICovICwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovIF07XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfShlLm9wKSk7XG4gICAgaWYgKG51bGwgIT09IG4pIFxuICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGl0J3MgYSBkdXBsaWNhdGUgb3AgdG8gZ2l2ZSBhIHNsaWdodGx5IGNsZWFyZXIgZXJyb3IgbWVzc2FnZS5cbiAgICB0aHJvdyBuID09PSBlLm9wID8gbmV3IFUoUCwgYEludmFsaWQgcXVlcnkuIFlvdSBjYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgJyR7ZS5vcC50b1N0cmluZygpfScgZmlsdGVyLmApIDogbmV3IFUoUCwgYEludmFsaWQgcXVlcnkuIFlvdSBjYW5ub3QgdXNlICcke2Uub3AudG9TdHJpbmcoKX0nIGZpbHRlcnMgd2l0aCAnJHtuLnRvU3RyaW5nKCl9JyBmaWx0ZXJzLmApO1xufVxuXG5mdW5jdGlvbiBNcih0LCBlLCBuKSB7XG4gICAgaWYgKCFuLmlzRXF1YWwoZSkpIHRocm93IG5ldyBVKFAsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgaGF2ZSBhIHdoZXJlIGZpbHRlciB3aXRoIGFuIGluZXF1YWxpdHkgKDwsIDw9LCAhPSwgbm90LWluLCA+LCBvciA+PSkgb24gZmllbGQgJyR7ZS50b1N0cmluZygpfScgYW5kIHNvIHlvdSBtdXN0IGFsc28gdXNlICcke2UudG9TdHJpbmcoKX0nIGFzIHlvdXIgZmlyc3QgYXJndW1lbnQgdG8gb3JkZXJCeSgpLCBidXQgeW91ciBmaXJzdCBvcmRlckJ5KCkgaXMgb24gZmllbGQgJyR7bi50b1N0cmluZygpfScgaW5zdGVhZC5gKTtcbn1cblxuZnVuY3Rpb24gVXIodCwgZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiB2ciB8fCBlIGluc3RhbmNlb2YgRXIpKSB0aHJvdyBuZXcgVShQLCBgRnVuY3Rpb24gJHt0fSgpIHJlcXVpcmVzIEFwcGxpYWJsZUNvbnN0cmFpbnRzIGNyZWF0ZWQgd2l0aCBhIGNhbGwgdG8gJ3doZXJlKC4uLiknLCAnb3IoLi4uKScsIG9yICdhbmQoLi4uKScuYCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnZlcnRzIGN1c3RvbSBtb2RlbCBvYmplY3Qgb2YgdHlwZSBUIGludG8gYERvY3VtZW50RGF0YWAgYnkgYXBwbHlpbmcgdGhlXG4gKiBjb252ZXJ0ZXIgaWYgaXQgZXhpc3RzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIGNvbnZlcnRpbmcgdXNlciBvYmplY3RzIHRvIGBEb2N1bWVudERhdGFgXG4gKiBiZWNhdXNlIHdlIHdhbnQgdG8gcHJvdmlkZSB0aGUgdXNlciB3aXRoIGEgbW9yZSBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIGlmXG4gKiB0aGVpciBgc2V0KClgIG9yIGZhaWxzIGR1ZSB0byBpbnZhbGlkIGRhdGEgb3JpZ2luYXRpbmcgZnJvbSBhIGB0b0ZpcmVzdG9yZSgpYFxuICogY2FsbC5cbiAqL1xuZnVuY3Rpb24ganIodCwgZSwgbikge1xuICAgIGxldCByO1xuICAgIC8vIENhc3QgdG8gYGFueWAgaW4gb3JkZXIgdG8gc2F0aXNmeSB0aGUgdW5pb24gdHlwZSBjb25zdHJhaW50IG9uXG4gICAgLy8gdG9GaXJlc3RvcmUoKS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiByID0gdCA/IG4gJiYgKG4ubWVyZ2UgfHwgbi5tZXJnZUZpZWxkcykgPyB0LnRvRmlyZXN0b3JlKGUsIG4pIDogdC50b0ZpcmVzdG9yZShlKSA6IGUsIFxuICAgIHI7XG59XG5cbmNsYXNzIEJyIGV4dGVuZHMgY2xhc3Mge1xuICAgIGNvbnZlcnRWYWx1ZSh0LCBlID0gXCJub25lXCIpIHtcbiAgICAgICAgc3dpdGNoICh4dCh0KSkge1xuICAgICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovIDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi8gOlxuICAgICAgICAgICAgcmV0dXJuIHQuYm9vbGVhblZhbHVlO1xuXG4gICAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLyA6XG4gICAgICAgICAgICByZXR1cm4gUnQodC5pbnRlZ2VyVmFsdWUgfHwgdC5kb3VibGVWYWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovIDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAodC50aW1lc3RhbXBWYWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovIDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTZXJ2ZXJUaW1lc3RhbXAodCwgZSk7XG5cbiAgICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovIDpcbiAgICAgICAgICAgIHJldHVybiB0LnN0cmluZ1ZhbHVlO1xuXG4gICAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi8gOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ5dGVzKFB0KHQuYnl0ZXNWYWx1ZSkpO1xuXG4gICAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLyA6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0UmVmZXJlbmNlKHQucmVmZXJlbmNlVmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovIDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRHZW9Qb2ludCh0Lmdlb1BvaW50VmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovIDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRBcnJheSh0LmFycmF5VmFsdWUsIGUpO1xuXG4gICAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi8gOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE9iamVjdCh0Lm1hcFZhbHVlLCBlKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBiKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udmVydE9iamVjdCh0LCBlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB7fTtcbiAgICAgICAgcmV0dXJuIEV0KHQuZmllbGRzLCAoKHQsIHIpID0+IHtcbiAgICAgICAgICAgIG5bdF0gPSB0aGlzLmNvbnZlcnRWYWx1ZShyLCBlKTtcbiAgICAgICAgfSkpLCBuO1xuICAgIH1cbiAgICBjb252ZXJ0R2VvUG9pbnQodCkge1xuICAgICAgICByZXR1cm4gbmV3IExuKFJ0KHQubGF0aXR1ZGUpLCBSdCh0LmxvbmdpdHVkZSkpO1xuICAgIH1cbiAgICBjb252ZXJ0QXJyYXkodCwgZSkge1xuICAgICAgICByZXR1cm4gKHQudmFsdWVzIHx8IFtdKS5tYXAoKHQgPT4gdGhpcy5jb252ZXJ0VmFsdWUodCwgZSkpKTtcbiAgICB9XG4gICAgY29udmVydFNlcnZlclRpbWVzdGFtcCh0LCBlKSB7XG4gICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgIGNhc2UgXCJwcmV2aW91c1wiOlxuICAgICAgICAgICAgY29uc3QgbiA9IE50KHQpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gbiA/IG51bGwgOiB0aGlzLmNvbnZlcnRWYWx1ZShuLCBlKTtcblxuICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRpbWVzdGFtcChEdCh0KSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udmVydFRpbWVzdGFtcCh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBBdCh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWdChlLnNlY29uZHMsIGUubmFub3MpO1xuICAgIH1cbiAgICBjb252ZXJ0RG9jdW1lbnRLZXkodCwgZSkge1xuICAgICAgICBjb25zdCBuID0gdHQuZnJvbVN0cmluZyh0KTtcbiAgICAgICAgRShjbihuKSk7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgWChuLmdldCgxKSwgbi5nZXQoMykpLCBzID0gbmV3IHJ0KG4ucG9wRmlyc3QoNSkpO1xuICAgICAgICByZXR1cm4gci5pc0VxdWFsKGUpIHx8IFxuICAgICAgICAvLyBUT0RPKGIvNjQxMzAyMDIpOiBTb21laG93IHN1cHBvcnQgZm9yZWlnbiByZWZlcmVuY2VzLlxuICAgICAgICBnKGBEb2N1bWVudCAke3N9IGNvbnRhaW5zIGEgZG9jdW1lbnQgcmVmZXJlbmNlIHdpdGhpbiBhIGRpZmZlcmVudCBkYXRhYmFzZSAoJHtyLnByb2plY3RJZH0vJHtyLmRhdGFiYXNlfSkgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC4gSXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVmZXJlbmNlIGluIHRoZSBjdXJyZW50IGRhdGFiYXNlICgke2UucHJvamVjdElkfS8ke2UuZGF0YWJhc2V9KSBpbnN0ZWFkLmApLCBcbiAgICAgICAgcztcbiAgICB9XG59IHtcbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHN1cGVyKCksIHRoaXMuZmlyZXN0b3JlID0gdDtcbiAgICB9XG4gICAgY29udmVydEJ5dGVzKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBxbih0KTtcbiAgICB9XG4gICAgY29udmVydFJlZmVyZW5jZSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleSh0LCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XG4gICAgICAgIHJldHVybiBuZXcgUG4odGhpcy5maXJlc3RvcmUsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGUgc3BlY2lmaWVkIGRvY3VtZW50IHJlZmVyZW5jZS5cbiAqXG4gKiBBbGwgZG9jdW1lbnRzIGFyZSBkaXJlY3RseSBmZXRjaGVkIGZyb20gdGhlIHNlcnZlciwgZXZlbiBpZiB0aGUgZG9jdW1lbnQgd2FzXG4gKiBwcmV2aW91c2x5IHJlYWQgb3IgbW9kaWZpZWQuIFJlY2VudCBtb2RpZmljYXRpb25zIGFyZSBvbmx5IHJlZmxlY3RlZCBpbiB0aGVcbiAqIHJldHJpZXZlZCBgRG9jdW1lbnRTbmFwc2hvdGAgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlbiBhcHBsaWVkIGJ5IHRoZVxuICogYmFja2VuZC4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGUgcmVhZCBmYWlscy4gSWYgeW91IGxpa2UgdG8gdXNlXG4gKiBjYWNoaW5nIG9yIHNlZSBsb2NhbCBtb2RpZmljYXRpb25zLCBwbGVhc2UgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2Ugb2YgdGhlIGRvY3VtZW50IHRvIGZldGNoLlxuICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGUgY3VycmVudFxuICogZG9jdW1lbnQgY29udGVudHMuXG4gKi8gZnVuY3Rpb24gUXIodCkge1xuICAgIGNvbnN0IGUgPSB5bigodCA9IGN0KHQsIFBuKSkuZmlyZXN0b3JlKSwgbiA9IG5ldyBCcih0LmZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGRuKGUsIFsgdC5fa2V5IF0pLnRoZW4oKGUgPT4ge1xuICAgICAgICBFKDEgPT09IGUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgciA9IGVbMF07XG4gICAgICAgIHJldHVybiBuZXcgZnIodC5maXJlc3RvcmUsIG4sIHQuX2tleSwgci5pc0ZvdW5kRG9jdW1lbnQoKSA/IHIgOiBudWxsLCB0LmNvbnZlcnRlcik7XG4gICAgfSkpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIHtAbGluayBRdWVyeVNuYXBzaG90fS5cbiAqXG4gKiBBbGwgcXVlcmllcyBhcmUgZXhlY3V0ZWQgZGlyZWN0bHkgYnkgdGhlIHNlcnZlciwgZXZlbiBpZiB0aGUgdGhlIHF1ZXJ5IHdhc1xuICogcHJldmlvdXNseSBleGVjdXRlZC4gUmVjZW50IG1vZGlmaWNhdGlvbnMgYXJlIG9ubHkgcmVmbGVjdGVkIGluIHRoZSByZXRyaWV2ZWRcbiAqIHJlc3VsdHMgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlbiBhcHBsaWVkIGJ5IHRoZSBiYWNrZW5kLiBJZiB0aGUgY2xpZW50IGlzXG4gKiBvZmZsaW5lLCB0aGUgb3BlcmF0aW9uIGZhaWxzLiBUbyBzZWUgcHJldmlvdXNseSBjYWNoZWQgcmVzdWx0IGFuZCBsb2NhbFxuICogbW9kaWZpY2F0aW9ucywgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIGBRdWVyeWAgdG8gZXhlY3V0ZS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi8gZnVuY3Rpb24genIodCkge1xuICAgICFmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmIChcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyA9PT0gdC5saW1pdFR5cGUgJiYgMCA9PT0gdC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoKSB0aHJvdyBuZXcgVShrLCBcImxpbWl0VG9MYXN0KCkgcXVlcmllcyByZXF1aXJlIHNwZWNpZnlpbmcgYXQgbGVhc3Qgb25lIG9yZGVyQnkoKSBjbGF1c2VcIik7XG4gICAgfSgodCA9IGN0KHQsIFZuKSkuX3F1ZXJ5KTtcbiAgICBjb25zdCBlID0geW4odC5maXJlc3RvcmUpLCBuID0gbmV3IEJyKHQuZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gd24oZSwgdC5fcXVlcnkpLnRoZW4oKGUgPT4ge1xuICAgICAgICBjb25zdCByID0gZS5tYXAoKGUgPT4gbmV3IGRyKHQuZmlyZXN0b3JlLCBuLCBlLmtleSwgZSwgdC5jb252ZXJ0ZXIpKSk7XG4gICAgICAgIHJldHVybiBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyA9PT0gdC5fcXVlcnkubGltaXRUeXBlICYmIFxuICAgICAgICAvLyBMaW1pdCB0byBsYXN0IHF1ZXJpZXMgcmV2ZXJzZSB0aGUgb3JkZXJCeSBjb25zdHJhaW50IHRoYXQgd2FzXG4gICAgICAgIC8vIHNwZWNpZmllZCBieSB0aGUgdXNlci4gQXMgc3VjaCwgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBvcmRlciBvZiB0aGVcbiAgICAgICAgLy8gcmVzdWx0cyB0byByZXR1cm4gdGhlIGRvY3VtZW50cyBpbiB0aGUgZXhwZWN0ZWQgb3JkZXIuXG4gICAgICAgIHIucmV2ZXJzZSgpLCBuZXcgd3IodCwgcik7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBXcih0LCBlLCBuKSB7XG4gICAgY29uc3QgciA9IGpyKCh0ID0gY3QodCwgUG4pKS5jb252ZXJ0ZXIsIGUsIG4pLCBzID0gR24oV24odC5maXJlc3RvcmUpLCBcInNldERvY1wiLCB0Ll9rZXksIHIsIG51bGwgIT09IHQuY29udmVydGVyLCBuKTtcbiAgICByZXR1cm4gZm4oeW4odC5maXJlc3RvcmUpLCBbIHMudG9NdXRhdGlvbih0Ll9rZXksIEZlLm5vbmUoKSkgXSk7XG59XG5cbmZ1bmN0aW9uIEdyKHQsIGUsIG4sIC4uLnIpIHtcbiAgICBjb25zdCBzID0gV24oKHQgPSBjdCh0LCBQbikpLmZpcmVzdG9yZSk7XG4gICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcbiAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgIGxldCBpO1xuICAgIGkgPSBcInN0cmluZ1wiID09IHR5cGVvZiAoZSA9IGwoZSkpIHx8IGUgaW5zdGFuY2VvZiBPbiA/IGVyKHMsIFwidXBkYXRlRG9jXCIsIHQuX2tleSwgZSwgbiwgcikgOiB0cihzLCBcInVwZGF0ZURvY1wiLCB0Ll9rZXksIGUpO1xuICAgIHJldHVybiBmbih5bih0LmZpcmVzdG9yZSksIFsgaS50b011dGF0aW9uKHQuX2tleSwgRmUuZXhpc3RzKCEwKSkgXSk7XG59XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHNwZWNpZmllZCBgRG9jdW1lbnRSZWZlcmVuY2VgLlxuICpcbiAqIFRoZSBkZWxldGlvbiB3aWxsIG9ubHkgYmUgcmVmbGVjdGVkIGluIGRvY3VtZW50IHJlYWRzIHRoYXQgb2NjdXIgYWZ0ZXIgdGhlXG4gKiByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzLiBJZiB0aGUgY2xpZW50IGlzIG9mZmxpbmUsIHRoZVxuICogZGVsZXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXG4gKiB1bnRpbCB0aGUgY2xpZW50IGlzIG9ubGluZSwgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBkZWxldGUuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCBvbmNlIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBzdWNjZXNzZnVsbHlcbiAqIGRlbGV0ZWQgZnJvbSB0aGUgYmFja2VuZC5cbiAqLyBmdW5jdGlvbiBLcih0KSB7XG4gICAgcmV0dXJuIGZuKHluKCh0ID0gY3QodCwgUG4pKS5maXJlc3RvcmUpLCBbIG5ldyBPZSh0Ll9rZXksIEZlLm5vbmUoKSkgXSk7XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGRvY3VtZW50IHRvIHNwZWNpZmllZCBgQ29sbGVjdGlvblJlZmVyZW5jZWAgd2l0aCB0aGUgZ2l2ZW4gZGF0YSxcbiAqIGFzc2lnbmluZyBpdCBhIGRvY3VtZW50IElEIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogVGhlIHJlc3VsdCBvZiB0aGlzIHdyaXRlIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdCBvY2N1clxuICogYWZ0ZXIgdGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMuIElmIHRoZSBjbGllbnQgaXMgb2ZmbGluZSwgdGhlXG4gKiB3cml0ZSBmYWlscy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGxvY2FsIG1vZGlmaWNhdGlvbnMgb3IgYnVmZmVyIHdyaXRlc1xuICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgY29sbGVjdGlvbiB0byBhZGQgdGhpcyBkb2N1bWVudCB0by5cbiAqIEBwYXJhbSBkYXRhIC0gQW4gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgZm9yIHRoZSBuZXcgZG9jdW1lbnQuXG4gKiBAdGhyb3dzIEVycm9yIC0gSWYgdGhlIHByb3ZpZGVkIGlucHV0IGlzIG5vdCBhIHZhbGlkIEZpcmVzdG9yZSBkb2N1bWVudC5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZVxuICogbmV3bHkgY3JlYXRlZCBkb2N1bWVudCBhZnRlciBpdCBoYXMgYmVlbiB3cml0dGVuIHRvIHRoZSBiYWNrZW5kLlxuICovIGZ1bmN0aW9uIFlyKHQsIGUpIHtcbiAgICBjb25zdCBuID0gRm4odCA9IGN0KHQsICRuKSksIHIgPSBqcih0LmNvbnZlcnRlciwgZSksIHMgPSBHbihXbih0LmZpcmVzdG9yZSksIFwiYWRkRG9jXCIsIG4uX2tleSwgciwgbnVsbCAhPT0gbi5jb252ZXJ0ZXIsIHt9KTtcbiAgICByZXR1cm4gZm4oeW4odC5maXJlc3RvcmUpLCBbIHMudG9NdXRhdGlvbihuLl9rZXksIEZlLmV4aXN0cyghMSkpIF0pLnRoZW4oKCgpID0+IG4pKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnksXG4gKiB3aXRob3V0IGFjdHVhbGx5IGRvd25sb2FkaW5nIHRoZSBkb2N1bWVudHMuXG4gKlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjb3VudCB0aGUgZG9jdW1lbnRzIGlzIGVmZmljaWVudCBiZWNhdXNlIG9ubHkgdGhlXG4gKiBmaW5hbCBjb3VudCwgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGlzIGRvd25sb2FkZWQuIFRoaXMgZnVuY3Rpb24gY2FuIGV2ZW5cbiAqIGNvdW50IHRoZSBkb2N1bWVudHMgaWYgdGhlIHJlc3VsdCBzZXQgd291bGQgYmUgcHJvaGliaXRpdmVseSBsYXJnZSB0b1xuICogZG93bmxvYWQgZW50aXJlbHkgKGUuZy4gdGhvdXNhbmRzIG9mIGRvY3VtZW50cykuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHdob3NlIHJlc3VsdCBzZXQgc2l6ZSB0byBjYWxjdWxhdGUuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGNvdW50OyB0aGUgY291bnQgY2FuIGJlXG4gKiByZXRyaWV2ZWQgZnJvbSBgc25hcHNob3QuZGF0YSgpLmNvdW50YCwgd2hlcmUgYHNuYXBzaG90YCBpcyB0aGVcbiAqIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byB3aGljaCB0aGUgcmV0dXJuZWQgUHJvbWlzZSByZXNvbHZlcy5cbiAqLyBmdW5jdGlvbiBIcih0KSB7XG4gICAgY29uc3QgZSA9IGN0KHQuZmlyZXN0b3JlLCBfbiksIG4gPSB5bihlKSwgciA9IG5ldyBCcihlKTtcbiAgICByZXR1cm4gbmV3IFJuKHQsIG4sIHIpLnJ1bigpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHR3byBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2VzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBUd28gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIGluc3RhbmNlcyBhcmUgY29uc2lkZXJlZCBcImVxdWFsXCIgaWYgdGhleSBoYXZlXG4gKiB1bmRlcmx5aW5nIHF1ZXJpZXMgdGhhdCBjb21wYXJlIGVxdWFsLCBhbmQgdGhlIHNhbWUgZGF0YS5cbiAqXG4gKiBAcGFyYW0gbGVmdCAtIFRoZSBmaXJzdCBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIFRoZSBzZWNvbmQgYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIGNvbXBhcmUuXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBcImVxdWFsXCIsIGFzIGRlZmluZWQgYWJvdmUsIG9yIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqLyBmdW5jdGlvbiBKcih0LCBlKSB7XG4gICAgcmV0dXJuIFNuKHQucXVlcnksIGUucXVlcnkpICYmIGYodC5kYXRhKCksIGUuZGF0YSgpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIHNlbnRpbmVsIGZvciB1c2Ugd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IG9yXG4gKiB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IHdpdGggYHttZXJnZTogdHJ1ZX1gIHRvIG1hcmsgYSBmaWVsZCBmb3IgZGVsZXRpb24uXG4gKi8gZnVuY3Rpb24gWHIoKSB7XG4gICAgcmV0dXJuIG5ldyBLbihcImRlbGV0ZUZpZWxkXCIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzZW50aW5lbCB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRvXG4gKiBpbmNsdWRlIGEgc2VydmVyLWdlbmVyYXRlZCB0aW1lc3RhbXAgaW4gdGhlIHdyaXR0ZW4gZGF0YS5cbiAqLyBmdW5jdGlvbiBacigpIHtcbiAgICByZXR1cm4gbmV3IEhuKFwic2VydmVyVGltZXN0YW1wXCIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byB1bmlvbiB0aGUgZ2l2ZW4gZWxlbWVudHMgd2l0aCBhbnkgYXJyYXlcbiAqIHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIHNlcnZlci4gRWFjaCBzcGVjaWZpZWQgZWxlbWVudCB0aGF0IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QgaW4gdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC4gSWYgdGhlIGZpZWxkIGJlaW5nXG4gKiBtb2RpZmllZCBpcyBub3QgYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgZXhhY3RseSB0aGUgc3BlY2lmaWVkIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byB1bmlvbiBpbnRvIHRoZSBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxuICogYHVwZGF0ZURvYygpYC5cbiAqLyBmdW5jdGlvbiB0cyguLi50KSB7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgYWN0dWFsbHkgcGFyc2UgdGhlIGRhdGEgdW50aWwgaXQncyB1c2VkIGluIHNldCgpIG9yXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cbiAgICByZXR1cm4gbmV3IEpuKFwiYXJyYXlVbmlvblwiLCB0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIChzZXREb2M6MSl9IG9yIHtAbGlua1xuICogdXBkYXRlRG9jOjF9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byByZW1vdmUgdGhlIGdpdmVuIGVsZW1lbnRzIGZyb20gYW55XG4gKiBhcnJheSB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSBzZXJ2ZXIuIEFsbCBpbnN0YW5jZXMgb2YgZWFjaCBlbGVtZW50XG4gKiBzcGVjaWZpZWQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGFycmF5LiBJZiB0aGUgZmllbGQgYmVpbmcgbW9kaWZpZWQgaXMgbm90XG4gKiBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudHMgLSBUaGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5LlxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXG4gKiBgdXBkYXRlRG9jKClgXG4gKi8gZnVuY3Rpb24gZXMoLi4udCkge1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXG4gICAgcmV0dXJuIG5ldyBYbihcImFycmF5UmVtb3ZlXCIsIHQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xuICogQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRoYXQgdGVsbHMgdGhlIHNlcnZlciB0byBpbmNyZW1lbnQgdGhlIGZpZWxkJ3MgY3VycmVudCB2YWx1ZSBieVxuICogdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIElmIGVpdGhlciB0aGUgb3BlcmFuZCBvciB0aGUgY3VycmVudCBmaWVsZCB2YWx1ZSB1c2VzIGZsb2F0aW5nIHBvaW50XG4gKiBwcmVjaXNpb24sIGFsbCBhcml0aG1ldGljIGZvbGxvd3MgSUVFRSA3NTQgc2VtYW50aWNzLiBJZiBib3RoIHZhbHVlcyBhcmVcbiAqIGludGVnZXJzLCB2YWx1ZXMgb3V0c2lkZSBvZiBKYXZhU2NyaXB0J3Mgc2FmZSBudW1iZXIgcmFuZ2VcbiAqIChgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJgIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmApIGFyZSBhbHNvIHN1YmplY3QgdG9cbiAqIHByZWNpc2lvbiBsb3NzLiBGdXJ0aGVybW9yZSwgb25jZSBwcm9jZXNzZWQgYnkgdGhlIEZpcmVzdG9yZSBiYWNrZW5kLCBhbGxcbiAqIGludGVnZXIgb3BlcmF0aW9ucyBhcmUgY2FwcGVkIGJldHdlZW4gLTJeNjMgYW5kIDJeNjMtMS5cbiAqXG4gKiBJZiB0aGUgY3VycmVudCBmaWVsZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSBgbnVtYmVyYCwgb3IgaWYgdGhlIGZpZWxkIGRvZXMgbm90XG4gKiB5ZXQgZXhpc3QsIHRoZSB0cmFuc2Zvcm1hdGlvbiBzZXRzIHRoZSBmaWVsZCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIG4gLSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IGJ5LlxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXG4gKiBgdXBkYXRlRG9jKClgXG4gKi8gZnVuY3Rpb24gbnModCkge1xuICAgIHJldHVybiBuZXcgWm4oXCJpbmNyZW1lbnRcIiwgdCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgd3JpdGUgYmF0Y2gsIHVzZWQgdG8gcGVyZm9ybSBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXG4gKlxuICogQSBgV3JpdGVCYXRjaGAgb2JqZWN0IGNhbiBiZSBhY3F1aXJlZCBieSBjYWxsaW5nIHtAbGluayB3cml0ZUJhdGNofS4gSXRcbiAqIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFkZGluZyB3cml0ZXMgdG8gdGhlIHdyaXRlIGJhdGNoLiBOb25lIG9mIHRoZSB3cml0ZXNcbiAqIHdpbGwgYmUgY29tbWl0dGVkIChvciB2aXNpYmxlIGxvY2FsbHkpIHVudGlsIHtAbGluayBXcml0ZUJhdGNoLmNvbW1pdH0gaXNcbiAqIGNhbGxlZC5cbiAqLyBjbGFzcyBycyB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IHQsIHRoaXMuX2NvbW1pdEhhbmRsZXIgPSBlLCB0aGlzLl9tdXRhdGlvbnMgPSBbXSwgdGhpcy5fY29tbWl0dGVkID0gITEsIFxuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gV24odCk7XG4gICAgfVxuICAgIHNldCh0LCBlLCBuKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xuICAgICAgICBjb25zdCByID0gc3ModCwgdGhpcy5fZmlyZXN0b3JlKSwgcyA9IGpyKHIuY29udmVydGVyLCBlLCBuKSwgaSA9IEduKHRoaXMuX2RhdGFSZWFkZXIsIFwiV3JpdGVCYXRjaC5zZXRcIiwgci5fa2V5LCBzLCBudWxsICE9PSByLmNvbnZlcnRlciwgbik7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhdGlvbnMucHVzaChpLnRvTXV0YXRpb24oci5fa2V5LCBGZS5ub25lKCkpKSwgdGhpcztcbiAgICB9XG4gICAgdXBkYXRlKHQsIGUsIG4sIC4uLnIpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIGNvbnN0IHMgPSBzcyh0LCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgIHJldHVybiBpID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgKGUgPSBsKGUpKSB8fCBlIGluc3RhbmNlb2YgT24gPyBlcih0aGlzLl9kYXRhUmVhZGVyLCBcIldyaXRlQmF0Y2gudXBkYXRlXCIsIHMuX2tleSwgZSwgbiwgcikgOiB0cih0aGlzLl9kYXRhUmVhZGVyLCBcIldyaXRlQmF0Y2gudXBkYXRlXCIsIHMuX2tleSwgZSksIFxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMucHVzaChpLnRvTXV0YXRpb24ocy5fa2V5LCBGZS5leGlzdHMoITApKSksIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXG4gICAgICogQHJldHVybnMgVGhpcyBgV3JpdGVCYXRjaGAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi8gICAgZGVsZXRlKHQpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIGNvbnN0IGUgPSBzcyh0LCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zLmNvbmNhdChuZXcgT2UoZS5fa2V5LCBGZS5ub25lKCkpKSwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tbWl0cyBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGlzIHdyaXRlIGJhdGNoIGFzIGEgc2luZ2xlIGF0b21pYyB1bml0LlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdCBvZiB0aGVzZSB3cml0ZXMgd2lsbCBvbmx5IGJlIHJlZmxlY3RlZCBpbiBkb2N1bWVudCByZWFkcyB0aGF0XG4gICAgICogb2NjdXIgYWZ0ZXIgdGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMuIElmIHRoZSBjbGllbnQgaXMgb2ZmbGluZSwgdGhlXG4gICAgICogd3JpdGUgZmFpbHMuIElmIHlvdSB3b3VsZCBsaWtlIHRvIHNlZSBsb2NhbCBtb2RpZmljYXRpb25zIG9yIGJ1ZmZlciB3cml0ZXNcbiAgICAgKiB1bnRpbCB0aGUgY2xpZW50IGlzIG9ubGluZSwgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCBvbmNlIGFsbCBvZiB0aGUgd3JpdGVzIGluIHRoZSBiYXRjaCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byB0aGUgYmFja2VuZCBhcyBhbiBhdG9taWMgdW5pdCAobm90ZSB0aGF0IGl0IHdvbid0XG4gICAgICogcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXG4gICAgICovICAgIGNvbW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpLCB0aGlzLl9jb21taXR0ZWQgPSAhMCwgdGhpcy5fbXV0YXRpb25zLmxlbmd0aCA+IDAgPyB0aGlzLl9jb21taXRIYW5kbGVyKHRoaXMuX211dGF0aW9ucykgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgX3ZlcmlmeU5vdENvbW1pdHRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbW1pdHRlZCkgdGhyb3cgbmV3IFUoUywgXCJBIHdyaXRlIGJhdGNoIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlciBjb21taXQoKSBoYXMgYmVlbiBjYWxsZWQuXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3ModCwgZSkge1xuICAgIGlmICgodCA9IGwodCkpLmZpcmVzdG9yZSAhPT0gZSkgdGhyb3cgbmV3IFUoUCwgXCJQcm92aWRlZCBkb2N1bWVudCByZWZlcmVuY2UgaXMgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgaW5zdGFuY2UuXCIpO1xuICAgIHJldHVybiB0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB3cml0ZSBiYXRjaCwgdXNlZCBmb3IgcGVyZm9ybWluZyBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGVcbiAqIGF0b21pYyBvcGVyYXRpb24uIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSBXcml0ZUJhdGNoXG4gKiBpcyA1MDAuXG4gKlxuICogVGhlIHJlc3VsdCBvZiB0aGVzZSB3cml0ZXMgd2lsbCBvbmx5IGJlIHJlZmxlY3RlZCBpbiBkb2N1bWVudCByZWFkcyB0aGF0XG4gKiBvY2N1ciBhZnRlciB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGVcbiAqIHdyaXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXG4gKiB1bnRpbCB0aGUgY2xpZW50IGlzIG9ubGluZSwgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXG4gKlxuICogQHJldHVybnMgQSBgV3JpdGVCYXRjaGAgdGhhdCBjYW4gYmUgdXNlZCB0byBhdG9taWNhbGx5IGV4ZWN1dGUgbXVsdGlwbGVcbiAqIHdyaXRlcy5cbiAqLyBmdW5jdGlvbiBpcyh0KSB7XG4gICAgY29uc3QgZSA9IHluKHQgPSBjdCh0LCBfbikpO1xuICAgIHJldHVybiBuZXcgcnModCwgKHQgPT4gZm4oZSwgdCkpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW50ZXJuYWwgdHJhbnNhY3Rpb24gb2JqZWN0IHJlc3BvbnNpYmxlIGZvciBhY2N1bXVsYXRpbmcgdGhlIG11dGF0aW9ucyB0b1xuICogcGVyZm9ybSBhbmQgdGhlIGJhc2UgdmVyc2lvbnMgZm9yIGFueSBkb2N1bWVudHMgcmVhZC5cbiAqLyBjbGFzcyBvcyB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IHQsIFxuICAgICAgICAvLyBUaGUgdmVyc2lvbiBvZiBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMucmVhZFZlcnNpb25zID0gbmV3IE1hcCwgdGhpcy5tdXRhdGlvbnMgPSBbXSwgdGhpcy5jb21taXR0ZWQgPSAhMSwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRlZmVycmVkIHVzYWdlIGVycm9yIHRoYXQgb2NjdXJyZWQgcHJldmlvdXNseSBpbiB0aGlzIHRyYW5zYWN0aW9uIHRoYXRcbiAgICAgICAgICogd2lsbCBjYXVzZSB0aGUgdHJhbnNhY3Rpb24gdG8gZmFpbCBvbmNlIGl0IGFjdHVhbGx5IGNvbW1pdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RXcml0ZUVycm9yID0gbnVsbCwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgZG9jdW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHdyaXR0ZW4gaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSB3cml0ZSB0byB0aGUgc2FtZSBrZXkgaW4gYSB0cmFuc2FjdGlvbiwgYW55XG4gICAgICAgICAqIHdyaXRlcyBhZnRlciB0aGUgZmlyc3QgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzID0gbmV3IFNldDtcbiAgICB9XG4gICAgYXN5bmMgbG9va3VwKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCksIHRoaXMubXV0YXRpb25zLmxlbmd0aCA+IDApIHRocm93IG5ldyBVKFAsIFwiRmlyZXN0b3JlIHRyYW5zYWN0aW9ucyByZXF1aXJlIGFsbCByZWFkcyB0byBiZSBleGVjdXRlZCBiZWZvcmUgYWxsIHdyaXRlcy5cIik7XG4gICAgICAgIGNvbnN0IGUgPSBhd2FpdCBkbih0aGlzLmRhdGFzdG9yZSwgdCk7XG4gICAgICAgIHJldHVybiBlLmZvckVhY2goKHQgPT4gdGhpcy5yZWNvcmRWZXJzaW9uKHQpKSksIGU7XG4gICAgfVxuICAgIHNldCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGUoZS50b011dGF0aW9uKHQsIHRoaXMucHJlY29uZGl0aW9uKHQpKSksIHRoaXMud3JpdHRlbkRvY3MuYWRkKHQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh0LCBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKGUudG9NdXRhdGlvbih0LCB0aGlzLnByZWNvbmRpdGlvbkZvclVwZGF0ZSh0KSkpO1xuICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RXcml0ZUVycm9yID0gdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZCh0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBkZWxldGUodCkge1xuICAgICAgICB0aGlzLndyaXRlKG5ldyBPZSh0LCB0aGlzLnByZWNvbmRpdGlvbih0KSkpLCB0aGlzLndyaXR0ZW5Eb2NzLmFkZCh0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBhc3luYyBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpLCB0aGlzLmxhc3RXcml0ZUVycm9yKSB0aHJvdyB0aGlzLmxhc3RXcml0ZUVycm9yO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5yZWFkVmVyc2lvbnM7XG4gICAgICAgIC8vIEZvciBlYWNoIG11dGF0aW9uLCBub3RlIHRoYXQgdGhlIGRvYyB3YXMgd3JpdHRlbi5cbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9ucy5mb3JFYWNoKChlID0+IHtcbiAgICAgICAgICAgIHQuZGVsZXRlKGUua2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9KSksIFxuICAgICAgICAvLyBGb3IgZWFjaCBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGJ1dCBub3Qgd3JpdHRlbiB0bywgd2Ugd2FudCB0byBwZXJmb3JtXG4gICAgICAgIC8vIGEgYHZlcmlmeWAgb3BlcmF0aW9uLlxuICAgICAgICB0LmZvckVhY2goKCh0LCBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gcnQuZnJvbVBhdGgoZSk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9ucy5wdXNoKG5ldyBrZShuLCB0aGlzLnByZWNvbmRpdGlvbihuKSkpO1xuICAgICAgICB9KSksIGF3YWl0IGZuKHRoaXMuZGF0YXN0b3JlLCB0aGlzLm11dGF0aW9ucyksIHRoaXMuY29tbWl0dGVkID0gITA7XG4gICAgfVxuICAgIHJlY29yZFZlcnNpb24odCkge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgaWYgKHQuaXNGb3VuZERvY3VtZW50KCkpIGUgPSB0LnZlcnNpb247IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0LmlzTm9Eb2N1bWVudCgpKSB0aHJvdyBiKCk7XG4gICAgICAgICAgICAvLyBSZXByZXNlbnQgYSBkZWxldGVkIGRvYyB1c2luZyBTbmFwc2hvdFZlcnNpb24ubWluKCkuXG4gICAgICAgICAgICBlID0gb2UubWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldCh0LmtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGlmICghZS5pc0VxdWFsKG4pKSBcbiAgICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd2lsbCBmYWlsIG5vIG1hdHRlciB3aGF0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IFUocSwgXCJEb2N1bWVudCB2ZXJzaW9uIGNoYW5nZWQgYmV0d2VlbiB0d28gcmVhZHMuXCIpO1xuICAgICAgICB9IGVsc2UgdGhpcy5yZWFkVmVyc2lvbnMuc2V0KHQua2V5LnRvU3RyaW5nKCksIGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoaXMgZG9jdW1lbnQgd2hlbiBpdCB3YXMgcmVhZCBpbiB0aGlzIHRyYW5zYWN0aW9uLFxuICAgICAqIGFzIGEgcHJlY29uZGl0aW9uLCBvciBubyBwcmVjb25kaXRpb24gaWYgaXQgd2FzIG5vdCByZWFkLlxuICAgICAqLyAgICBwcmVjb25kaXRpb24odCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KHQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiAhdGhpcy53cml0dGVuRG9jcy5oYXModC50b1N0cmluZygpKSAmJiBlID8gZS5pc0VxdWFsKG9lLm1pbigpKSA/IEZlLmV4aXN0cyghMSkgOiBGZS51cGRhdGVUaW1lKGUpIDogRmUubm9uZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmVjb25kaXRpb24gZm9yIGEgZG9jdW1lbnQgaWYgdGhlIG9wZXJhdGlvbiBpcyBhbiB1cGRhdGUuXG4gICAgICovICAgIHByZWNvbmRpdGlvbkZvclVwZGF0ZSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQodC50b1N0cmluZygpKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgYSBkb2N1bWVudCBpcyB3cml0dGVuLCB3ZSB3YW50IHRvIHRha2UgaW50byBhY2NvdW50IHRoZVxuICAgICAgICAvLyByZWFkIHRpbWUgYW5kIGV4aXN0ZW5jZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy53cml0dGVuRG9jcy5oYXModC50b1N0cmluZygpKSAmJiBlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0VxdWFsKG9lLm1pbigpKSkgXG4gICAgICAgICAgICAvLyBUaGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCwgc28gZmFpbCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAvLyBUaGlzIGhhcyB0byBiZSB2YWxpZGF0ZWQgbG9jYWxseSBiZWNhdXNlIHlvdSBjYW4ndCBzZW5kIGFcbiAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbiB0aGF0IGEgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgICAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgYmFja2VuZCB3cml0ZSB0byBiZSBhbiBpbnNlcnQuIFRoaXMgaXMgdGhlIHJldmVyc2VcbiAgICAgICAgICAgIC8vIG9mIHdoYXQgd2Ugd2FudCwgc2luY2Ugd2Ugd2FudCB0byBhc3NlcnQgdGhhdCB0aGUgZG9jdW1lbnQgZG9lc24ndFxuICAgICAgICAgICAgLy8gZXhpc3QgYnV0IHRoZW4gc2VuZCB0aGUgdXBkYXRlIGFuZCBoYXZlIGl0IGZhaWwuIFNpbmNlIHdlIGNhbid0XG4gICAgICAgICAgICAvLyBleHByZXNzIHRoYXQgdG8gdGhlIGJhY2tlbmQsIHdlIGhhdmUgdG8gdmFsaWRhdGUgbG9jYWxseS5cbiAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgY2FuIGNoYW5nZSBvbmNlIHdlIGNhbiBzZW5kIHNlcGFyYXRlIHZlcmlmeSB3cml0ZXMgaW4gdGhlXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBVKFAsIFwiQ2FuJ3QgdXBkYXRlIGEgZG9jdW1lbnQgdGhhdCBkb2Vzbid0IGV4aXN0LlwiKTtcbiAgICAgICAgICAgIC8vIERvY3VtZW50IGV4aXN0cywgYmFzZSBwcmVjb25kaXRpb24gb24gZG9jdW1lbnQgdXBkYXRlIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmUudXBkYXRlVGltZShlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2N1bWVudCB3YXMgbm90IHJlYWQsIHNvIHdlIGp1c3QgdXNlIHRoZSBwcmVjb25kaXRpb25zIGZvciBhIGJsaW5kXG4gICAgICAgIC8vIHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuIEZlLmV4aXN0cyghMCk7XG4gICAgfVxuICAgIHdyaXRlKHQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKSwgdGhpcy5tdXRhdGlvbnMucHVzaCh0KTtcbiAgICB9XG4gICAgZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCkge31cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY29uc3QgdXMgPSB7XG4gICAgbWF4QXR0ZW1wdHM6IDVcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRyYW5zYWN0aW9uUnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zXG4gKiB3aXRoIGJhY2tvZmYuXG4gKi9cbmNsYXNzIGNzIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBuLCByLCBzKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IHQsIHRoaXMuZGF0YXN0b3JlID0gZSwgdGhpcy5vcHRpb25zID0gbiwgdGhpcy51cGRhdGVGdW5jdGlvbiA9IHIsIFxuICAgICAgICB0aGlzLmRlZmVycmVkID0gcywgdGhpcy55dCA9IG4ubWF4QXR0ZW1wdHMsIHRoaXMuZ3QgPSBuZXcgaG4odGhpcy5hc3luY1F1ZXVlLCBcInRyYW5zYWN0aW9uX3JldHJ5XCIgLyogVGltZXJJZC5UcmFuc2FjdGlvblJldHJ5ICovKTtcbiAgICB9XG4gICAgLyoqIFJ1bnMgdGhlIHRyYW5zYWN0aW9uIGFuZCBzZXRzIHRoZSByZXN1bHQgb24gZGVmZXJyZWQuICovICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy55dCAtPSAxLCB0aGlzLl90KCk7XG4gICAgfVxuICAgIF90KCkge1xuICAgICAgICB0aGlzLmd0LkgoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgb3ModGhpcy5kYXRhc3RvcmUpLCBlID0gdGhpcy52dCh0KTtcbiAgICAgICAgICAgIGUgJiYgZS50aGVuKChlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKCkgPT4gdC5jb21taXQoKS50aGVuKCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShlKTtcbiAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ0KHQpO1xuICAgICAgICAgICAgICAgIH0pKSkpO1xuICAgICAgICAgICAgfSkpLmNhdGNoKCh0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ0KHQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHZ0KHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLnVwZGF0ZUZ1bmN0aW9uKHQpO1xuICAgICAgICAgICAgcmV0dXJuICFodChlKSAmJiBlLmNhdGNoICYmIGUudGhlbiA/IGUgOiAodGhpcy5kZWZlcnJlZC5yZWplY3QoRXJyb3IoXCJUcmFuc2FjdGlvbiBjYWxsYmFjayBtdXN0IHJldHVybiBhIFByb21pc2VcIikpLCBcbiAgICAgICAgICAgIG51bGwpO1xuICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgcmV0cnkgZXJyb3JzIHRocm93biBieSB1c2VyIHByb3ZpZGVkIHVwZGF0ZUZ1bmN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucmVqZWN0KHQpLCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ0KHQpIHtcbiAgICAgICAgdGhpcy55dCA+IDAgJiYgdGhpcy5FdCh0KSA/ICh0aGlzLnl0IC09IDEsIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgoKSA9PiAodGhpcy5fdCgpLCBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkpKSkpIDogdGhpcy5kZWZlcnJlZC5yZWplY3QodCk7XG4gICAgfVxuICAgIEV0KHQpIHtcbiAgICAgICAgaWYgKFwiRmlyZWJhc2VFcnJvclwiID09PSB0Lm5hbWUpIHtcbiAgICAgICAgICAgIC8vIEluIHRyYW5zYWN0aW9ucywgdGhlIGJhY2tlbmQgd2lsbCBmYWlsIG91dGRhdGVkIHJlYWRzIHdpdGggRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcbiAgICAgICAgICAgIC8vIG5vbi1tYXRjaGluZyBkb2N1bWVudCB2ZXJzaW9ucyB3aXRoIEFCT1JURUQuIFRoZXNlIGVycm9ycyBzaG91bGQgYmUgcmV0cmllZC5cbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LmNvZGU7XG4gICAgICAgICAgICByZXR1cm4gXCJhYm9ydGVkXCIgPT09IGUgfHwgXCJmYWlsZWQtcHJlY29uZGl0aW9uXCIgPT09IGUgfHwgXCJhbHJlYWR5LWV4aXN0c1wiID09PSBlIHx8ICFcbiAgICAgICAgICAgIC8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXG4gKiBpbiByZXNwb25zZSB0byBhIG5vbi13cml0ZSBvcGVyYXRpb24uXG4gKlxuICogU2VlIGlzUGVybWFuZW50V3JpdGVFcnJvciBmb3IgY2xhc3NpZnlpbmcgd3JpdGUgZXJyb3JzLlxuICovXG4gICAgICAgICAgICBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYigpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFY6XG4gICAgICAgICAgICAgICAgICBjYXNlIHg6XG4gICAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICBjYXNlIEw6XG4gLy8gVW5hdXRoZW50aWNhdGVkIG1lYW5zIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggb3VyIHRva2VuIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHJldHJ5IHdpdGggbmV3IGNyZWRlbnRpYWxzIHdoaWNoIHdpbGwgaGFwcGVuIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFA6XG4gICAgICAgICAgICAgICAgICBjYXNlICQ6XG4gICAgICAgICAgICAgICAgICBjYXNlIE46XG4gICAgICAgICAgICAgICAgICBjYXNlIEQ6XG4gICAgICAgICAgICAgICAgICBjYXNlIFM6XG4gLy8gQWJvcnRlZCBtaWdodCBiZSByZXRyaWVkIGluIHNvbWUgc2NlbmFyaW9zLCBidXQgdGhhdCBpcyBkZXBlbmRhbnQgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbnRleHQgYW5kIHNob3VsZCBoYW5kbGVkIGluZGl2aWR1YWxseSBieSB0aGUgY2FsbGluZyBjb2RlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwaXMvZGVzaWduL2Vycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBxOlxuICAgICAgICAgICAgICAgICAgY2FzZSBPOlxuICAgICAgICAgICAgICAgICAgY2FzZSBrOlxuICAgICAgICAgICAgICAgICAgY2FzZSBNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFRoZSBQbGF0Zm9ybSdzICdkb2N1bWVudCcgaW1wbGVtZW50YXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLiAqLyBmdW5jdGlvbiBhcygpIHtcbiAgICAvLyBgZG9jdW1lbnRgIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlLCBlLmcuIGluIFJlYWN0TmF0aXZlIGFuZCBXZWJXb3JrZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudCA6IG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb3BlcmF0aW9uIHNjaGVkdWxlZCB0byBiZSBydW4gaW4gdGhlIGZ1dHVyZSBvbiBhbiBBc3luY1F1ZXVlLlxuICpcbiAqIEl0IGlzIGNyZWF0ZWQgdmlhIERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUoKS5cbiAqXG4gKiBTdXBwb3J0cyBjYW5jZWxsYXRpb24gKHZpYSBjYW5jZWwoKSkgYW5kIGVhcmx5IGV4ZWN1dGlvbiAodmlhIHNraXBEZWxheSgpKS5cbiAqXG4gKiBOb3RlOiBXZSBpbXBsZW1lbnQgYFByb21pc2VMaWtlYCBpbnN0ZWFkIG9mIGBQcm9taXNlYCwgYXMgdGhlIGBQcm9taXNlYCB0eXBlXG4gKiBpbiBuZXdlciB2ZXJzaW9ucyBvZiBUeXBlU2NyaXB0IGRlZmluZXMgYGZpbmFsbHlgLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluXG4gKiBJRS5cbiAqLyBjbGFzcyBocyB7XG4gICAgY29uc3RydWN0b3IodCwgZSwgbiwgciwgcykge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSB0LCB0aGlzLnRpbWVySWQgPSBlLCB0aGlzLnRhcmdldFRpbWVNcyA9IG4sIHRoaXMub3AgPSByLCB0aGlzLnJlbW92YWxDYWxsYmFjayA9IHMsIFxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IGosIHRoaXMudGhlbiA9IHRoaXMuZGVmZXJyZWQucHJvbWlzZS50aGVuLmJpbmQodGhpcy5kZWZlcnJlZC5wcm9taXNlKSwgXG4gICAgICAgIC8vIEl0J3Mgbm9ybWFsIGZvciB0aGUgZGVmZXJyZWQgcHJvbWlzZSB0byBiZSBjYW5jZWxlZCAoZHVlIHRvIGNhbmNlbGxhdGlvbilcbiAgICAgICAgLy8gYW5kIHNvIHdlIGF0dGFjaCBhIGR1bW15IGNhdGNoIGNhbGxiYWNrIHRvIGF2b2lkXG4gICAgICAgIC8vICdVbmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uV2FybmluZycgbG9nIHNwYW0uXG4gICAgICAgIHRoaXMuZGVmZXJyZWQucHJvbWlzZS5jYXRjaCgodCA9PiB7fSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgRGVsYXllZE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIHNjaGVkdWxlZCB0byBiZVxuICAgICAqIGV4ZWN1dGVkIG9uIHRoZSBwcm92aWRlZCBhc3luY1F1ZXVlIGFmdGVyIHRoZSBwcm92aWRlZCBkZWxheU1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jUXVldWUgLSBUaGUgcXVldWUgdG8gc2NoZWR1bGUgdGhlIG9wZXJhdGlvbiBvbi5cbiAgICAgKiBAcGFyYW0gaWQgLSBBIFRpbWVyIElEIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiB0aGlzIGlzLlxuICAgICAqIEBwYXJhbSBkZWxheU1zIC0gVGhlIGRlbGF5IChtcykgYmVmb3JlIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlIHNjaGVkdWxlZC5cbiAgICAgKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHJ1bi5cbiAgICAgKiBAcGFyYW0gcmVtb3ZhbENhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBvbmNlIHRoZVxuICAgICAqICAgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLCBub3RpZnlpbmcgdGhlIEFzeW5jUXVldWUgdG8gcmVtb3ZlIGl0XG4gICAgICogICBmcm9tIGl0cyBkZWxheWVkT3BlcmF0aW9ucyBsaXN0LlxuICAgICAqICAgUE9SVElORyBOT1RFOiBUaGlzIGV4aXN0cyB0byBwcmV2ZW50IG1ha2luZyByZW1vdmVEZWxheWVkT3BlcmF0aW9uKCkgYW5kXG4gICAgICogICB0aGUgRGVsYXllZE9wZXJhdGlvbiBjbGFzcyBwdWJsaWMuXG4gICAgICovICAgIHN0YXRpYyBjcmVhdGVBbmRTY2hlZHVsZSh0LCBlLCBuLCByLCBzKSB7XG4gICAgICAgIGNvbnN0IGkgPSBEYXRlLm5vdygpICsgbiwgbyA9IG5ldyBocyh0LCBlLCBpLCByLCBzKTtcbiAgICAgICAgcmV0dXJuIG8uc3RhcnQobiksIG87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdGltZXIuIFRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGNvbnN0cnVjdGlvbiBieVxuICAgICAqIGNyZWF0ZUFuZFNjaGVkdWxlKCkuXG4gICAgICovICAgIHN0YXJ0KHQpIHtcbiAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCgpID0+IHRoaXMuaGFuZGxlRGVsYXlFbGFwc2VkKCkpLCB0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVldWVzIHRoZSBvcGVyYXRpb24gdG8gcnVuIGltbWVkaWF0ZWx5IChpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJ1biBvclxuICAgICAqIGNhbmNlbGVkKS5cbiAgICAgKi8gICAgc2tpcERlbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgb3BlcmF0aW9uIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQgb3IgY2FuY2VsZWQuIFRoZVxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEFzIGxvbmcgYXMgdGhlIG9wZXJhdGlvbiBoYXMgbm90IHlldCBiZWVuIHJ1biwgY2FsbGluZyBjYW5jZWwoKSBwcm92aWRlcyBhXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSBydW4uXG4gICAgICovICAgIGNhbmNlbCh0KSB7XG4gICAgICAgIG51bGwgIT09IHRoaXMudGltZXJIYW5kbGUgJiYgKHRoaXMuY2xlYXJUaW1lb3V0KCksIHRoaXMuZGVmZXJyZWQucmVqZWN0KG5ldyBVKEEsIFwiT3BlcmF0aW9uIGNhbmNlbGxlZFwiICsgKHQgPyBcIjogXCIgKyB0IDogXCJcIikpKSk7XG4gICAgfVxuICAgIGhhbmRsZURlbGF5RWxhcHNlZCgpIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCgpID0+IG51bGwgIT09IHRoaXMudGltZXJIYW5kbGUgPyAodGhpcy5jbGVhclRpbWVvdXQoKSwgXG4gICAgICAgIHRoaXMub3AoKS50aGVuKCh0ID0+IHRoaXMuZGVmZXJyZWQucmVzb2x2ZSh0KSkpKSA6IFByb21pc2UucmVzb2x2ZSgpKSk7XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCgpIHtcbiAgICAgICAgbnVsbCAhPT0gdGhpcy50aW1lckhhbmRsZSAmJiAodGhpcy5yZW1vdmFsQ2FsbGJhY2sodGhpcyksIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySGFuZGxlKSwgXG4gICAgICAgIHRoaXMudGltZXJIYW5kbGUgPSBudWxsKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzIGxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gVGhlIGxhc3QgcHJvbWlzZSBpbiB0aGUgcXVldWUuXG4gICAgICAgIHRoaXMuSXQgPSBQcm9taXNlLnJlc29sdmUoKSwgXG4gICAgICAgIC8vIEEgbGlzdCBvZiByZXRyeWFibGUgb3BlcmF0aW9ucy4gUmV0cnlhYmxlIG9wZXJhdGlvbnMgYXJlIHJ1biBpbiBvcmRlciBhbmRcbiAgICAgICAgLy8gcmV0cmllZCB3aXRoIGJhY2tvZmYuXG4gICAgICAgIHRoaXMuVHQgPSBbXSwgXG4gICAgICAgIC8vIElzIHRoaXMgQXN5bmNRdWV1ZSBiZWluZyBzaHV0IGRvd24/IE9uY2UgaXQgaXMgc2V0IHRvIHRydWUsIGl0IHdpbGwgbm90XG4gICAgICAgIC8vIGJlIGNoYW5nZWQgYWdhaW4uXG4gICAgICAgIHRoaXMuQXQgPSAhMSwgXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgc2NoZWR1bGVkIHRvIGJlIHF1ZXVlZCBpbiB0aGUgZnV0dXJlLiBPcGVyYXRpb25zIGFyZVxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSBhcmUgcnVuIG9yIGNhbmNlbGVkLlxuICAgICAgICB0aGlzLlJ0ID0gW10sIFxuICAgICAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG4gICAgICAgIHRoaXMuUHQgPSBudWxsLCBcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hpbGUgdGhlcmUncyBhbiBvdXRzdGFuZGluZyBBc3luY1F1ZXVlIG9wZXJhdGlvbiwgdXNlZCBmb3JcbiAgICAgICAgLy8gYXNzZXJ0aW9uIHNhbml0eS1jaGVja3MuXG4gICAgICAgIHRoaXMuVnQgPSAhMSwgXG4gICAgICAgIC8vIEVuYWJsZWQgZHVyaW5nIHNodXRkb3duIG9uIFNhZmFyaSB0byBwcmV2ZW50IGZ1dHVyZSBhY2Nlc3MgdG8gSW5kZXhlZERCLlxuICAgICAgICB0aGlzLiR0ID0gITEsIFxuICAgICAgICAvLyBMaXN0IG9mIFRpbWVySWRzIHRvIGZhc3QtZm9yd2FyZCBkZWxheXMgZm9yLlxuICAgICAgICB0aGlzLk50ID0gW10sIFxuICAgICAgICAvLyBCYWNrb2ZmIHRpbWVyIHVzZWQgdG8gc2NoZWR1bGUgcmV0cmllcyBmb3IgcmV0cnlhYmxlIG9wZXJhdGlvbnNcbiAgICAgICAgdGhpcy5ndCA9IG5ldyBobih0aGlzLCBcImFzeW5jX3F1ZXVlX3JldHJ5XCIgLyogVGltZXJJZC5Bc3luY1F1ZXVlUmV0cnkgKi8pLCBcbiAgICAgICAgLy8gVmlzaWJpbGl0eSBoYW5kbGVyIHRoYXQgdHJpZ2dlcnMgYW4gaW1tZWRpYXRlIHJldHJ5IG9mIGFsbCByZXRyeWFibGVcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gTWVhbnQgdG8gc3BlZWQgdXAgcmVjb3Zlcnkgd2hlbiB3ZSByZWdhaW4gZmlsZSBzeXN0ZW0gYWNjZXNzXG4gICAgICAgIC8vIGFmdGVyIHBhZ2UgY29tZXMgaW50byBmb3JlZ3JvdW5kLlxuICAgICAgICB0aGlzLkR0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IGFzKCk7XG4gICAgICAgICAgICB0ICYmIHkoXCJBc3luY1F1ZXVlXCIsIFwiVmlzaWJpbGl0eSBzdGF0ZSBjaGFuZ2VkIHRvIFwiICsgdC52aXNpYmlsaXR5U3RhdGUpLCB0aGlzLmd0LlgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdCA9IGFzKCk7XG4gICAgICAgIHQgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0LmFkZEV2ZW50TGlzdGVuZXIgJiYgdC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLkR0KTtcbiAgICB9XG4gICAgZ2V0IGlzU2h1dHRpbmdEb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5BdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlIHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gY29tcGxldGUgKGkuZS5cbiAgICAgKiB3ZSBpZ25vcmUgdGhlIFByb21pc2UgcmVzdWx0KS5cbiAgICAgKi8gICAgZW5xdWV1ZUFuZEZvcmdldCh0KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy5lbnF1ZXVlKHQpO1xuICAgIH1cbiAgICBlbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZCh0KSB7XG4gICAgICAgIHRoaXMuRnQoKSwgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy54dCh0KTtcbiAgICB9XG4gICAgZW50ZXJSZXN0cmljdGVkTW9kZSh0KSB7XG4gICAgICAgIGlmICghdGhpcy5BdCkge1xuICAgICAgICAgICAgdGhpcy5BdCA9ICEwLCB0aGlzLiR0ID0gdCB8fCAhMTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBhcygpO1xuICAgICAgICAgICAgZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuRHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVucXVldWUodCkge1xuICAgICAgICBpZiAodGhpcy5GdCgpLCB0aGlzLkF0KSBcbiAgICAgICAgLy8gUmV0dXJuIGEgUHJvbWlzZSB3aGljaCBuZXZlciByZXNvbHZlcy5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgoKSA9PiB7fSkpO1xuICAgICAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBQcm9taXNlIHRoYXQgd2UgY2FuIHJldHVybiB0byB0aGUgY2FsbGVlLiBUaGlzXG4gICAgICAgIC8vIGFsbG93cyB1cyB0byByZXR1cm4gYSBcImhhbmdpbmcgUHJvbWlzZVwiIG9ubHkgdG8gdGhlIGNhbGxlZSBhbmQgc3RpbGxcbiAgICAgICAgLy8gYWR2YW5jZSB0aGUgcXVldWUgZXZlbiB3aGVuIHRoZSBvcGVyYXRpb24gaXMgbm90IHJ1bi5cbiAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IGo7XG4gICAgICAgIHJldHVybiB0aGlzLnh0KCgoKSA9PiB0aGlzLkF0ICYmIHRoaXMuJHQgPyBQcm9taXNlLnJlc29sdmUoKSA6ICh0KCkudGhlbihlLnJlc29sdmUsIGUucmVqZWN0KSwgXG4gICAgICAgIGUucHJvbWlzZSkpKS50aGVuKCgoKSA9PiBlLnByb21pc2UpKTtcbiAgICB9XG4gICAgZW5xdWV1ZVJldHJ5YWJsZSh0KSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZUFuZEZvcmdldCgoKCkgPT4gKHRoaXMuVHQucHVzaCh0KSwgdGhpcy5TdCgpKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBuZXh0IG9wZXJhdGlvbiBmcm9tIHRoZSByZXRyeWFibGUgcXVldWUuIElmIHRoZSBvcGVyYXRpb24gZmFpbHMsXG4gICAgICogcmVzY2hlZHVsZXMgd2l0aCBiYWNrb2ZmLlxuICAgICAqLyAgICBhc3luYyBTdCgpIHtcbiAgICAgICAgaWYgKDAgIT09IHRoaXMuVHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuVHRbMF0oKSwgdGhpcy5UdC5zaGlmdCgpLCB0aGlzLmd0LnJlc2V0KCk7XG4gICAgICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFcbiAgICAgICAgICAgICAgICAvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuICAgICAgICAgICAgICAgIC8qKiBWZXJpZmllcyB3aGV0aGVyIGBlYCBpcyBhbiBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yLiAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5hbWUgZXF1YWxpdHksIGFzIGluc3RhbmNlb2YgY2hlY2tzIG9uIGVycm9ycyBkb24ndCB3b3JrIHdpdGggZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgd3JhcCBvdGhlciBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3JcIiA9PT0gdC5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAodCkpIHRocm93IHQ7XG4gLy8gRmFpbHVyZSB3aWxsIGJlIGhhbmRsZWQgYnkgQXN5bmNRdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwiQXN5bmNRdWV1ZVwiLCBcIk9wZXJhdGlvbiBmYWlsZWQgd2l0aCByZXRyeWFibGUgZXJyb3I6IFwiICsgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlR0Lmxlbmd0aCA+IDAgJiYgXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBvcGVyYXRpb25zLCB3ZSByZS1zY2hlZHVsZSBgcmV0cnlOZXh0T3AoKWAuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBydW4gcmV0cnlhYmxlIG9wZXJhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBpbml0aWFsIGF0dGVtcHQgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZXkgYXJlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGVucXVldWVkLiBJZiwgZm9yIGV4YW1wbGUsIGBvcDFgLCBgb3AyYCwgYG9wM2AgYXJlIGVucXVldWVkIGFuZCBgb3AxYFxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gIGJlIHJlLXJ1biwgd2Ugd2lsbCBydW4gYG9wMWAsIGBvcDFgLCBgb3AyYCB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZW5xdWV1ZWQgY2FsbHMgdG8gYHJldHJ5TmV4dE9wKClgLiBgb3AzKClgIHdpbGwgdGhlbiBydW4gaW4gdGhlXG4gICAgICAgICAgICAvLyBjYWxsIHNjaGVkdWxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gU2luY2UgYGJhY2tvZmZBbmRSdW4oKWAgY2FuY2VscyBhbiBleGlzdGluZyBiYWNrb2ZmIGFuZCBzY2hlZHVsZXMgYVxuICAgICAgICAgICAgLy8gbmV3IGJhY2tvZmYgb24gZXZlcnkgY2FsbCwgdGhlcmUgaXMgb25seSBldmVyIGEgc2luZ2xlIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICB0aGlzLmd0LkgoKCgpID0+IHRoaXMuU3QoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHh0KHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuSXQudGhlbigoKCkgPT4gKHRoaXMuVnQgPSAhMCwgdCgpLmNhdGNoKCh0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuUHQgPSB0LCB0aGlzLlZ0ID0gITE7XG4gICAgICAgICAgICBjb25zdCBlID0gXG4gICAgICAgICAgICAvKipcbiAqIENocm9tZSBpbmNsdWRlcyBFcnJvci5tZXNzYWdlIGluIEVycm9yLnN0YWNrLiBPdGhlciBicm93c2VycyBkbyBub3QuXG4gKiBUaGlzIHJldHVybnMgZXhwZWN0ZWQgb3V0cHV0IG9mIG1lc3NhZ2UgKyBzdGFjayB3aGVuIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBlcnJvciAtIEVycm9yIG9yIEZpcmVzdG9yZUVycm9yXG4gKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZSA9IHQubWVzc2FnZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHQuc3RhY2sgJiYgKGUgPSB0LnN0YWNrLmluY2x1ZGVzKHQubWVzc2FnZSkgPyB0LnN0YWNrIDogdC5tZXNzYWdlICsgXCJcXG5cIiArIHQuc3RhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbiAgICAgICAgICAgIC8vIFRPRE8obXJzY2htaWR0KSBDb25zaWRlciB1c2luZyBgQmFzZVRyYW5zYWN0aW9uYCBhcyB0aGUgYmFzZSBjbGFzcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIGxlZ2FjeSBTREsuXG4gICAgICAgICAgICAvKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogVGhlIGBUcmFuc2FjdGlvbmAgb2JqZWN0IHBhc3NlZCB0byBhIHRyYW5zYWN0aW9uJ3MgYHVwZGF0ZUZ1bmN0aW9uYCBwcm92aWRlc1xuICogdGhlIG1ldGhvZHMgdG8gcmVhZCBhbmQgd3JpdGUgZGF0YSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNvbnRleHQuIFNlZVxuICoge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cbiAqLyAodCk7XG4gICAgICAgICAgICAvLyBSZS10aHJvdyB0aGUgZXJyb3Igc28gdGhhdCB0aGlzLnRhaWwgYmVjb21lcyBhIHJlamVjdGVkIFByb21pc2UgYW5kXG4gICAgICAgICAgICAvLyBhbGwgZnVydGhlciBhdHRlbXB0cyB0byBjaGFpbiAodmlhIC50aGVuKSB3aWxsIGp1c3Qgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAgICAgICAgICAgIHRocm93IGcoXCJJTlRFUk5BTCBVTkhBTkRMRUQgRVJST1I6IFwiLCBlKSwgdDtcbiAgICAgICAgfSkpLnRoZW4oKHQgPT4gKHRoaXMuVnQgPSAhMSwgdCkpKSkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuSXQgPSBlLCBlO1xuICAgIH1cbiAgICBlbnF1ZXVlQWZ0ZXJEZWxheSh0LCBlLCBuKSB7XG4gICAgICAgIHRoaXMuRnQoKSwgXG4gICAgICAgIC8vIEZhc3QtZm9yd2FyZCBkZWxheXMgZm9yIHRpbWVySWRzIHRoYXQgaGF2ZSBiZWVuIG92ZXJyaWRlbi5cbiAgICAgICAgdGhpcy5OdC5pbmRleE9mKHQpID4gLTEgJiYgKGUgPSAwKTtcbiAgICAgICAgY29uc3QgciA9IGhzLmNyZWF0ZUFuZFNjaGVkdWxlKHRoaXMsIHQsIGUsIG4sICh0ID0+IHRoaXMucXQodCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuUnQucHVzaChyKSwgcjtcbiAgICB9XG4gICAgRnQoKSB7XG4gICAgICAgIHRoaXMuUHQgJiYgYigpO1xuICAgIH1cbiAgICB2ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCkge31cbiAgICAvKipcbiAgICAgKiBXYWl0cyB1bnRpbCBhbGwgY3VycmVudGx5IHF1ZXVlZCB0YXNrcyBhcmUgZmluaXNoZWQgZXhlY3V0aW5nLiBEZWxheWVkXG4gICAgICogb3BlcmF0aW9ucyBhcmUgbm90IHJ1bi5cbiAgICAgKi8gICAgYXN5bmMgT3QoKSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaW4gdGhlIHF1ZXVlIHByaW9yIHRvIGRyYWluaW5nIG1heSBoYXZlIGVucXVldWVkIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gS2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlIHRhaWwgaXMgbm8gbG9uZ2VyIGFkdmFuY2VkLFxuICAgICAgICAvLyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBubyBtb3JlIG5ldyBvcGVyYXRpb25zIHdlcmUgZW5xdWV1ZWQgYW5kIHRoYXQgYWxsXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZC5cbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHQgPSB0aGlzLkl0LCBhd2FpdCB0O1xuICAgICAgICB9IHdoaWxlICh0ICE9PSB0aGlzLkl0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIFRlc3RzOiBEZXRlcm1pbmUgaWYgYSBkZWxheWVkIG9wZXJhdGlvbiB3aXRoIGEgcGFydGljdWxhciBUaW1lcklkXG4gICAgICogZXhpc3RzLlxuICAgICAqLyAgICBrdCh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLlJ0KSBpZiAoZS50aW1lcklkID09PSB0KSByZXR1cm4gITA7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIFRlc3RzOiBSdW5zIHNvbWUgb3IgYWxsIGRlbGF5ZWQgb3BlcmF0aW9ucyBlYXJseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXN0VGltZXJJZCAtIERlbGF5ZWQgb3BlcmF0aW9ucyB1cCB0byBhbmQgaW5jbHVkaW5nIHRoaXMgVGltZXJJZFxuICAgICAqIHdpbGwgYmUgZHJhaW5lZC4gUGFzcyBUaW1lcklkLkFsbCB0byBydW4gYWxsIGRlbGF5ZWQgb3BlcmF0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFsbCBvcGVyYXRpb25zIGhhdmUgYmVlbiBydW4uXG4gICAgICovICAgIEN0KHQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRyYWluaW5nIG1heSBnZW5lcmF0ZSBtb3JlIGRlbGF5ZWQgb3BzLCBzbyB3ZSBkbyB0aGF0IGZpcnN0LlxuICAgICAgICByZXR1cm4gdGhpcy5PdCgpLnRoZW4oKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJ1biBvcHMgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSdkIHJ1biBpZiB0aGV5IHJhbiBuYXR1cmFsbHkuXG4gICAgICAgICAgICB0aGlzLlJ0LnNvcnQoKCh0LCBlKSA9PiB0LnRhcmdldFRpbWVNcyAtIGUudGFyZ2V0VGltZU1zKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5SdCkgaWYgKGUuc2tpcERlbGF5KCksIFwiYWxsXCIgLyogVGltZXJJZC5BbGwgKi8gIT09IHQgJiYgZS50aW1lcklkID09PSB0KSBicmVhaztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk90KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIFRlc3RzOiBTa2lwIGFsbCBzdWJzZXF1ZW50IGRlbGF5cyBmb3IgYSB0aW1lciBpZC5cbiAgICAgKi8gICAgTHQodCkge1xuICAgICAgICB0aGlzLk50LnB1c2godCk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgb25jZSBhIERlbGF5ZWRPcGVyYXRpb24gaXMgcnVuIG9yIGNhbmNlbGVkLiAqLyAgICBxdCh0KSB7XG4gICAgICAgIC8vIE5PVEU6IGluZGV4T2YgLyBzbGljZSBhcmUgTyhuKSwgYnV0IGRlbGF5ZWRPcGVyYXRpb25zIGlzIGV4cGVjdGVkIHRvIGJlIHNtYWxsLlxuICAgICAgICBjb25zdCBlID0gdGhpcy5SdC5pbmRleE9mKHQpO1xuICAgICAgICB0aGlzLlJ0LnNwbGljZShlLCAxKTtcbiAgICB9XG59XG5cbmNsYXNzIGZzIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gdCwgdGhpcy5fdHJhbnNhY3Rpb24gPSBlLCB0aGlzLl9kYXRhUmVhZGVyID0gV24odCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqLyAgICBnZXQodCkge1xuICAgICAgICBjb25zdCBlID0gc3ModCwgdGhpcy5fZmlyZXN0b3JlKSwgbiA9IG5ldyBCcih0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24ubG9va3VwKFsgZS5fa2V5IF0pLnRoZW4oKHQgPT4ge1xuICAgICAgICAgICAgaWYgKCF0IHx8IDEgIT09IHQubGVuZ3RoKSByZXR1cm4gYigpO1xuICAgICAgICAgICAgY29uc3QgciA9IHRbMF07XG4gICAgICAgICAgICBpZiAoci5pc0ZvdW5kRG9jdW1lbnQoKSkgcmV0dXJuIG5ldyBmcih0aGlzLl9maXJlc3RvcmUsIG4sIHIua2V5LCByLCBlLmNvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAoci5pc05vRG9jdW1lbnQoKSkgcmV0dXJuIG5ldyBmcih0aGlzLl9maXJlc3RvcmUsIG4sIGUuX2tleSwgbnVsbCwgZS5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdGhyb3cgYigpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHNldCh0LCBlLCBuKSB7XG4gICAgICAgIGNvbnN0IHIgPSBzcyh0LCB0aGlzLl9maXJlc3RvcmUpLCBzID0ganIoci5jb252ZXJ0ZXIsIGUsIG4pLCBpID0gR24odGhpcy5fZGF0YVJlYWRlciwgXCJUcmFuc2FjdGlvbi5zZXRcIiwgci5fa2V5LCBzLCBudWxsICE9PSByLmNvbnZlcnRlciwgbik7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5zZXQoci5fa2V5LCBpKSwgdGhpcztcbiAgICB9XG4gICAgdXBkYXRlKHQsIGUsIG4sIC4uLnIpIHtcbiAgICAgICAgY29uc3QgcyA9IHNzKHQsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgcmV0dXJuIGkgPSBcInN0cmluZ1wiID09IHR5cGVvZiAoZSA9IGwoZSkpIHx8IGUgaW5zdGFuY2VvZiBPbiA/IGVyKHRoaXMuX2RhdGFSZWFkZXIsIFwiVHJhbnNhY3Rpb24udXBkYXRlXCIsIHMuX2tleSwgZSwgbiwgcikgOiB0cih0aGlzLl9kYXRhUmVhZGVyLCBcIlRyYW5zYWN0aW9uLnVwZGF0ZVwiLCBzLl9rZXksIGUpLCBcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24udXBkYXRlKHMuX2tleSwgaSksIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXG4gICAgICogQHJldHVybnMgVGhpcyBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovICAgIGRlbGV0ZSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBzcyh0LCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uZGVsZXRlKGUuX2tleSksIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBnaXZlbiBgdXBkYXRlRnVuY3Rpb25gIGFuZCB0aGVuIGF0dGVtcHRzIHRvIGNvbW1pdCB0aGUgY2hhbmdlc1xuICogYXBwbGllZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLiBJZiBhbnkgZG9jdW1lbnQgcmVhZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG4gKiBoYXMgY2hhbmdlZCwgQ2xvdWQgRmlyZXN0b3JlIHJldHJpZXMgdGhlIGB1cGRhdGVGdW5jdGlvbmAuIElmIGl0IGZhaWxzIHRvXG4gKiBjb21taXQgYWZ0ZXIgNSBhdHRlbXB0cywgdGhlIHRyYW5zYWN0aW9uIGZhaWxzLlxuICpcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB3cml0ZXMgYWxsb3dlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBpcyA1MDAuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBGaXJlc3RvcmUgZGF0YWJhc2UgdG8gcnVuIHRoaXNcbiAqIHRyYW5zYWN0aW9uIGFnYWluc3QuXG4gKiBAcGFyYW0gdXBkYXRlRnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG4gKiBjb250ZXh0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMgdG9cbiAqIGNvbW1pdC5cbiAqIEByZXR1cm5zIElmIHRoZSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IG9yIHdhcyBleHBsaWNpdGx5IGFib3J0ZWRcbiAqICh0aGUgYHVwZGF0ZUZ1bmN0aW9uYCByZXR1cm5lZCBhIGZhaWxlZCBwcm9taXNlKSwgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlXG4gKiBgdXBkYXRlRnVuY3Rpb24gYGlzIHJldHVybmVkIGhlcmUuIE90aGVyd2lzZSwgaWYgdGhlIHRyYW5zYWN0aW9uIGZhaWxlZCwgYVxuICogcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGZhaWx1cmUgZXJyb3IgaXMgcmV0dXJuZWQuXG4gKi8gZnVuY3Rpb24gZHModCwgZSwgbikge1xuICAgIGNvbnN0IHIgPSB5bih0ID0gY3QodCwgX24pKSwgcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXMpLCBuKTtcbiAgICAhZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodC5tYXhBdHRlbXB0cyA8IDEpIHRocm93IG5ldyBVKFAsIFwiTWF4IGF0dGVtcHRzIG11c3QgYmUgYXQgbGVhc3QgMVwiKTtcbiAgICB9KHMpO1xuICAgIGNvbnN0IGkgPSBuZXcgajtcbiAgICByZXR1cm4gbmV3IGNzKG5ldyBscywgciwgcywgKG4gPT4gZShuZXcgZnModCwgbikpKSwgaSkucnVuKCksIGkucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBGaXJlc3RvcmUgTGl0ZVxuICpcbiAqIEByZW1hcmtzIEZpcmVzdG9yZSBMaXRlIGlzIGEgc21hbGwgb25saW5lLW9ubHkgU0RLIHRoYXQgYWxsb3dzIHJlYWRcbiAqIGFuZCB3cml0ZSBhY2Nlc3MgdG8geW91ciBGaXJlc3RvcmUgZGF0YWJhc2UuIEFsbCBvcGVyYXRpb25zIGNvbm5lY3RcbiAqIGRpcmVjdGx5IHRvIHRoZSBiYWNrZW5kLCBhbmQgYG9uU25hcHNob3QoKWAgQVBJcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovICFmdW5jdGlvbih0KSB7XG4gICAgdyA9IHQ7XG59KGAke3N9X2xpdGVgKSwgbihuZXcgaShcImZpcmVzdG9yZS9saXRlXCIsICgodCwge2luc3RhbmNlSWRlbnRpZmllcjogZSwgb3B0aW9uczogbn0pID0+IHtcbiAgICBjb25zdCByID0gdC5nZXRQcm92aWRlcihcImFwcFwiKS5nZXRJbW1lZGlhdGUoKSwgcyA9IG5ldyBfbihuZXcgVyh0LmdldFByb3ZpZGVyKFwiYXV0aC1pbnRlcm5hbFwiKSksIG5ldyBIKHQuZ2V0UHJvdmlkZXIoXCJhcHAtY2hlY2staW50ZXJuYWxcIikpLCBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5hcHBseSh0Lm9wdGlvbnMsIFsgXCJwcm9qZWN0SWRcIiBdKSkgdGhyb3cgbmV3IFUoUCwgJ1wicHJvamVjdElkXCIgbm90IHByb3ZpZGVkIGluIGZpcmViYXNlLmluaXRpYWxpemVBcHAuJyk7XG4gICAgICAgIHJldHVybiBuZXcgWCh0Lm9wdGlvbnMucHJvamVjdElkLCBlKTtcbiAgICB9XG4gICAgLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gKHIsIGUpLCByKTtcbiAgICByZXR1cm4gbiAmJiBzLl9zZXRTZXR0aW5ncyhuKSwgcztcbn0pLCBcIlBVQkxJQ1wiKS5zZXRNdWx0aXBsZUluc3RhbmNlcyghMCkpLCBcbi8vIFJVTlRJTUVfRU5WIGFuZCBCVUlMRF9UQVJHRVQgYXJlIHJlcGxhY2VkIGJ5IHJlYWwgdmFsdWVzIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbnIoXCJmaXJlc3RvcmUtbGl0ZVwiLCBcIjMuOC4wXCIsIFwiXCIpLCByKFwiZmlyZXN0b3JlLWxpdGVcIiwgXCIzLjguMFwiLCBcIl9fQlVJTERfVEFSR0VUX19cIik7XG5cbmV4cG9ydCB7IFRuIGFzIEFnZ3JlZ2F0ZUZpZWxkLCBBbiBhcyBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90LCBxbiBhcyBCeXRlcywgJG4gYXMgQ29sbGVjdGlvblJlZmVyZW5jZSwgUG4gYXMgRG9jdW1lbnRSZWZlcmVuY2UsIGZyIGFzIERvY3VtZW50U25hcHNob3QsIE9uIGFzIEZpZWxkUGF0aCwgQ24gYXMgRmllbGRWYWx1ZSwgX24gYXMgRmlyZXN0b3JlLCBVIGFzIEZpcmVzdG9yZUVycm9yLCBMbiBhcyBHZW9Qb2ludCwgVm4gYXMgUXVlcnksIEVyIGFzIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCwgZ3IgYXMgUXVlcnlDb25zdHJhaW50LCBkciBhcyBRdWVyeURvY3VtZW50U25hcHNob3QsIHhyIGFzIFF1ZXJ5RW5kQXRDb25zdHJhaW50LCB2ciBhcyBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCwgUHIgYXMgUXVlcnlMaW1pdENvbnN0cmFpbnQsIEFyIGFzIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQsIHdyIGFzIFF1ZXJ5U25hcHNob3QsIE5yIGFzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQsIFZ0IGFzIFRpbWVzdGFtcCwgZnMgYXMgVHJhbnNhY3Rpb24sIHJzIGFzIFdyaXRlQmF0Y2gsIFlyIGFzIGFkZERvYywgSnIgYXMgYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsLCBUciBhcyBhbmQsIGVzIGFzIGFycmF5UmVtb3ZlLCB0cyBhcyBhcnJheVVuaW9uLCBObiBhcyBjb2xsZWN0aW9uLCBEbiBhcyBjb2xsZWN0aW9uR3JvdXAsIEVuIGFzIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvciwgS3IgYXMgZGVsZXRlRG9jLCBYciBhcyBkZWxldGVGaWVsZCwgRm4gYXMgZG9jLCBrbiBhcyBkb2N1bWVudElkLCBxciBhcyBlbmRBdCwgU3IgYXMgZW5kQmVmb3JlLCBIciBhcyBnZXRDb3VudCwgUXIgYXMgZ2V0RG9jLCB6ciBhcyBnZXREb2NzLCBibiBhcyBnZXRGaXJlc3RvcmUsIG5zIGFzIGluY3JlbWVudCwgdm4gYXMgaW5pdGlhbGl6ZUZpcmVzdG9yZSwgVnIgYXMgbGltaXQsICRyIGFzIGxpbWl0VG9MYXN0LCBJciBhcyBvciwgUnIgYXMgb3JkZXJCeSwgX3IgYXMgcXVlcnksIFNuIGFzIHF1ZXJ5RXF1YWwsIHhuIGFzIHJlZkVxdWFsLCBkcyBhcyBydW5UcmFuc2FjdGlvbiwgWnIgYXMgc2VydmVyVGltZXN0YW1wLCBXciBhcyBzZXREb2MsIHAgYXMgc2V0TG9nTGV2ZWwsIG1yIGFzIHNuYXBzaG90RXF1YWwsIEZyIGFzIHN0YXJ0QWZ0ZXIsIERyIGFzIHN0YXJ0QXQsIEluIGFzIHRlcm1pbmF0ZSwgR3IgYXMgdXBkYXRlRG9jLCBiciBhcyB3aGVyZSwgaXMgYXMgd3JpdGVCYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguYnJvd3Nlci5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbImQiLCJ0IiwidWlkIiwiaXNBdXRoZW50aWNhdGVkIiwiVU5BVVRIRU5USUNBVEVEIiwiR09PR0xFX0NSRURFTlRJQUxTIiwiRklSU1RfUEFSVFkiLCJNT0NLX1VTRVIiLCJ3IiwibSIsIm8iLCJwIiwic2V0TG9nTGV2ZWwiLCJ5IiwibG9nTGV2ZWwiLCJ1IiwiREVCVUciLCJlIiwibiIsIm1hcCIsInYiLCJkZWJ1ZyIsImciLCJFUlJPUiIsImVycm9yIiwiXyIsIldBUk4iLCJ3YXJuIiwiSlNPTiIsInN0cmluZ2lmeSIsImIiLCJFcnJvciIsIkUiLCJJIiwiVCIsIkEiLCJSIiwiUCIsIlYiLCIkIiwiTiIsIkQiLCJGIiwieCIsIlMiLCJxIiwiTyIsImsiLCJDIiwiTCIsIk0iLCJVIiwiY29kZSIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsIm5hbWUiLCJjIiwiaiIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkIiLCJ1c2VyIiwidHlwZSIsImhlYWRlcnMiLCJNYXAiLCJzZXQiLCJRIiwiZW5xdWV1ZVJldHJ5YWJsZSIsInoiLCJ0b2tlbiIsImNoYW5nZUxpc3RlbmVyIiwiVyIsImF1dGgiLCJvbkluaXQiLCJnZXRUb2tlbiIsInRoZW4iLCJhY2Nlc3NUb2tlbiIsImdldFVpZCIsIkciLCJyIiwiaSIsImgiLCJnZXRBdXRoSGVhZGVyVmFsdWVGb3JGaXJzdFBhcnR5IiwibCIsIksiLCJZIiwidmFsdWUiLCJsZW5ndGgiLCJIIiwiYXBwQ2hlY2siLCJKIiwicyIsImRhdGFiYXNlSWQiLCJhcHBJZCIsInBlcnNpc3RlbmNlS2V5IiwiaG9zdCIsInNzbCIsImZvcmNlTG9uZ1BvbGxpbmciLCJhdXRvRGV0ZWN0TG9uZ1BvbGxpbmciLCJ1c2VGZXRjaFN0cmVhbXMiLCJYIiwicHJvamVjdElkIiwiZGF0YWJhc2UiLCJaIiwic2VnbWVudHMiLCJvZmZzZXQiLCJsZW4iLCJjb21wYXJhdG9yIiwic2xpY2UiLCJsaW1pdCIsImZvckVhY2giLCJwdXNoIiwiY29uc3RydWN0IiwiZ2V0IiwiTWF0aCIsIm1pbiIsInR0IiwidG9BcnJheSIsImpvaW4iLCJjYW5vbmljYWxTdHJpbmciLCJpbmRleE9mIiwic3BsaXQiLCJmaWx0ZXIiLCJldCIsIm50IiwicmVwbGFjZSIsImlzVmFsaWRJZGVudGlmaWVyIiwidGVzdCIsInJ0IiwicGF0aCIsInBvcExhc3QiLCJsYXN0U2VnbWVudCIsImZyb21TdHJpbmciLCJwb3BGaXJzdCIsImVtcHR5UGF0aCIsInN0IiwiaXQiLCJpc0RvY3VtZW50S2V5Iiwib3QiLCJ1dCIsInN1YnN0cmluZyIsIkFycmF5IiwiY29uc3RydWN0b3IiLCJjdCIsIl9kZWxlZ2F0ZSIsImF0IiwiaHQiLCJsdCIsImZ0IiwiQmF0Y2hHZXREb2N1bWVudHMiLCJDb21taXQiLCJSdW5RdWVyeSIsIlJ1bkFnZ3JlZ2F0aW9uUXVlcnkiLCJkdCIsInd0IiwibXQiLCJPSyIsIkNBTkNFTExFRCIsIlVOS05PV04iLCJJTlZBTElEX0FSR1VNRU5UIiwiREVBRExJTkVfRVhDRUVERUQiLCJOT1RfRk9VTkQiLCJBTFJFQURZX0VYSVNUUyIsIlBFUk1JU1NJT05fREVOSUVEIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiRkFJTEVEX1BSRUNPTkRJVElPTiIsIkFCT1JURUQiLCJPVVRfT0ZfUkFOR0UiLCJVTklNUExFTUVOVEVEIiwiSU5URVJOQUwiLCJVTkFWQUlMQUJMRSIsIkRBVEFfTE9TUyIsInB0IiwibWV0aG9kIiwiYm9keSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJvayIsImpzb24iLCJpc0FycmF5IiwiZGF0YWJhc2VJbmZvIiwieXQiLCJzZWxmIiwiY3J5cHRvIiwibXNDcnlwdG8iLCJVaW50OEFycmF5IiwiZ2V0UmFuZG9tVmFsdWVzIiwiZmxvb3IiLCJyYW5kb20iLCJndCIsImNoYXJBdCIsIl90IiwidnQiLCJldmVyeSIsImJ0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRXQiLCJJdCIsImJpbmFyeVN0cmluZyIsIm5leHQiLCJjaGFyQ29kZUF0IiwiZG9uZSIsImJ0b2EiLCJhdG9iIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJFTVBUWV9CWVRFX1NUUklORyIsIlR0IiwiUmVnRXhwIiwiQXQiLCJleGVjIiwic3Vic3RyIiwiTnVtYmVyIiwiRGF0ZSIsInNlY29uZHMiLCJnZXRUaW1lIiwibmFub3MiLCJSdCIsIlB0IiwiZnJvbUJhc2U2NFN0cmluZyIsImZyb21VaW50OEFycmF5IiwiVnQiLCJuYW5vc2Vjb25kcyIsInRvTWlsbGlzIiwicGFkU3RhcnQiLCJmcm9tTWlsbGlzIiwibm93IiwiJHQiLCJtYXBWYWx1ZSIsImZpZWxkcyIsIl9fdHlwZV9fIiwic3RyaW5nVmFsdWUiLCJOdCIsIl9fcHJldmlvdXNfdmFsdWVfXyIsIkR0IiwiX19sb2NhbF93cml0ZV90aW1lX18iLCJ0aW1lc3RhbXBWYWx1ZSIsIkZ0IiwieHQiLCJTdCIsImJvb2xlYW5WYWx1ZSIsImlzRXF1YWwiLCJieXRlc1ZhbHVlIiwicmVmZXJlbmNlVmFsdWUiLCJnZW9Qb2ludFZhbHVlIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJpbnRlZ2VyVmFsdWUiLCJkb3VibGVWYWx1ZSIsImlzTmFOIiwiYXJyYXlWYWx1ZSIsInZhbHVlcyIsInF0IiwiZmluZCIsIk90Iiwia3QiLCJjb21wYXJlVG8iLCJrZXlzIiwic29ydCIsIkN0IiwiTHQiLCJNdCIsIlV0IiwianQiLCJCdCIsImFzc2lnbiIsIlF0IiwicG9zaXRpb24iLCJpbmNsdXNpdmUiLCJ6dCIsIld0IiwiR3QiLCJmaWVsZCIsIm9wIiwiZGF0YSIsIm1hdGNoZXNDb21wYXJpc29uIiwiaXNJbmVxdWFsaXR5IiwiaXNLZXlGaWVsZCIsImNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIiLCJIdCIsInRlIiwiZWUiLCJuZSIsInJlIiwiSnQiLCJYdCIsIkt0IiwiZmlsdGVycyIsIm1hdGNoZXMiLCJyZWR1Y2UiLCJjb25jYXQiLCJnZXRGbGF0dGVuZWRGaWx0ZXJzIiwiWXQiLCJrZXkiLCJmcm9tTmFtZSIsIlp0Iiwic29tZSIsIm51bGxWYWx1ZSIsInNlIiwiZGlyIiwiaWUiLCJvZSIsInRpbWVzdGFtcCIsIl9jb21wYXJlVG8iLCJ1ZSIsInJvb3QiLCJhZSIsIkVNUFRZIiwiaW5zZXJ0IiwiY29weSIsIkJMQUNLIiwicmVtb3ZlIiwiaXNFbXB0eSIsImxlZnQiLCJyaWdodCIsInNpemUiLCJtaW5LZXkiLCJtYXhLZXkiLCJpbm9yZGVyVHJhdmVyc2FsIiwicmV2ZXJzZVRyYXZlcnNhbCIsImNlIiwiaXNSZXZlcnNlIiwibm9kZVN0YWNrIiwicG9wIiwiY29sb3IiLCJSRUQiLCJmaXhVcCIsImlzUmVkIiwibW92ZVJlZExlZnQiLCJyZW1vdmVNaW4iLCJyb3RhdGVSaWdodCIsIm1vdmVSZWRSaWdodCIsInJvdGF0ZUxlZnQiLCJjb2xvckZsaXAiLCJjaGVjayIsInBvdyIsImhlIiwiZ2V0SXRlcmF0b3JGcm9tIiwiaGFzTmV4dCIsImdldE5leHQiLCJnZXRJdGVyYXRvciIsImxlIiwiaGFzIiwiYWRkIiwiaXRlciIsImZlIiwiaXNQcmVmaXhPZiIsImRlIiwiZ2V0RmllbGRzTWFwIiwiaXNJbW1lZGlhdGVQYXJlbnRPZiIsImFwcGx5Q2hhbmdlcyIsIndlIiwiZG9jdW1lbnRUeXBlIiwidmVyc2lvbiIsInJlYWRUaW1lIiwiY3JlYXRlVGltZSIsImRvY3VtZW50U3RhdGUiLCJlbXB0eSIsImhhc0xvY2FsTXV0YXRpb25zIiwiaGFzQ29tbWl0dGVkTXV0YXRpb25zIiwiY2xvbmUiLCJtZSIsImNvbGxlY3Rpb25Hcm91cCIsIm9yZGVyQnkiLCJzdGFydEF0IiwiZW5kQXQiLCJwZSIsInllIiwiZXhwbGljaXRPcmRlckJ5IiwibGltaXRUeXBlIiwiZ2UiLCJfZSIsImdldEZpcnN0SW5lcXVhbGl0eUZpZWxkIiwidmUiLCJiZSIsImtleUZpZWxkIiwiRWUiLCJJZSIsIlRlIiwiQWUiLCJpc0ludGVnZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIlJlIiwiUGUiLCJWZSIsImVsZW1lbnRzIiwiJGUiLCJOZSIsIkRlIiwidHJhbnNmb3JtIiwiRmUiLCJ1cGRhdGVUaW1lIiwiZXhpc3RzIiwieGUiLCJTZSIsInByZWNvbmRpdGlvbiIsImZpZWxkVHJhbnNmb3JtcyIsInFlIiwiZmllbGRNYXNrIiwiT2UiLCJrZSIsIkNlIiwiYXNjIiwiZGVzYyIsIkxlIiwiTWUiLCJhbmQiLCJvciIsIlVlIiwiamUiLCJ0b0lTT1N0cmluZyIsIkJlIiwidG9CYXNlNjQiLCJ0b1VpbnQ4QXJyYXkiLCJRZSIsInRvVGltZXN0YW1wIiwiemUiLCJmcm9tVGltZXN0YW1wIiwiV2UiLCJjaGlsZCIsIkdlIiwiS2UiLCJjbiIsIlllIiwiSGUiLCJKZSIsIlhlIiwiZm91bmQiLCJuZXdGb3VuZERvY3VtZW50IiwibWlzc2luZyIsIm5ld05vRG9jdW1lbnQiLCJaZSIsInVwZGF0ZSIsInVwZGF0ZU1hc2siLCJ1biIsInZlcmlmeSIsInVwZGF0ZVRyYW5zZm9ybXMiLCJmaWVsZFBhdGgiLCJzZXRUb1NlcnZlclZhbHVlIiwiYXBwZW5kTWlzc2luZ0VsZW1lbnRzIiwicmVtb3ZlQWxsRnJvbUFycmF5IiwiaW5jcmVtZW50IiwiaXNOb25lIiwiY3VycmVudERvY3VtZW50IiwidG4iLCJzdHJ1Y3R1cmVkUXVlcnkiLCJwYXJlbnQiLCJmcm9tIiwiY29sbGVjdGlvbklkIiwiYWxsRGVzY2VuZGFudHMiLCJvbiIsImNyZWF0ZSIsIndoZXJlIiwic24iLCJkaXJlY3Rpb24iLCJlbiIsImJlZm9yZSIsIm5uIiwicm4iLCJ1bmFyeUZpbHRlciIsImZpZWxkRmlsdGVyIiwiZ2V0RmlsdGVycyIsImNvbXBvc2l0ZUZpbHRlciIsImZpZWxkUGF0aHMiLCJhbiIsImhuIiwidGltZXJJZCIsInJlc2V0IiwiY2FuY2VsIiwibWF4IiwiZW5xdWV1ZUFmdGVyRGVsYXkiLCJza2lwRGVsYXkiLCJsbiIsImF1dGhDcmVkZW50aWFscyIsImFwcENoZWNrQ3JlZGVudGlhbHMiLCJjb25uZWN0aW9uIiwiYWxsIiwiaW52YWxpZGF0ZVRva2VuIiwiZm4iLCJ3cml0ZXMiLCJkbiIsImRvY3VtZW50cyIsInduIiwiZG9jdW1lbnQiLCJzZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMiLCJtbiIsInN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5IiwiYWdncmVnYXRpb25zIiwiY291bnQiLCJhbGlhcyIsInJlc3VsdCIsImFnZ3JlZ2F0ZUZpZWxkcyIsInBuIiwieW4iLCJfdGVybWluYXRlZCIsImZldGNoIiwiYmluZCIsIl9kYXRhYmFzZUlkIiwiYXBwIiwib3B0aW9ucyIsIl9wZXJzaXN0ZW5jZUtleSIsIl9mcmVlemVTZXR0aW5ncyIsImV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmciLCJleHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmciLCJfYXV0aENyZWRlbnRpYWxzIiwiX2FwcENoZWNrQ3JlZGVudGlhbHMiLCJnbiIsImNyZWRlbnRpYWxzIiwiaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyIsImNhY2hlU2l6ZUJ5dGVzIiwiX24iLCJfYXBwIiwiX3NldHRpbmdzIiwiX3NldHRpbmdzRnJvemVuIiwiX3Rlcm1pbmF0ZVRhc2siLCJjbGllbnQiLCJzZXNzaW9uSW5kZXgiLCJpYW1Ub2tlbiIsImF1dGhUb2tlbkZhY3RvcnkiLCJfdGVybWluYXRlIiwic2V0dGluZ3MiLCJ0ZXJtaW5hdGUiLCJ2biIsIl9nZXRQcm92aWRlciIsImlzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplIiwiaW5zdGFuY2VJZGVudGlmaWVyIiwiYm4iLCJnZXRJbW1lZGlhdGUiLCJpZGVudGlmaWVyIiwiX2luaXRpYWxpemVkIiwiYSIsIkVuIiwiX2dldFNldHRpbmdzIiwiX3NldFNldHRpbmdzIiwibW9ja1VzZXJUb2tlbiIsInN1YiIsInVzZXJfaWQiLCJJbiIsIl9kZWxldGUiLCJUbiIsIkFuIiwiX2RhdGEiLCJxdWVyeSIsIlJuIiwiZGF0YXN0b3JlIiwidXNlckRhdGFXcml0ZXIiLCJfcXVlcnkiLCJlbnRyaWVzIiwiY29udmVydFZhbHVlIiwiUG4iLCJjb252ZXJ0ZXIiLCJfa2V5IiwiZmlyZXN0b3JlIiwiJG4iLCJWbiIsIl9wYXRoIiwiTm4iLCJEbiIsIkZuIiwiYXJndW1lbnRzIiwieG4iLCJTbiIsInFuIiwiX2J5dGVTdHJpbmciLCJPbiIsIl9pbnRlcm5hbFBhdGgiLCJrbiIsIkNuIiwiX21ldGhvZE5hbWUiLCJMbiIsImlzRmluaXRlIiwiX2xhdCIsIl9sb25nIiwiTW4iLCJVbiIsImpuIiwiQm4iLCJRbiIsImhyIiwibWV0aG9kTmFtZSIsInpuIiwiV24iLCJHbiIsIm1lcmdlIiwibWVyZ2VGaWVsZHMiLCJzciIsInVyIiwiY29udGFpbnMiLCJsciIsImNvdmVycyIsIktuIiwiWW4iLCJIbiIsIkpuIiwicnIiLCJYbiIsIlpuIiwidHIiLCJhciIsImVyIiwiZiIsIm5yIiwiaXIiLCJfdG9GaWVsZFRyYW5zZm9ybSIsImZyb21EYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJjciIsInNlYXJjaCIsImZyIiwiX2ZpcmVzdG9yZSIsIl91c2VyRGF0YVdyaXRlciIsIl9kb2N1bWVudCIsIl9jb252ZXJ0ZXIiLCJkciIsImZyb21GaXJlc3RvcmUiLCJwciIsIndyIiwiX2RvY3MiLCJkb2NzIiwibXIiLCJ5ciIsImdyIiwiX3IiLCJFciIsInZyIiwiX2FwcGx5IiwiX2ZpZWxkIiwiX29wIiwiX3ZhbHVlIiwiX3BhcnNlIiwiTHIiLCJDciIsImtyIiwiYnIiLCJfY3JlYXRlIiwiX3F1ZXJ5Q29uc3RyYWludHMiLCJfZ2V0T3BlcmF0b3IiLCJJciIsIlVyIiwiVHIiLCJBciIsIl9kaXJlY3Rpb24iLCJNciIsIlJyIiwiUHIiLCJfbGltaXQiLCJfbGltaXRUeXBlIiwiVnIiLCIkciIsIk5yIiwiX2RvY09yRmllbGRzIiwiX2luY2x1c2l2ZSIsIk9yIiwiRHIiLCJGciIsInhyIiwiU3IiLCJxciIsImpyIiwidG9GaXJlc3RvcmUiLCJCciIsImNvbnZlcnREb2N1bWVudEtleSIsImNvbnZlcnRUaW1lc3RhbXAiLCJjb252ZXJ0U2VydmVyVGltZXN0YW1wIiwiY29udmVydEJ5dGVzIiwiY29udmVydFJlZmVyZW5jZSIsImNvbnZlcnRHZW9Qb2ludCIsImNvbnZlcnRBcnJheSIsImNvbnZlcnRPYmplY3QiLCJRciIsImlzRm91bmREb2N1bWVudCIsInpyIiwicmV2ZXJzZSIsIldyIiwidG9NdXRhdGlvbiIsIm5vbmUiLCJHciIsIktyIiwiWXIiLCJIciIsInJ1biIsIkpyIiwiWHIiLCJaciIsInRzIiwiZXMiLCJucyIsInJzIiwiX2NvbW1pdEhhbmRsZXIiLCJfbXV0YXRpb25zIiwiX2NvbW1pdHRlZCIsIl9kYXRhUmVhZGVyIiwiX3ZlcmlmeU5vdENvbW1pdHRlZCIsInNzIiwiaXMiLCJvcyIsInJlYWRWZXJzaW9ucyIsIm11dGF0aW9ucyIsImNvbW1pdHRlZCIsImxhc3RXcml0ZUVycm9yIiwid3JpdHRlbkRvY3MiLCJTZXQiLCJlbnN1cmVDb21taXROb3RDYWxsZWQiLCJyZWNvcmRWZXJzaW9uIiwid3JpdGUiLCJwcmVjb25kaXRpb25Gb3JVcGRhdGUiLCJmcm9tUGF0aCIsImlzTm9Eb2N1bWVudCIsInVzIiwibWF4QXR0ZW1wdHMiLCJjcyIsImFzeW5jUXVldWUiLCJ1cGRhdGVGdW5jdGlvbiIsImRlZmVycmVkIiwiZW5xdWV1ZUFuZEZvcmdldCIsImNvbW1pdCIsImFzIiwiaHMiLCJ0YXJnZXRUaW1lTXMiLCJyZW1vdmFsQ2FsbGJhY2siLCJ0aW1lckhhbmRsZSIsInNldFRpbWVvdXQiLCJoYW5kbGVEZWxheUVsYXBzZWQiLCJjbGVhclRpbWVvdXQiLCJzdGFydCIsImxzIiwidmlzaWJpbGl0eVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVucXVldWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2hpZnQiLCJzdGFjayIsImluY2x1ZGVzIiwiY3JlYXRlQW5kU2NoZWR1bGUiLCJzcGxpY2UiLCJmcyIsIl90cmFuc2FjdGlvbiIsImxvb2t1cCIsImRzIiwiZ2V0UHJvdmlkZXIiLCJhcHBseSIsInNldE11bHRpcGxlSW5zdGFuY2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@firebase/firestore/dist/lite/index.browser.esm2017.js\n");

/***/ }),

/***/ "./node_modules/@firebase/util/dist/index.esm2017.js":
/*!***********************************************************!*\
  !*** ./node_modules/@firebase/util/dist/index.esm2017.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS),\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"ErrorFactory\": () => (/* binding */ ErrorFactory),\n/* harmony export */   \"FirebaseError\": () => (/* binding */ FirebaseError),\n/* harmony export */   \"MAX_VALUE_MILLIS\": () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   \"RANDOM_FACTOR\": () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   \"Sha1\": () => (/* binding */ Sha1),\n/* harmony export */   \"areCookiesEnabled\": () => (/* binding */ areCookiesEnabled),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"assertionError\": () => (/* binding */ assertionError),\n/* harmony export */   \"async\": () => (/* binding */ async),\n/* harmony export */   \"base64\": () => (/* binding */ base64),\n/* harmony export */   \"base64Decode\": () => (/* binding */ base64Decode),\n/* harmony export */   \"base64Encode\": () => (/* binding */ base64Encode),\n/* harmony export */   \"base64urlEncodeWithoutPadding\": () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   \"calculateBackoffMillis\": () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"createMockUserToken\": () => (/* binding */ createMockUserToken),\n/* harmony export */   \"createSubscribe\": () => (/* binding */ createSubscribe),\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"deepCopy\": () => (/* binding */ deepCopy),\n/* harmony export */   \"deepEqual\": () => (/* binding */ deepEqual),\n/* harmony export */   \"deepExtend\": () => (/* binding */ deepExtend),\n/* harmony export */   \"errorPrefix\": () => (/* binding */ errorPrefix),\n/* harmony export */   \"extractQuerystring\": () => (/* binding */ extractQuerystring),\n/* harmony export */   \"getDefaultAppConfig\": () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   \"getDefaultEmulatorHost\": () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   \"getDefaultEmulatorHostnameAndPort\": () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   \"getExperimentalSetting\": () => (/* binding */ getExperimentalSetting),\n/* harmony export */   \"getGlobal\": () => (/* binding */ getGlobal),\n/* harmony export */   \"getModularInstance\": () => (/* binding */ getModularInstance),\n/* harmony export */   \"getUA\": () => (/* binding */ getUA),\n/* harmony export */   \"isAdmin\": () => (/* binding */ isAdmin),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isBrowserExtension\": () => (/* binding */ isBrowserExtension),\n/* harmony export */   \"isElectron\": () => (/* binding */ isElectron),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"isIE\": () => (/* binding */ isIE),\n/* harmony export */   \"isIndexedDBAvailable\": () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   \"isMobileCordova\": () => (/* binding */ isMobileCordova),\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isNodeSdk\": () => (/* binding */ isNodeSdk),\n/* harmony export */   \"isReactNative\": () => (/* binding */ isReactNative),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari),\n/* harmony export */   \"isUWP\": () => (/* binding */ isUWP),\n/* harmony export */   \"isValidFormat\": () => (/* binding */ isValidFormat),\n/* harmony export */   \"isValidTimestamp\": () => (/* binding */ isValidTimestamp),\n/* harmony export */   \"issuedAtTime\": () => (/* binding */ issuedAtTime),\n/* harmony export */   \"jsonEval\": () => (/* binding */ jsonEval),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"ordinal\": () => (/* binding */ ordinal),\n/* harmony export */   \"promiseWithTimeout\": () => (/* binding */ promiseWithTimeout),\n/* harmony export */   \"querystring\": () => (/* binding */ querystring),\n/* harmony export */   \"querystringDecode\": () => (/* binding */ querystringDecode),\n/* harmony export */   \"safeGet\": () => (/* binding */ safeGet),\n/* harmony export */   \"stringLength\": () => (/* binding */ stringLength),\n/* harmony export */   \"stringToByteArray\": () => (/* binding */ stringToByteArray),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify),\n/* harmony export */   \"uuidv4\": () => (/* binding */ uuidv4),\n/* harmony export */   \"validateArgCount\": () => (/* binding */ validateArgCount),\n/* harmony export */   \"validateCallback\": () => (/* binding */ validateCallback),\n/* harmony export */   \"validateContextObject\": () => (/* binding */ validateContextObject),\n/* harmony export */   \"validateIndexedDBOpenable\": () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   \"validateNamespace\": () => (/* binding */ validateNamespace)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\nvar CONSTANTS = {\n  /**\r\n   * @define {boolean} Whether this is the client Node.js SDK.\r\n   */\n  NODE_CLIENT: false,\n  /**\r\n   * @define {boolean} Whether this is the Admin Node.js SDK.\r\n   */\n  NODE_ADMIN: false,\n  /**\r\n   * Firebase SDK Version\r\n   */\n  SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\nvar assert = function assert(assertion, message) {\n  if (!assertion) {\n    throw assertionError(message);\n  }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\nvar assertionError = function assertionError(message) {\n  return new Error('Firebase Database (' + CONSTANTS.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + message);\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar stringToByteArray$1 = function stringToByteArray$1(str) {\n  // TODO(user): Use native implementations if/when available\n  var out = [];\n  var p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n  return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\nvar byteArrayToString = function byteArrayToString(bytes) {\n  // TODO(user): Use native implementations if/when available\n  var out = [];\n  var pos = 0,\n    c = 0;\n  while (pos < bytes.length) {\n    var c1 = bytes[pos++];\n    if (c1 < 128) {\n      out[c++] = String.fromCharCode(c1);\n    } else if (c1 > 191 && c1 < 224) {\n      var c2 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n    } else if (c1 > 239 && c1 < 365) {\n      // Surrogate Pair\n      var _c = bytes[pos++];\n      var c3 = bytes[pos++];\n      var c4 = bytes[pos++];\n      var u = ((c1 & 7) << 18 | (_c & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n      out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n      out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n    } else {\n      var _c2 = bytes[pos++];\n      var _c3 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 15) << 12 | (_c2 & 63) << 6 | _c3 & 63);\n    }\n  }\n  return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nvar base64 = {\n  /**\r\n   * Maps bytes to characters.\r\n   */\n  byteToCharMap_: null,\n  /**\r\n   * Maps characters to bytes.\r\n   */\n  charToByteMap_: null,\n  /**\r\n   * Maps bytes to websafe characters.\r\n   * @private\r\n   */\n  byteToCharMapWebSafe_: null,\n  /**\r\n   * Maps websafe characters to bytes.\r\n   * @private\r\n   */\n  charToByteMapWebSafe_: null,\n  /**\r\n   * Our default alphabet, shared between\r\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n   */\n  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n  /**\r\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n  /**\r\n   * Our websafe alphabet.\r\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n  /**\r\n   * Whether this browser supports the atob and btoa functions. This extension\r\n   * started at Mozilla but is now implemented by many browsers. We use the\r\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n   * but still allowing the standard per-browser compilations.\r\n   *\r\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n  /**\r\n   * Base64-encode an array of bytes.\r\n   *\r\n   * @param input An array of bytes (numbers with\r\n   *     value in [0, 255]) to encode.\r\n   * @param webSafe Boolean indicating we should use the\r\n   *     alternative alphabet.\r\n   * @return The base64 encoded string.\r\n   */\n  encodeByteArray: function encodeByteArray(input, webSafe) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n    this.init_();\n    var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n    var output = [];\n    for (var i = 0; i < input.length; i += 3) {\n      var byte1 = input[i];\n      var haveByte2 = i + 1 < input.length;\n      var byte2 = haveByte2 ? input[i + 1] : 0;\n      var haveByte3 = i + 2 < input.length;\n      var byte3 = haveByte3 ? input[i + 2] : 0;\n      var outByte1 = byte1 >> 2;\n      var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n      var outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n      var outByte4 = byte3 & 0x3f;\n      if (!haveByte3) {\n        outByte4 = 64;\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n    return output.join('');\n  },\n  /**\r\n   * Base64-encode a string.\r\n   *\r\n   * @param input A string to encode.\r\n   * @param webSafe If true, we should use the\r\n   *     alternative alphabet.\r\n   * @return The base64 encoded string.\r\n   */\n  encodeString: function encodeString(input, webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n  },\n  /**\r\n   * Base64-decode a string.\r\n   *\r\n   * @param input to decode.\r\n   * @param webSafe True if we should use the\r\n   *     alternative alphabet.\r\n   * @return string representing the decoded value.\r\n   */\n  decodeString: function decodeString(input, webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n  },\n  /**\r\n   * Base64-decode a string.\r\n   *\r\n   * In base-64 decoding, groups of four characters are converted into three\r\n   * bytes.  If the encoder did not apply padding, the input length may not\r\n   * be a multiple of 4.\r\n   *\r\n   * In this case, the last group will have fewer than 4 characters, and\r\n   * padding will be inferred.  If the group has one or two characters, it decodes\r\n   * to one byte.  If the group has three characters, it decodes to two bytes.\r\n   *\r\n   * @param input Input to decode.\r\n   * @param webSafe True if we should use the web-safe alphabet.\r\n   * @return bytes representing the decoded value.\r\n   */\n  decodeStringToByteArray: function decodeStringToByteArray(input, webSafe) {\n    this.init_();\n    var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n    var output = [];\n    for (var i = 0; i < input.length;) {\n      var byte1 = charToByteMap[input.charAt(i++)];\n      var haveByte2 = i < input.length;\n      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n      var haveByte3 = i < input.length;\n      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      var haveByte4 = i < input.length;\n      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n      var outByte1 = byte1 << 2 | byte2 >> 4;\n      output.push(outByte1);\n      if (byte3 !== 64) {\n        var outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n        output.push(outByte2);\n        if (byte4 !== 64) {\n          var outByte3 = byte3 << 6 & 0xc0 | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n    return output;\n  },\n  /**\r\n   * Lazy static initialization function. Called before\r\n   * accessing any of the static map variables.\r\n   * @private\r\n   */\n  init_: function init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n      // We want quick mappings back and forth, so we precompute two maps.\n      for (var i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n        // Be forgiving when decoding and correctly decode both encodings.\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n/**\r\n * URL-safe base64 encoding\r\n */\nvar base64Encode = function base64Encode(str) {\n  var utf8Bytes = stringToByteArray$1(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */\nvar base64urlEncodeWithoutPadding = function base64urlEncodeWithoutPadding(str) {\n  // Use base64url encoding and remove padding in the end (dot characters).\n  return base64Encode(str).replace(/\\./g, '');\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\nvar base64Decode = function base64Decode(str) {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n  return null;\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\nfunction deepCopy(value) {\n  return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */\nfunction deepExtend(target, source) {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      var dateValue = source;\n      return new Date(dateValue.getTime());\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n      break;\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n  for (var prop in source) {\n    // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n      continue;\n    }\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n  return target;\n}\nfunction isValidKey(key) {\n  return key !== '__proto__';\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\nfunction getUA() {\n  if (typeof navigator !== 'undefined' && typeof navigator['userAgent'] === 'string') {\n    return navigator['userAgent'];\n  } else {\n    return '';\n  }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\nfunction isMobileCordova() {\n  return typeof window !== 'undefined' &&\n  // @ts-ignore Setting up an broadly applicable index signature for Window\n  // just to deal with this case would probably be a bad idea.\n  !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected.\r\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n  try {\n    return Object.prototype.toString.call(__webpack_require__.g.process) === '[object process]';\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Detect Browser Environment\r\n */\nfunction isBrowser() {\n  return (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && self.self === self;\n}\nfunction isBrowserExtension() {\n  var runtime = (typeof chrome === \"undefined\" ? \"undefined\" : _typeof(chrome)) === 'object' ? chrome.runtime : (typeof browser === \"undefined\" ? \"undefined\" : _typeof(browser)) === 'object' ? browser.runtime : undefined;\n  return _typeof(runtime) === 'object' && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\nfunction isReactNative() {\n  return (typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) === 'object' && navigator['product'] === 'ReactNative';\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n  return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n  var ua = getUA();\n  return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n  return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\nfunction isNodeSdk() {\n  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n  return !isNode() && navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\nfunction isIndexedDBAvailable() {\n  try {\n    return (typeof indexedDB === \"undefined\" ? \"undefined\" : _typeof(indexedDB)) === 'object';\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */\nfunction validateIndexedDBOpenable() {\n  return new Promise(function (resolve, reject) {\n    try {\n      var preExist = true;\n      var DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n      var request = self.indexedDB.open(DB_CHECK_NAME);\n      request.onsuccess = function () {\n        request.result.close();\n        // delete database only when it doesn't pre-exist\n        if (!preExist) {\n          self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n        }\n        resolve(true);\n      };\n      request.onupgradeneeded = function () {\n        preExist = false;\n      };\n      request.onerror = function () {\n        var _a;\n        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\nfunction areCookiesEnabled() {\n  if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n */\nfunction getGlobal() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof __webpack_require__.g !== 'undefined') {\n    return __webpack_require__.g;\n  }\n  throw new Error('Unable to locate global object.');\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar getDefaultsFromGlobal = function getDefaultsFromGlobal() {\n  return getGlobal().__FIREBASE_DEFAULTS__;\n};\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process.env.__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process.env.__FIREBASE_DEFAULTS_PATH__\r\n */\nvar getDefaultsFromEnvVariable = function getDefaultsFromEnvVariable() {\n  if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n    return;\n  }\n  var defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n  if (defaultsJsonString) {\n    return JSON.parse(defaultsJsonString);\n  }\n};\nvar getDefaultsFromCookie = function getDefaultsFromCookie() {\n  if (typeof document === 'undefined') {\n    return;\n  }\n  var match;\n  try {\n    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n  } catch (e) {\n    // Some environments such as Angular Universal SSR have a\n    // `document` object but error on accessing `document.cookie`.\n    return;\n  }\n  var decoded = match && base64Decode(match[1]);\n  return decoded && JSON.parse(decoded);\n};\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n */\nvar getDefaults = function getDefaults() {\n  try {\n    return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n  } catch (e) {\n    /**\r\n     * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n     * to any environment case we have not accounted for. Log to\r\n     * info instead of swallowing so we can find these unknown cases\r\n     * and add paths for them if needed.\r\n     */\n    console.info(\"Unable to get __FIREBASE_DEFAULTS__ due to: \".concat(e));\n    return;\n  }\n};\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */\nvar getDefaultEmulatorHost = function getDefaultEmulatorHost(productName) {\n  var _a, _b;\n  return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */\nvar getDefaultEmulatorHostnameAndPort = function getDefaultEmulatorHostnameAndPort(productName) {\n  var host = getDefaultEmulatorHost(productName);\n  if (!host) {\n    return undefined;\n  }\n  var separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n  if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n    throw new Error(\"Invalid host \".concat(host, \" with no separate hostname and port!\"));\n  }\n  // eslint-disable-next-line no-restricted-globals\n  var port = parseInt(host.substring(separatorIndex + 1), 10);\n  if (host[0] === '[') {\n    // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n    return [host.substring(1, separatorIndex - 1), port];\n  } else {\n    return [host.substring(0, separatorIndex), port];\n  }\n};\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */\nvar getDefaultAppConfig = function getDefaultAppConfig() {\n  var _a;\n  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */\nvar getExperimentalSetting = function getExperimentalSetting(name) {\n  var _a;\n  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[\"_\".concat(name)];\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar Deferred = /*#__PURE__*/function () {\n  function Deferred() {\n    var _this = this;\n    _classCallCheck(this, Deferred);\n    this.reject = function () {};\n    this.resolve = function () {};\n    this.promise = new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    });\n  }\n  /**\r\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n   */\n  _createClass(Deferred, [{\n    key: \"wrapCallback\",\n    value: function wrapCallback(callback) {\n      var _this2 = this;\n      return function (error, value) {\n        if (error) {\n          _this2.reject(error);\n        } else {\n          _this2.resolve(value);\n        }\n        if (typeof callback === 'function') {\n          // Attaching noop handler just in case developer wasn't expecting\n          // promises\n          _this2.promise[\"catch\"](function () {});\n          // Some of our callbacks don't expect a value and our own tests\n          // assert that the parameter length is 1\n          if (callback.length === 1) {\n            callback(error);\n          } else {\n            callback(error, value);\n          }\n        }\n      };\n    }\n  }]);\n  return Deferred;\n}();\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction createMockUserToken(token, projectId) {\n  if (token.uid) {\n    throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n  }\n  // Unsecured JWTs use \"none\" as the algorithm.\n  var header = {\n    alg: 'none',\n    type: 'JWT'\n  };\n  var project = projectId || 'demo-project';\n  var iat = token.iat || 0;\n  var sub = token.sub || token.user_id;\n  if (!sub) {\n    throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n  }\n  var payload = Object.assign({\n    // Set all required fields to decent defaults\n    iss: \"https://securetoken.google.com/\".concat(project),\n    aud: project,\n    iat: iat,\n    exp: iat + 3600,\n    auth_time: iat,\n    sub: sub,\n    user_id: sub,\n    firebase: {\n      sign_in_provider: 'custom',\n      identities: {}\n    }\n  }, token);\n  // Unsecured JWTs use the empty string as a signature.\n  var signature = '';\n  return [base64urlEncodeWithoutPadding(JSON.stringify(header)), base64urlEncodeWithoutPadding(JSON.stringify(payload)), signature].join('.');\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */\nvar ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nvar FirebaseError = /*#__PURE__*/function (_Error) {\n  _inherits(FirebaseError, _Error);\n  var _super = _createSuper(FirebaseError);\n  function FirebaseError( /** The error code for this error. */\n  code, message, /** Custom data for this error. */\n  customData) {\n    var _this3;\n    _classCallCheck(this, FirebaseError);\n    _this3 = _super.call(this, message);\n    _this3.code = code;\n    _this3.customData = customData;\n    /** The custom name for all FirebaseErrors. */\n    _this3.name = ERROR_NAME;\n    // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(_assertThisInitialized(_this3), FirebaseError.prototype);\n    // Maintains proper stack trace for where our error was thrown.\n    // Only available on V8.\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this3), ErrorFactory.prototype.create);\n    }\n    return _this3;\n  }\n  return _createClass(FirebaseError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar ErrorFactory = /*#__PURE__*/function () {\n  function ErrorFactory(service, serviceName, errors) {\n    _classCallCheck(this, ErrorFactory);\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors;\n  }\n  _createClass(ErrorFactory, [{\n    key: \"create\",\n    value: function create(code) {\n      var customData = (arguments.length <= 1 ? undefined : arguments[1]) || {};\n      var fullCode = \"\".concat(this.service, \"/\").concat(code);\n      var template = this.errors[code];\n      var message = template ? replaceTemplate(template, customData) : 'Error';\n      // Service Name: Error message (service/code).\n      var fullMessage = \"\".concat(this.serviceName, \": \").concat(message, \" (\").concat(fullCode, \").\");\n      var error = new FirebaseError(fullCode, fullMessage, customData);\n      return error;\n    }\n  }]);\n  return ErrorFactory;\n}();\nfunction replaceTemplate(template, data) {\n  return template.replace(PATTERN, function (_, key) {\n    var value = data[key];\n    return value != null ? String(value) : \"<\".concat(key, \"?>\");\n  });\n}\nvar PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\nfunction jsonEval(str) {\n  return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\nfunction stringify(data) {\n  return JSON.stringify(data);\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\nvar decode = function decode(token) {\n  var header = {},\n    claims = {},\n    data = {},\n    signature = '';\n  try {\n    var parts = token.split('.');\n    header = jsonEval(base64Decode(parts[0]) || '');\n    claims = jsonEval(base64Decode(parts[1]) || '');\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n  return {\n    header: header,\n    claims: claims,\n    data: data,\n    signature: signature\n  };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\nvar isValidTimestamp = function isValidTimestamp(token) {\n  var claims = decode(token).claims;\n  var now = Math.floor(new Date().getTime() / 1000);\n  var validSince = 0,\n    validUntil = 0;\n  if (_typeof(claims) === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'];\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'];\n    }\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'];\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n  return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\nvar issuedAtTime = function issuedAtTime(token) {\n  var claims = decode(token).claims;\n  if (_typeof(claims) === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'];\n  }\n  return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\nvar isValidFormat = function isValidFormat(token) {\n  var decoded = decode(token),\n    claims = decoded.claims;\n  return !!claims && _typeof(claims) === 'object' && claims.hasOwnProperty('iat');\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\nvar isAdmin = function isAdmin(token) {\n  var claims = decode(token).claims;\n  return _typeof(claims) === 'object' && claims['admin'] === true;\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction contains(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n  if (Object.prototype.hasOwnProperty.call(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\nfunction isEmpty(obj) {\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction map(obj, fn, contextObj) {\n  var res = {};\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      res[key] = fn.call(contextObj, obj[key], key, obj);\n    }\n  }\n  return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {\n    var k = _aKeys[_i];\n    if (!bKeys.includes(k)) {\n      return false;\n    }\n    var aProp = a[k];\n    var bProp = b[k];\n    if (isObject(aProp) && isObject(bProp)) {\n      if (!deepEqual(aProp, bProp)) {\n        return false;\n      }\n    } else if (aProp !== bProp) {\n      return false;\n    }\n  }\n  for (var _i2 = 0, _bKeys = bKeys; _i2 < _bKeys.length; _i2++) {\n    var _k = _bKeys[_i2];\n    if (!aKeys.includes(_k)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isObject(thing) {\n  return thing !== null && _typeof(thing) === 'object';\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */\nfunction promiseWithTimeout(promise) {\n  var timeInMS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n  var deferredPromise = new Deferred();\n  setTimeout(function () {\n    return deferredPromise.reject('timeout!');\n  }, timeInMS);\n  promise.then(deferredPromise.resolve, deferredPromise.reject);\n  return deferredPromise.promise;\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\nfunction querystring(querystringParams) {\n  var params = [];\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),\n      key = _Object$entries$_i[0],\n      value = _Object$entries$_i[1];\n    if (Array.isArray(value)) {\n      value.forEach(function (arrayVal) {\n        params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n      });\n    } else {\n      params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n    }\n  };\n  for (var _i3 = 0, _Object$entries = Object.entries(querystringParams); _i3 < _Object$entries.length; _i3++) {\n    _loop();\n  }\n  return params.length ? '&' + params.join('&') : '';\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\nfunction querystringDecode(querystring) {\n  var obj = {};\n  var tokens = querystring.replace(/^\\?/, '').split('&');\n  tokens.forEach(function (token) {\n    if (token) {\n      var _token$split = token.split('='),\n        _token$split2 = _slicedToArray(_token$split, 2),\n        key = _token$split2[0],\n        value = _token$split2[1];\n      obj[decodeURIComponent(key)] = decodeURIComponent(value);\n    }\n  });\n  return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */\nfunction extractQuerystring(url) {\n  var queryStart = url.indexOf('?');\n  if (!queryStart) {\n    return '';\n  }\n  var fragmentStart = url.indexOf('#', queryStart);\n  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\nvar Sha1 = /*#__PURE__*/function () {\n  function Sha1() {\n    _classCallCheck(this, Sha1);\n    /**\r\n     * Holds the previous values of accumulated variables a-e in the compress_\r\n     * function.\r\n     * @private\r\n     */\n    this.chain_ = [];\n    /**\r\n     * A buffer holding the partially computed hash result.\r\n     * @private\r\n     */\n    this.buf_ = [];\n    /**\r\n     * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n     * as the message schedule in the docs.\r\n     * @private\r\n     */\n    this.W_ = [];\n    /**\r\n     * Contains data needed to pad messages less than 64 bytes.\r\n     * @private\r\n     */\n    this.pad_ = [];\n    /**\r\n     * @private {number}\r\n     */\n    this.inbuf_ = 0;\n    /**\r\n     * @private {number}\r\n     */\n    this.total_ = 0;\n    this.blockSize = 512 / 8;\n    this.pad_[0] = 128;\n    for (var i = 1; i < this.blockSize; ++i) {\n      this.pad_[i] = 0;\n    }\n    this.reset();\n  }\n  _createClass(Sha1, [{\n    key: \"reset\",\n    value: function reset() {\n      this.chain_[0] = 0x67452301;\n      this.chain_[1] = 0xefcdab89;\n      this.chain_[2] = 0x98badcfe;\n      this.chain_[3] = 0x10325476;\n      this.chain_[4] = 0xc3d2e1f0;\n      this.inbuf_ = 0;\n      this.total_ = 0;\n    }\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */\n  }, {\n    key: \"compress_\",\n    value: function compress_(buf, offset) {\n      if (!offset) {\n        offset = 0;\n      }\n      var W = this.W_;\n      // get 16 big endian words\n      if (typeof buf === 'string') {\n        for (var i = 0; i < 16; i++) {\n          // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n          // have a bug that turns the post-increment ++ operator into pre-increment\n          // during JIT compilation.  We have code that depends heavily on SHA-1 for\n          // correctness and which is affected by this bug, so I've removed all uses\n          // of post-increment ++ in which the result value is used.  We can revert\n          // this change once the Safari bug\n          // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n          // most clients have been updated.\n          W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n          offset += 4;\n        }\n      } else {\n        for (var _i4 = 0; _i4 < 16; _i4++) {\n          W[_i4] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n          offset += 4;\n        }\n      }\n      // expand to 80 words\n      for (var _i5 = 16; _i5 < 80; _i5++) {\n        var t = W[_i5 - 3] ^ W[_i5 - 8] ^ W[_i5 - 14] ^ W[_i5 - 16];\n        W[_i5] = (t << 1 | t >>> 31) & 0xffffffff;\n      }\n      var a = this.chain_[0];\n      var b = this.chain_[1];\n      var c = this.chain_[2];\n      var d = this.chain_[3];\n      var e = this.chain_[4];\n      var f, k;\n      // TODO(user): Try to unroll this loop to speed up the computation.\n      for (var _i6 = 0; _i6 < 80; _i6++) {\n        if (_i6 < 40) {\n          if (_i6 < 20) {\n            f = d ^ b & (c ^ d);\n            k = 0x5a827999;\n          } else {\n            f = b ^ c ^ d;\n            k = 0x6ed9eba1;\n          }\n        } else {\n          if (_i6 < 60) {\n            f = b & c | d & (b | c);\n            k = 0x8f1bbcdc;\n          } else {\n            f = b ^ c ^ d;\n            k = 0xca62c1d6;\n          }\n        }\n        var _t = (a << 5 | a >>> 27) + f + e + k + W[_i6] & 0xffffffff;\n        e = d;\n        d = c;\n        c = (b << 30 | b >>> 2) & 0xffffffff;\n        b = a;\n        a = _t;\n      }\n      this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n      this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n      this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n      this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n      this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n    }\n  }, {\n    key: \"update\",\n    value: function update(bytes, length) {\n      // TODO(johnlenz): tighten the function signature and remove this check\n      if (bytes == null) {\n        return;\n      }\n      if (length === undefined) {\n        length = bytes.length;\n      }\n      var lengthMinusBlock = length - this.blockSize;\n      var n = 0;\n      // Using local instead of member variables gives ~5% speedup on Firefox 16.\n      var buf = this.buf_;\n      var inbuf = this.inbuf_;\n      // The outer while loop should execute at most twice.\n      while (n < length) {\n        // When we have no data in the block to top up, we can directly process the\n        // input buffer (assuming it contains sufficient data). This gives ~25%\n        // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n        // the data is provided in large chunks (or in multiples of 64 bytes).\n        if (inbuf === 0) {\n          while (n <= lengthMinusBlock) {\n            this.compress_(bytes, n);\n            n += this.blockSize;\n          }\n        }\n        if (typeof bytes === 'string') {\n          while (n < length) {\n            buf[inbuf] = bytes.charCodeAt(n);\n            ++inbuf;\n            ++n;\n            if (inbuf === this.blockSize) {\n              this.compress_(buf);\n              inbuf = 0;\n              // Jump to the outer loop so we use the full-block optimization.\n              break;\n            }\n          }\n        } else {\n          while (n < length) {\n            buf[inbuf] = bytes[n];\n            ++inbuf;\n            ++n;\n            if (inbuf === this.blockSize) {\n              this.compress_(buf);\n              inbuf = 0;\n              // Jump to the outer loop so we use the full-block optimization.\n              break;\n            }\n          }\n        }\n      }\n      this.inbuf_ = inbuf;\n      this.total_ += length;\n    }\n    /** @override */\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var digest = [];\n      var totalBits = this.total_ * 8;\n      // Add pad 0x80 0x00*.\n      if (this.inbuf_ < 56) {\n        this.update(this.pad_, 56 - this.inbuf_);\n      } else {\n        this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n      }\n      // Add # bits.\n      for (var i = this.blockSize - 1; i >= 56; i--) {\n        this.buf_[i] = totalBits & 255;\n        totalBits /= 256; // Don't use bit-shifting here!\n      }\n\n      this.compress_(this.buf_);\n      var n = 0;\n      for (var _i7 = 0; _i7 < 5; _i7++) {\n        for (var j = 24; j >= 0; j -= 8) {\n          digest[n] = this.chain_[_i7] >> j & 255;\n          ++n;\n        }\n      }\n      return digest;\n    }\n  }]);\n  return Sha1;\n}();\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\nfunction createSubscribe(executor, onNoObservers) {\n  var proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\nvar ObserverProxy = /*#__PURE__*/function () {\n  /**\r\n   * @param executor Function which can make calls to a single Observer\r\n   *     as a proxy.\r\n   * @param onNoObservers Callback when count of Observers goes to zero.\r\n   */\n  function ObserverProxy(executor, onNoObservers) {\n    var _this4 = this;\n    _classCallCheck(this, ObserverProxy);\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0;\n    // Micro-task scheduling by calling task.then().\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task.then(function () {\n      executor(_this4);\n    })[\"catch\"](function (e) {\n      _this4.error(e);\n    });\n  }\n  _createClass(ObserverProxy, [{\n    key: \"next\",\n    value: function next(value) {\n      this.forEachObserver(function (observer) {\n        observer.next(value);\n      });\n    }\n  }, {\n    key: \"error\",\n    value: function error(_error) {\n      this.forEachObserver(function (observer) {\n        observer.error(_error);\n      });\n      this.close(_error);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.forEachObserver(function (observer) {\n        observer.complete();\n      });\n      this.close();\n    }\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(nextOrObserver, error, complete) {\n      var _this5 = this;\n      var observer;\n      if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n        throw new Error('Missing Observer.');\n      }\n      // Assemble an Observer object when passed as callback functions.\n      if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n        observer = nextOrObserver;\n      } else {\n        observer = {\n          next: nextOrObserver,\n          error: error,\n          complete: complete\n        };\n      }\n      if (observer.next === undefined) {\n        observer.next = noop;\n      }\n      if (observer.error === undefined) {\n        observer.error = noop;\n      }\n      if (observer.complete === undefined) {\n        observer.complete = noop;\n      }\n      var unsub = this.unsubscribeOne.bind(this, this.observers.length);\n      // Attempt to subscribe to a terminated Observable - we\n      // just respond to the Observer with the final error or complete\n      // event.\n      if (this.finalized) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(function () {\n          try {\n            if (_this5.finalError) {\n              observer.error(_this5.finalError);\n            } else {\n              observer.complete();\n            }\n          } catch (e) {\n            // nothing\n          }\n          return;\n        });\n      }\n      this.observers.push(observer);\n      return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n  }, {\n    key: \"unsubscribeOne\",\n    value: function unsubscribeOne(i) {\n      if (this.observers === undefined || this.observers[i] === undefined) {\n        return;\n      }\n      delete this.observers[i];\n      this.observerCount -= 1;\n      if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n        this.onNoObservers(this);\n      }\n    }\n  }, {\n    key: \"forEachObserver\",\n    value: function forEachObserver(fn) {\n      if (this.finalized) {\n        // Already closed by previous event....just eat the additional values.\n        return;\n      }\n      // Since sendOne calls asynchronously - there is no chance that\n      // this.observers will become undefined.\n      for (var i = 0; i < this.observers.length; i++) {\n        this.sendOne(i, fn);\n      }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n  }, {\n    key: \"sendOne\",\n    value: function sendOne(i, fn) {\n      var _this6 = this;\n      // Execute the callback asynchronously\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.task.then(function () {\n        if (_this6.observers !== undefined && _this6.observers[i] !== undefined) {\n          try {\n            fn(_this6.observers[i]);\n          } catch (e) {\n            // Ignore exceptions raised in Observers or missing methods of an\n            // Observer.\n            // Log error to console. b/31404806\n            if (typeof console !== 'undefined' && console.error) {\n              console.error(e);\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(err) {\n      var _this7 = this;\n      if (this.finalized) {\n        return;\n      }\n      this.finalized = true;\n      if (err !== undefined) {\n        this.finalError = err;\n      }\n      // Proxy is no longer needed - garbage collect references\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.task.then(function () {\n        _this7.observers = undefined;\n        _this7.onNoObservers = undefined;\n      });\n    }\n  }]);\n  return ObserverProxy;\n}();\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    Promise.resolve(true).then(function () {\n      fn.apply(void 0, args);\n    })[\"catch\"](function (error) {\n      if (onError) {\n        onError(error);\n      }\n    });\n  };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\nfunction implementsAnyMethods(obj, methods) {\n  if (_typeof(obj) !== 'object' || obj === null) {\n    return false;\n  }\n  var _iterator = _createForOfIteratorHelper(methods),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var method = _step.value;\n      if (method in obj && typeof obj[method] === 'function') {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return false;\n}\nfunction noop() {\n  // do nothing\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\nvar validateArgCount = function validateArgCount(fnName, minCount, maxCount, argCount) {\n  var argError;\n  if (argCount < minCount) {\n    argError = 'at least ' + minCount;\n  } else if (argCount > maxCount) {\n    argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n  }\n  if (argError) {\n    var error = fnName + ' failed: Was called with ' + argCount + (argCount === 1 ? ' argument.' : ' arguments.') + ' Expects ' + argError + '.';\n    throw new Error(error);\n  }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */\nfunction errorPrefix(fnName, argName) {\n  return \"\".concat(fnName, \" failed: \").concat(argName, \" argument \");\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\nfunction validateNamespace(fnName, namespace, optional) {\n  if (optional && !namespace) {\n    return;\n  }\n  if (typeof namespace !== 'string') {\n    //TODO: I should do more validation here. We only allow certain chars in namespaces.\n    throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n  }\n}\nfunction validateCallback(fnName, argumentName,\n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n  if (optional && !callback) {\n    return;\n  }\n  if (typeof callback !== 'function') {\n    throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n  }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n  if (optional && !context) {\n    return;\n  }\n  if (_typeof(context) !== 'object' || context === null) {\n    throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n  }\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\nvar stringToByteArray = function stringToByteArray(str) {\n  var out = [];\n  var p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    // Is this the lead surrogate in a surrogate pair?\n    if (c >= 0xd800 && c <= 0xdbff) {\n      var high = c - 0xd800; // the high 10 bits.\n      i++;\n      assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n      var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n      c = 0x10000 + (high << 10) + low;\n    }\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if (c < 65536) {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n  return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\nvar stringLength = function stringLength(str) {\n  var p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c < 128) {\n      p++;\n    } else if (c < 2048) {\n      p += 2;\n    } else if (c >= 0xd800 && c <= 0xdbff) {\n      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n      p += 4;\n      i++; // skip trail surrogate.\n    } else {\n      p += 3;\n    }\n  }\n  return p;\n};\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */\nvar uuidv4 = function uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n      v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\nvar DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\nvar DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\nvar MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\nvar RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\nfunction calculateBackoffMillis(backoffCount) {\n  var intervalMillis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_INTERVAL_MILLIS;\n  var backoffFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BACKOFF_FACTOR;\n  // Calculates an exponentially increasing value.\n  // Deviation: calculates value from count and a constant interval, so we only need to save value\n  // and count to restore state.\n  var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n  // A random \"fuzz\" to avoid waves of retries.\n  // Deviation: randomFactor is required.\n  var randomWait = Math.round(\n  // A fraction of the backoff value to add/subtract.\n  // Deviation: changes multiplication order to improve readability.\n  RANDOM_FACTOR * currBaseValue * (\n  // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n  // if we add or subtract.\n  Math.random() - 0.5) * 2);\n  // Limits backoff to max to avoid effectively permanent backoff.\n  return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Provide English ordinal letters after a number\r\n */\nfunction ordinal(i) {\n  if (!Number.isFinite(i)) {\n    return \"\".concat(i);\n  }\n  return i + indicator(i);\n}\nfunction indicator(i) {\n  i = Math.abs(i);\n  var cent = i % 100;\n  if (cent >= 10 && cent <= 20) {\n    return 'th';\n  }\n  var dec = i % 10;\n  if (dec === 1) {\n    return 'st';\n  }\n  if (dec === 2) {\n    return 'nd';\n  }\n  if (dec === 3) {\n    return 'rd';\n  }\n  return 'th';\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction getModularInstance(service) {\n  if (service && service._delegate) {\n    return service._delegate;\n  } else {\n    return service;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9pbmRleC5lc20yMDE3LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQUVIOztBQUVHO0FBRVUsYUFBUyxHQUFHO0VBQ3ZCOztBQUVHO0VBQ0hBLFdBQVcsRUFBRSxLQUFLO0VBQ2xCOztBQUVHO0VBQ0hDLFVBQVUsRUFBRSxLQUFLO0VBRWpCOztBQUVHO0VBQ0hDLFdBQVcsRUFBRTs7O0FDbENmOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQUlIOztBQUVHO0FBQ1UsVUFBTSxHQUFHLFNBQVRDLE1BQU0sQ0FBYUMsU0FBa0IsRUFBRUMsT0FBZTtFQUNqRSxJQUFJLENBQUNELFNBQVMsRUFBRTtJQUNkLE1BQU1FLGNBQWMsQ0FBQ0QsT0FBTyxDQUFDO0VBQzlCO0FBQ0g7QUFFQTs7QUFFRztBQUNJLElBQU1DLGNBQWMsR0FBRyxTQUFqQkEsY0FBYyxDQUFhRCxPQUFlO0VBQ3JELE9BQU8sSUFBSUUsS0FBSyxDQUNkLHFCQUFxQixHQUNuQkMsU0FBUyxDQUFDTixXQUFXLEdBQ3JCLDRCQUE0QixHQUM1QkcsT0FBTyxDQUNWO0FBQ0g7O0FDdENBOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQUVILElBQU1JLG1CQUFpQixHQUFHLFNBQXBCQSxtQkFBaUIsQ0FBYUMsR0FBVzs7RUFFN0MsSUFBTUMsR0FBRyxHQUFhLEVBQUU7RUFDeEIsSUFBSUMsQ0FBQyxHQUFHLENBQUM7RUFDVCxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0gsR0FBRyxDQUFDSSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQ25DLElBQUlFLENBQUMsR0FBR0wsR0FBRyxDQUFDTSxVQUFVLENBQUNILENBQUMsQ0FBQztJQUN6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UyxDQUFDclUsQ0FBQyxDQUFDO0FBQ3pCO0FBRUEsU0FBU3FVLFNBQVMsQ0FBQ3JVLENBQVM7RUFDMUJBLENBQUMsR0FBR29NLElBQUksQ0FBQ2tJLEdBQUcsQ0FBQ3RVLENBQUMsQ0FBQztFQUNmLElBQU11VSxJQUFJLEdBQUd2VSxDQUFDLEdBQUcsR0FBRztFQUNwQixJQUFJdVUsSUFBSSxJQUFJLEVBQUUsSUFBSUEsSUFBSSxJQUFJLEVBQUUsRUFBRTtJQUM1QixPQUFPLElBQUk7RUFDWjtFQUNELElBQU1DLEdBQUcsR0FBR3hVLENBQUMsR0FBRyxFQUFFO0VBQ2xCLElBQUl3VSxHQUFHLEtBQUssQ0FBQyxFQUFFO0lBQ2IsT0FBTyxJQUFJO0VBQ1o7RUFDRCxJQUFJQSxHQUFHLEtBQUssQ0FBQyxFQUFFO0lBQ2IsT0FBTyxJQUFJO0VBQ1o7RUFDRCxJQUFJQSxHQUFHLEtBQUssQ0FBQyxFQUFFO0lBQ2IsT0FBTyxJQUFJO0VBQ1o7RUFDRCxPQUFPLElBQUk7QUFDYjs7QUM1Q0E7Ozs7Ozs7Ozs7Ozs7OztBQWVHO0FBTUcsU0FBVUMsa0JBQWtCLENBQ2hDdEosT0FBd0M7RUFFeEMsSUFBSUEsT0FBTyxJQUFLQSxPQUE4QixDQUFDdUosU0FBUyxFQUFFO0lBQ3hELE9BQVF2SixPQUE4QixDQUFDdUosU0FBUztFQUNqRCxPQUFNO0lBQ0wsT0FBT3ZKLE9BQXFCO0VBQzdCO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9jb25zdGFudHMudHM/MzViMCIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9hc3NlcnQudHM/MTJmOCIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9jcnlwdC50cz8zYmExIiwid2VicGFjazovL2xpYnJhcnkvLi4vc3JjL2RlZXBDb3B5LnRzP2U5MTQiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvZW52aXJvbm1lbnQudHM/MTQ2ZSIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9kZWZhdWx0cy50cz81MmY3Iiwid2VicGFjazovL2xpYnJhcnkvLi4vc3JjL2RlZmVycmVkLnRzPzIxNzYiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvZW11bGF0b3IudHM/OTBmMiIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9lcnJvcnMudHM/M2Q1YiIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9qc29uLnRzPzBkYjQiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvand0LnRzPzE1NmYiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvb2JqLnRzPzc0NTkiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvcHJvbWlzZS50cz9jN2JjIiwid2VicGFjazovL2xpYnJhcnkvLi4vc3JjL3F1ZXJ5LnRzPzFlMzgiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvc2hhMS50cz8zODNiIiwid2VicGFjazovL2xpYnJhcnkvLi4vc3JjL3N1YnNjcmliZS50cz85ODgzIiwid2VicGFjazovL2xpYnJhcnkvLi4vc3JjL3ZhbGlkYXRpb24udHM/ZGU2ZiIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy91dGY4LnRzPzEzYzUiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvdXVpZC50cz9kM2NiIiwid2VicGFjazovL2xpYnJhcnkvLi4vc3JjL2V4cG9uZW50aWFsX2JhY2tvZmYudHM/MGM3MCIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uL3NyYy9mb3JtYXR0ZXJzLnRzP2ZkNWMiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi9zcmMvY29tcGF0LnRzPzQzZTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UUyA9IHtcbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxuICAgKi9cbiAgTk9ERV9DTElFTlQ6IGZhbHNlLFxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICovXG4gIE5PREVfQURNSU46IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgKi9cbiAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb246IHVua25vd24sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gRXJyb3Igb2JqZWN0IHN1aXRhYmxlIGZvciB0aHJvd2luZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAnRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcbiAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xuICAgICAgbWVzc2FnZVxuICApO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogbnVtYmVyW10ge1xuICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICBjb25zdCBvdXQ6IG51bWJlcltdID0gW107XG4gIGxldCBwID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICBvdXRbcCsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG4gICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcbiAgICAgIChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZjMDApID09PSAweGRjMDBcbiAgICApIHtcbiAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxuICovXG5jb25zdCBieXRlQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlczogbnVtYmVyW10pOiBzdHJpbmcge1xuICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XG4gIGxldCBwb3MgPSAwLFxuICAgIGMgPSAwO1xuICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XG4gICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcbiAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAzMSkgPDwgNikgfCAoYzIgJiA2MykpO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcbiAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XG4gICAgICBjb25zdCB1ID1cbiAgICAgICAgKCgoYzEgJiA3KSA8PCAxOCkgfCAoKGMyICYgNjMpIDw8IDEyKSB8ICgoYzMgJiA2MykgPDwgNikgfCAoYzQgJiA2MykpIC1cbiAgICAgICAgMHgxMDAwMDtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAodSA+PiAxMCkpO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAoKGMxICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MylcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQuam9pbignJyk7XG59O1xuXG5pbnRlcmZhY2UgQmFzZTY0IHtcbiAgYnl0ZVRvQ2hhck1hcF86IHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0gfCBudWxsO1xuICBjaGFyVG9CeXRlTWFwXzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB8IG51bGw7XG4gIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogeyBba2V5OiBudW1iZXJdOiBzdHJpbmcgfSB8IG51bGw7XG4gIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB8IG51bGw7XG4gIEVOQ09ERURfVkFMU19CQVNFOiBzdHJpbmc7XG4gIHJlYWRvbmx5IEVOQ09ERURfVkFMUzogc3RyaW5nO1xuICByZWFkb25seSBFTkNPREVEX1ZBTFNfV0VCU0FGRTogc3RyaW5nO1xuICBIQVNfTkFUSVZFX1NVUFBPUlQ6IGJvb2xlYW47XG4gIGVuY29kZUJ5dGVBcnJheShpbnB1dDogbnVtYmVyW10gfCBVaW50OEFycmF5LCB3ZWJTYWZlPzogYm9vbGVhbik6IHN0cmluZztcbiAgZW5jb2RlU3RyaW5nKGlucHV0OiBzdHJpbmcsIHdlYlNhZmU/OiBib29sZWFuKTogc3RyaW5nO1xuICBkZWNvZGVTdHJpbmcoaW5wdXQ6IHN0cmluZywgd2ViU2FmZTogYm9vbGVhbik6IHN0cmluZztcbiAgZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQ6IHN0cmluZywgd2ViU2FmZTogYm9vbGVhbik6IG51bWJlcltdO1xuICBpbml0XygpOiB2b2lkO1xufVxuXG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcbi8vIFN0YXRpYyBsb29rdXAgbWFwcywgbGF6aWx5IHBvcHVsYXRlZCBieSBpbml0XygpXG5leHBvcnQgY29uc3QgYmFzZTY0OiBCYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXG4gICAqL1xuICBieXRlVG9DaGFyTWFwXzogbnVsbCxcblxuICAvKipcbiAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgKi9cbiAgY2hhclRvQnl0ZU1hcF86IG51bGwsXG5cbiAgLyoqXG4gICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxuXG4gIC8qKlxuICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcblxuICAvKipcbiAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXG4gICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcbiAgICovXG4gIEVOQ09ERURfVkFMU19CQVNFOlxuICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuXG4gIC8qKlxuICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxuICAgKi9cbiAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cbiAgICovXG4gIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXG4gICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcbiAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxuICAgKlxuICAgKi9cbiAgSEFTX05BVElWRV9TVVBQT1JUOiB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJyxcblxuICAvKipcbiAgICogQmFzZTY0LWVuY29kZSBhbiBhcnJheSBvZiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcbiAgICogICAgIHZhbHVlIGluIFswLCAyNTVdKSB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICovXG4gIGVuY29kZUJ5dGVBcnJheShpbnB1dDogbnVtYmVyW10gfCBVaW50OEFycmF5LCB3ZWJTYWZlPzogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdF8oKTtcblxuICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXG4gICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfIVxuICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfITtcblxuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcbiAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xuICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XG4gICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGlucHV0W2kgKyAyXSA6IDA7XG5cbiAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuXG4gICAgICBpZiAoIWhhdmVCeXRlMykge1xuICAgICAgICBvdXRCeXRlNCA9IDY0O1xuXG4gICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgb3V0Qnl0ZTMgPSA2NDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sXG4gICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLFxuICAgICAgICBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSxcbiAgICAgICAgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqL1xuICBlbmNvZGVTdHJpbmcoaW5wdXQ6IHN0cmluZywgd2ViU2FmZT86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgcmV0dXJuIGJ0b2EoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmNvZGVCeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQpLCB3ZWJTYWZlKTtcbiAgfSxcblxuICAvKipcbiAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxuICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICovXG4gIGRlY29kZVN0cmluZyhpbnB1dDogc3RyaW5nLCB3ZWJTYWZlOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcbiAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICpcbiAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICogYnl0ZXMuICBJZiB0aGUgZW5jb2RlciBkaWQgbm90IGFwcGx5IHBhZGRpbmcsIHRoZSBpbnB1dCBsZW5ndGggbWF5IG5vdFxuICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXG4gICAqXG4gICAqIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgZ3JvdXAgd2lsbCBoYXZlIGZld2VyIHRoYW4gNCBjaGFyYWN0ZXJzLCBhbmRcbiAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcbiAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxuICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICovXG4gIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0OiBzdHJpbmcsIHdlYlNhZmU6IGJvb2xlYW4pOiBudW1iZXJbXSB7XG4gICAgdGhpcy5pbml0XygpO1xuXG4gICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcbiAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8hXG4gICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF8hO1xuXG4gICAgY29uc3Qgb3V0cHV0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcblxuICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogMDtcbiAgICAgICsraTtcblxuICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICArK2k7XG5cbiAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgKytpO1xuXG4gICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcbiAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcblxuICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xuICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweGYwKSB8IChieXRlMyA+PiAyKTtcbiAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTIpO1xuXG4gICAgICAgIGlmIChieXRlNCAhPT0gNjQpIHtcbiAgICAgICAgICBjb25zdCBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweGMwKSB8IGJ5dGU0O1xuICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXG4gICAqIGFjY2Vzc2luZyBhbnkgb2YgdGhlIHN0YXRpYyBtYXAgdmFyaWFibGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdF8oKSB7XG4gICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XG4gICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XG4gICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcblxuICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTkNPREVEX1ZBTFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcbiAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldXSA9IGk7XG4gICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XG4gICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXG4gICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICovXG5leHBvcnQgY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcbiAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nICh3aXRob3V0IFwiLlwiIHBhZGRpbmcgaW4gdGhlIGVuZCkuXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cbiAgcmV0dXJuIGJhc2U2NEVuY29kZShzdHIpLnJlcGxhY2UoL1xcLi9nLCAnJyk7XG59O1xuXG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xuICpcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxuICovXG5leHBvcnQgY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQ+KHZhbHVlOiBUKTogVCB7XG4gIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpIGFzIFQ7XG59XG5cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxuICogKGFuZCByZXR1cm5lZCkuXG4gKlxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cbiAqXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldDogdW5rbm93biwgc291cmNlOiB1bmtub3duKTogdW5rbm93biB7XG4gIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIERhdGU6XG4gICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxuICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxuICAgICAgY29uc3QgZGF0ZVZhbHVlID0gc291cmNlIGFzIERhdGU7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVZhbHVlLmdldFRpbWUoKSk7XG5cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQXJyYXk6XG4gICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cbiAgICAgIHRhcmdldCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxuICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgKHRhcmdldCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbcHJvcF0gPSBkZWVwRXh0ZW5kKFxuICAgICAgKHRhcmdldCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbcHJvcF0sXG4gICAgICAoc291cmNlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtwcm9wXVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cbiAqIEByZXR1cm4gdXNlciBhZ2VudCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVBKCk6IHN0cmluZyB7XG4gIGlmIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlIFNldHRpbmcgdXAgYW4gYnJvYWRseSBhcHBsaWNhYmxlIGluZGV4IHNpZ25hdHVyZSBmb3IgV2luZG93XG4gICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXG4gICAgISEod2luZG93Wydjb3Jkb3ZhJ10gfHwgd2luZG93WydwaG9uZWdhcCddIHx8IHdpbmRvd1snUGhvbmVHYXAnXSkgJiZcbiAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChnZXRVQSgpKVxuICApO1xufVxuXG4vKipcbiAqIERldGVjdCBOb2RlLmpzLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBOb2RlLmpzIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxuICovXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGUoKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJ1xuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgQnJvd3NlciBFbnZpcm9ubWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZjtcbn1cblxuLyoqXG4gKiBEZXRlY3QgYnJvd3NlciBleHRlbnNpb25zIChDaHJvbWUgYW5kIEZpcmVmb3ggYXQgbGVhc3QpLlxuICovXG5pbnRlcmZhY2UgQnJvd3NlclJ1bnRpbWUge1xuICBpZD86IHVua25vd247XG59XG5kZWNsYXJlIGNvbnN0IGNocm9tZTogeyBydW50aW1lPzogQnJvd3NlclJ1bnRpbWUgfTtcbmRlY2xhcmUgY29uc3QgYnJvd3NlcjogeyBydW50aW1lPzogQnJvd3NlclJ1bnRpbWUgfTtcbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJ1bnRpbWUgPVxuICAgIHR5cGVvZiBjaHJvbWUgPT09ICdvYmplY3QnXG4gICAgICA/IGNocm9tZS5ydW50aW1lXG4gICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xuICAgICAgPyBicm93c2VyLnJ1bnRpbWVcbiAgICAgIDogdW5kZWZpbmVkO1xuICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZSdcbiAgKTtcbn1cblxuLyoqIERldGVjdHMgRWxlY3Ryb24gYXBwcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZWN0cm9uKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xufVxuXG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lFKCk6IGJvb2xlYW4ge1xuICBjb25zdCB1YSA9IGdldFVBKCk7XG4gIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xufVxuXG4vKiogRGV0ZWN0cyBVbml2ZXJzYWwgV2luZG93cyBQbGF0Zm9ybSBhcHBzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVVdQKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcbn1cblxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVTZGsoKTogYm9vbGVhbiB7XG4gIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gU2FmYXJpLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgICFpc05vZGUoKSAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ1NhZmFyaScpICYmXG4gICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpXG4gICk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIGluZGV4ZWREQiA9PT0gJ29iamVjdCc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB2YWxpZGF0ZXMgYnJvd3Nlci9zdyBjb250ZXh0IGZvciBpbmRleGVkREIgYnkgb3BlbmluZyBhIGR1bW15IGluZGV4ZWREQiBkYXRhYmFzZSBhbmQgcmVqZWN0XG4gKiBpZiBlcnJvcnMgb2NjdXIgZHVyaW5nIHRoZSBkYXRhYmFzZSBvcGVuIG9wZXJhdGlvbi5cbiAqXG4gKiBAdGhyb3dzIGV4Y2VwdGlvbiBpZiBjdXJyZW50IGJyb3dzZXIvc3cgY29udGV4dCBjYW4ndCBydW4gaWRiLm9wZW4gKGV4OiBTYWZhcmkgaWZyYW1lLCBGaXJlZm94XG4gKiBwcml2YXRlIGJyb3dzaW5nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHByZUV4aXN0OiBib29sZWFuID0gdHJ1ZTtcbiAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPVxuICAgICAgICAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICByZXF1ZXN0LnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAvLyBkZWxldGUgZGF0YWJhc2Ugb25seSB3aGVuIGl0IGRvZXNuJ3QgcHJlLWV4aXN0XG4gICAgICAgIGlmICghcHJlRXhpc3QpIHtcbiAgICAgICAgICBzZWxmLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShEQl9DSEVDS19OQU1FKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xuICAgICAgICBwcmVFeGlzdCA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcj8ubWVzc2FnZSB8fCAnJyk7XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICpcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWwoKTogdHlwZW9mIGdsb2JhbFRoaXMge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZTY0RGVjb2RlIH0gZnJvbSAnLi9jcnlwdCc7XG5pbXBvcnQgeyBnZXRHbG9iYWwgfSBmcm9tICcuL2Vudmlyb25tZW50JztcblxuLyoqXG4gKiBLZXlzIGZvciBleHBlcmltZW50YWwgcHJvcGVydGllcyBvbiB0aGUgYEZpcmViYXNlRGVmYXVsdHNgIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRXhwZXJpbWVudGFsS2V5ID0gJ2F1dGhUb2tlblN5bmNVUkwnIHwgJ2F1dGhJZFRva2VuTWF4QWdlJztcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gYmUgaW5qZWN0ZWQgaW50byB0aGUgZW52aXJvbm1lbnQgYXMgX19GSVJFQkFTRV9ERUZBVUxUU19fLFxuICogZWl0aGVyIGFzIGEgcHJvcGVydHkgb2YgZ2xvYmFsVGhpcywgYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgb3IgYVxuICogY29va2llLlxuICpcbiAqIFRoaXMgb2JqZWN0IGNhbiBiZSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgY29uZmlndXJlIGFuZCBpbml0aWFsaXplXG4gKiBhIEZpcmViYXNlIGFwcCBhcyB3ZWxsIGFzIGFueSBlbXVsYXRvcnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpcmViYXNlRGVmYXVsdHMge1xuICBjb25maWc/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBlbXVsYXRvckhvc3RzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgX2F1dGhUb2tlblN5bmNVUkw/OiBzdHJpbmc7XG4gIF9hdXRoSWRUb2tlbk1heEFnZT86IG51bWJlcjtcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBOZWVkIGB2YXJgIGZvciB0aGlzIHRvIHdvcmsuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcbiAgdmFyIF9fRklSRUJBU0VfREVGQVVMVFNfXzogRmlyZWJhc2VEZWZhdWx0cyB8IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCk6IEZpcmViYXNlRGVmYXVsdHMgfCB1bmRlZmluZWQgPT5cbiAgZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcmVhZCBkZWZhdWx0cyBmcm9tIGEgSlNPTiBzdHJpbmcgcHJvdmlkZWQgdG9cbiAqIHByb2Nlc3MuZW52Ll9fRklSRUJBU0VfREVGQVVMVFNfXyBvciBhIEpTT04gZmlsZSB3aG9zZSBwYXRoIGlzIGluXG4gKiBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xuICovXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpOiBGaXJlYmFzZURlZmF1bHRzIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRzSnNvblN0cmluZyA9IHByb2Nlc3MuZW52Ll9fRklSRUJBU0VfREVGQVVMVFNfXztcbiAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpOiBGaXJlYmFzZURlZmF1bHRzIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG1hdGNoO1xuICB0cnkge1xuICAgIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9fX0ZJUkVCQVNFX0RFRkFVTFRTX189KFteO10rKS8pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXG4gICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVjb2RlZCA9IG1hdGNoICYmIGJhc2U2NERlY29kZShtYXRjaFsxXSk7XG4gIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC4gSXQgY2hlY2tzIGluIG9yZGVyOlxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxuICogKDIpIGlmIHN1Y2ggYW4gb2JqZWN0IHdhcyBwcm92aWRlZCBvbiBhIHNoZWxsIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiAoMykgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGluIGEgY29va2llXG4gKi9cbmNvbnN0IGdldERlZmF1bHRzID0gKCk6IEZpcmViYXNlRGVmYXVsdHMgfCB1bmRlZmluZWQgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICBnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxuICAgICAgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUoKSB8fFxuICAgICAgZ2V0RGVmYXVsdHNGcm9tQ29va2llKClcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyoqXG4gICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcbiAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cbiAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXG4gICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcbiAgICByZXR1cm47XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3QgPSAoXG4gIHByb2R1Y3ROYW1lOiBzdHJpbmdcbik6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiBnZXREZWZhdWx0cygpPy5lbXVsYXRvckhvc3RzPy5bcHJvZHVjdE5hbWVdO1xuXG4vKipcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdG5hbWUgYW5kIHBvcnQgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIHBhaXIgb2YgaG9zdG5hbWUgYW5kIHBvcnQgbGlrZSBgW1wiOjoxXCIsIDQwMDBdYCBpZiBhdmFpbGFibGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCA9IChcbiAgcHJvZHVjdE5hbWU6IHN0cmluZ1xuKTogW2hvc3RuYW1lOiBzdHJpbmcsIHBvcnQ6IG51bWJlcl0gfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBob3N0Lmxhc3RJbmRleE9mKCc6Jyk7IC8vIEZpbmRpbmcgdGhlIGxhc3Qgc2luY2UgSVB2NiBhZGRyIGFsc28gaGFzIGNvbG9ucy5cbiAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XG4gIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICAvLyBCcmFja2V0LXF1b3RlZCBgW2lwdjZhZGRyXTpwb3J0YCA9PiByZXR1cm4gXCJpcHY2YWRkclwiICh3aXRob3V0IGJyYWNrZXRzKS5cbiAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDEsIHNlcGFyYXRvckluZGV4IC0gMSksIHBvcnRdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZpcmViYXNlIGFwcCBjb25maWcgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkID0+XG4gIGdldERlZmF1bHRzKCk/LmNvbmZpZztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXG4gKiBwcmVmaXhlZCBieSBcIl9cIilcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSA8VCBleHRlbmRzIEV4cGVyaW1lbnRhbEtleT4oXG4gIG5hbWU6IFRcbik6IEZpcmViYXNlRGVmYXVsdHNbYF8ke1R9YF0gPT5cbiAgZ2V0RGVmYXVsdHMoKT8uW2BfJHtuYW1lfWBdIGFzIEZpcmViYXNlRGVmYXVsdHNbYF8ke1R9YF07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQ8Uj4ge1xuICBwcm9taXNlOiBQcm9taXNlPFI+O1xuICByZWplY3Q6ICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgcmVzb2x2ZTogKHZhbHVlPzogdW5rbm93bikgPT4gdm9pZCA9ICgpID0+IHt9O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlIGFzICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQ7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdCBhcyAodmFsdWU/OiB1bmtub3duKSA9PiB2b2lkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXG4gICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXG4gICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXG4gICAqL1xuICB3cmFwQ2FsbGJhY2soXG4gICAgY2FsbGJhY2s/OiAoZXJyb3I/OiB1bmtub3duLCB2YWx1ZT86IHVua25vd24pID0+IHZvaWRcbiAgKTogKGVycm9yOiB1bmtub3duLCB2YWx1ZT86IHVua25vd24pID0+IHZvaWQge1xuICAgIHJldHVybiAoZXJyb3IsIHZhbHVlPykgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXG4gICAgICAgIC8vIHByb21pc2VzXG4gICAgICAgIHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICAgICAgLy8gU29tZSBvZiBvdXIgY2FsbGJhY2tzIGRvbid0IGV4cGVjdCBhIHZhbHVlIGFuZCBvdXIgb3duIHRlc3RzXG4gICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcbiAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgfSBmcm9tICcuL2NyeXB0JztcblxuLy8gRmlyZWJhc2UgQXV0aCB0b2tlbnMgY29udGFpbiBzbmFrZV9jYXNlIGNsYWltcyBmb2xsb3dpbmcgdGhlIEpXVCBzdGFuZGFyZCAvIGNvbnZlbnRpb24uXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxuZXhwb3J0IHR5cGUgRmlyZWJhc2VTaWduSW5Qcm92aWRlciA9XG4gIHwgJ2N1c3RvbSdcbiAgfCAnZW1haWwnXG4gIHwgJ3Bhc3N3b3JkJ1xuICB8ICdwaG9uZSdcbiAgfCAnYW5vbnltb3VzJ1xuICB8ICdnb29nbGUuY29tJ1xuICB8ICdmYWNlYm9vay5jb20nXG4gIHwgJ2dpdGh1Yi5jb20nXG4gIHwgJ3R3aXR0ZXIuY29tJ1xuICB8ICdtaWNyb3NvZnQuY29tJ1xuICB8ICdhcHBsZS5jb20nO1xuXG5pbnRlcmZhY2UgRmlyZWJhc2VJZFRva2VuIHtcbiAgLy8gQWx3YXlzIHNldCB0byBodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vUFJPSkVDVF9JRFxuICBpc3M6IHN0cmluZztcblxuICAvLyBBbHdheXMgc2V0IHRvIFBST0pFQ1RfSURcbiAgYXVkOiBzdHJpbmc7XG5cbiAgLy8gVGhlIHVzZXIncyB1bmlxdWUgSURcbiAgc3ViOiBzdHJpbmc7XG5cbiAgLy8gVGhlIHRva2VuIGlzc3VlIHRpbWUsIGluIHNlY29uZHMgc2luY2UgZXBvY2hcbiAgaWF0OiBudW1iZXI7XG5cbiAgLy8gVGhlIHRva2VuIGV4cGlyeSB0aW1lLCBub3JtYWxseSAnaWF0JyArIDM2MDBcbiAgZXhwOiBudW1iZXI7XG5cbiAgLy8gVGhlIHVzZXIncyB1bmlxdWUgSUQuIE11c3QgYmUgZXF1YWwgdG8gJ3N1YidcbiAgdXNlcl9pZDogc3RyaW5nO1xuXG4gIC8vIFRoZSB0aW1lIHRoZSB1c2VyIGF1dGhlbnRpY2F0ZWQsIG5vcm1hbGx5ICdpYXQnXG4gIGF1dGhfdGltZTogbnVtYmVyO1xuXG4gIC8vIFRoZSBzaWduIGluIHByb3ZpZGVyLCBvbmx5IHNldCB3aGVuIHRoZSBwcm92aWRlciBpcyAnYW5vbnltb3VzJ1xuICBwcm92aWRlcl9pZD86ICdhbm9ueW1vdXMnO1xuXG4gIC8vIFRoZSB1c2VyJ3MgcHJpbWFyeSBlbWFpbFxuICBlbWFpbD86IHN0cmluZztcblxuICAvLyBUaGUgdXNlcidzIGVtYWlsIHZlcmlmaWNhdGlvbiBzdGF0dXNcbiAgZW1haWxfdmVyaWZpZWQ/OiBib29sZWFuO1xuXG4gIC8vIFRoZSB1c2VyJ3MgcHJpbWFyeSBwaG9uZSBudW1iZXJcbiAgcGhvbmVfbnVtYmVyPzogc3RyaW5nO1xuXG4gIC8vIFRoZSB1c2VyJ3MgZGlzcGxheSBuYW1lXG4gIG5hbWU/OiBzdHJpbmc7XG5cbiAgLy8gVGhlIHVzZXIncyBwcm9maWxlIHBob3RvIFVSTFxuICBwaWN0dXJlPzogc3RyaW5nO1xuXG4gIC8vIEluZm9ybWF0aW9uIG9uIGFsbCBpZGVudGl0aWVzIGxpbmtlZCB0byB0aGlzIHVzZXJcbiAgZmlyZWJhc2U6IHtcbiAgICAvLyBUaGUgcHJpbWFyeSBzaWduLWluIHByb3ZpZGVyXG4gICAgc2lnbl9pbl9wcm92aWRlcjogRmlyZWJhc2VTaWduSW5Qcm92aWRlcjtcblxuICAgIC8vIEEgbWFwIG9mIHByb3ZpZGVycyB0byB0aGUgdXNlcidzIGxpc3Qgb2YgdW5pcXVlIGlkZW50aWZpZXJzIGZyb21cbiAgICAvLyBlYWNoIHByb3ZpZGVyXG4gICAgaWRlbnRpdGllcz86IHsgW3Byb3ZpZGVyIGluIEZpcmViYXNlU2lnbkluUHJvdmlkZXJdPzogc3RyaW5nW10gfTtcbiAgfTtcblxuICAvLyBDdXN0b20gY2xhaW1zIHNldCBieSB0aGUgZGV2ZWxvcGVyXG4gIFtjbGFpbTogc3RyaW5nXTogdW5rbm93bjtcblxuICB1aWQ/OiBuZXZlcjsgLy8gVHJ5IHRvIGNhdGNoIGEgY29tbW9uIG1pc3Rha2Ugb2YgXCJ1aWRcIiAoc2hvdWxkIGJlIFwic3ViXCIgaW5zdGVhZCkuXG59XG5cbmV4cG9ydCB0eXBlIEVtdWxhdG9yTW9ja1Rva2VuT3B0aW9ucyA9ICh7IHVzZXJfaWQ6IHN0cmluZyB9IHwgeyBzdWI6IHN0cmluZyB9KSAmXG4gIFBhcnRpYWw8RmlyZWJhc2VJZFRva2VuPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4oXG4gIHRva2VuOiBFbXVsYXRvck1vY2tUb2tlbk9wdGlvbnMsXG4gIHByb2plY3RJZD86IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgaWYgKHRva2VuLnVpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdUaGUgXCJ1aWRcIiBmaWVsZCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGJ5IG1vY2tVc2VyVG9rZW4uIFBsZWFzZSB1c2UgXCJzdWJcIiBpbnN0ZWFkIGZvciBGaXJlYmFzZSBBdXRoIFVzZXIgSUQuJ1xuICAgICk7XG4gIH1cbiAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICBhbGc6ICdub25lJyxcbiAgICB0eXBlOiAnSldUJ1xuICB9O1xuXG4gIGNvbnN0IHByb2plY3QgPSBwcm9qZWN0SWQgfHwgJ2RlbW8tcHJvamVjdCc7XG4gIGNvbnN0IGlhdCA9IHRva2VuLmlhdCB8fCAwO1xuICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcbiAgaWYgKCFzdWIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICB9XG5cbiAgY29uc3QgcGF5bG9hZDogRmlyZWJhc2VJZFRva2VuID0ge1xuICAgIC8vIFNldCBhbGwgcmVxdWlyZWQgZmllbGRzIHRvIGRlY2VudCBkZWZhdWx0c1xuICAgIGlzczogYGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS8ke3Byb2plY3R9YCxcbiAgICBhdWQ6IHByb2plY3QsXG4gICAgaWF0LFxuICAgIGV4cDogaWF0ICsgMzYwMCxcbiAgICBhdXRoX3RpbWU6IGlhdCxcbiAgICBzdWIsXG4gICAgdXNlcl9pZDogc3ViLFxuICAgIGZpcmViYXNlOiB7XG4gICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcbiAgICAgIGlkZW50aXRpZXM6IHt9XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHdpdGggdXNlciBvcHRpb25zXG4gICAgLi4udG9rZW5cbiAgfTtcblxuICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhIHNpZ25hdHVyZS5cbiAgY29uc3Qgc2lnbmF0dXJlID0gJyc7XG4gIHJldHVybiBbXG4gICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXG4gICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxuICAgIHNpZ25hdHVyZVxuICBdLmpvaW4oJy4nKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgLy8gVHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xuICogICB0eXBlIEVyciA9XG4gKiAgICAgJ3Vua25vd24nIHxcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcbiAqICAgICA7XG4gKlxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XG4gKiAgIHZhciBFcnIgPSB7XG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcbiAqICAgfVxuICpcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxuICogICB9O1xuICpcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xuICpcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xuICogICAuLi5cbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXG4gKlxuICogICBjYXRjaCAoZSkge1xuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xuICogICAgIH1cbiAqICAgfVxuICovXG5cbmV4cG9ydCB0eXBlIEVycm9yTWFwPEVycm9yQ29kZSBleHRlbmRzIHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtLIGluIEVycm9yQ29kZV06IHN0cmluZztcbn07XG5cbmNvbnN0IEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaW5nTGlrZSB7XG4gIHRvU3RyaW5nKCk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvckRhdGEge1xuICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vLyBCYXNlZCBvbiBjb2RlIGZyb206XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNDdXN0b21fRXJyb3JfVHlwZXNcbmV4cG9ydCBjbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogVGhlIGN1c3RvbSBuYW1lIGZvciBhbGwgRmlyZWJhc2VFcnJvcnMuICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZyA9IEVSUk9SX05BTUU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSBlcnJvciBjb2RlIGZvciB0aGlzIGVycm9yLiAqL1xuICAgIHJlYWRvbmx5IGNvZGU6IHN0cmluZyxcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgLyoqIEN1c3RvbSBkYXRhIGZvciB0aGlzIGVycm9yLiAqL1xuICAgIHB1YmxpYyBjdXN0b21EYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICAvLyBGaXggRm9yIEVTNVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcblxuICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duLlxuICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXJyb3JGYWN0b3J5PFxuICBFcnJvckNvZGUgZXh0ZW5kcyBzdHJpbmcsXG4gIEVycm9yUGFyYW1zIGV4dGVuZHMgeyByZWFkb25seSBbSyBpbiBFcnJvckNvZGVdPzogRXJyb3JEYXRhIH0gPSB7fVxuPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VydmljZU5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGVycm9yczogRXJyb3JNYXA8RXJyb3JDb2RlPlxuICApIHt9XG5cbiAgY3JlYXRlPEsgZXh0ZW5kcyBFcnJvckNvZGU+KFxuICAgIGNvZGU6IEssXG4gICAgLi4uZGF0YTogSyBleHRlbmRzIGtleW9mIEVycm9yUGFyYW1zID8gW0Vycm9yUGFyYW1zW0tdXSA6IFtdXG4gICk6IEZpcmViYXNlRXJyb3Ige1xuICAgIGNvbnN0IGN1c3RvbURhdGEgPSAoZGF0YVswXSBhcyBFcnJvckRhdGEpIHx8IHt9O1xuICAgIGNvbnN0IGZ1bGxDb2RlID0gYCR7dGhpcy5zZXJ2aWNlfS8ke2NvZGV9YDtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuXG4gICAgY29uc3QgbWVzc2FnZSA9IHRlbXBsYXRlID8gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBjdXN0b21EYXRhKSA6ICdFcnJvcic7XG4gICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxuICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYCR7dGhpcy5zZXJ2aWNlTmFtZX06ICR7bWVzc2FnZX0gKCR7ZnVsbENvZGV9KS5gO1xuXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZTogc3RyaW5nLCBkYXRhOiBFcnJvckRhdGEpOiBzdHJpbmcge1xuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShQQVRURVJOLCAoXywga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XG4gIH0pO1xufVxuXG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkV2YWwoc3RyOiBzdHJpbmcpOiB1bmtub3duIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YXNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoZGF0YTogdW5rbm93bik6IHN0cmluZyB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGJhc2U2NERlY29kZSB9IGZyb20gJy4vY3J5cHQnO1xuaW1wb3J0IHsganNvbkV2YWwgfSBmcm9tICcuL2pzb24nO1xuXG5pbnRlcmZhY2UgQ2xhaW1zIHtcbiAgW2tleTogc3RyaW5nXToge307XG59XG5cbmludGVyZmFjZSBEZWNvZGVkVG9rZW4ge1xuICBoZWFkZXI6IG9iamVjdDtcbiAgY2xhaW1zOiBDbGFpbXM7XG4gIGRhdGE6IG9iamVjdDtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gZnVuY3Rpb24gKHRva2VuOiBzdHJpbmcpOiBEZWNvZGVkVG9rZW4ge1xuICBsZXQgaGVhZGVyID0ge30sXG4gICAgY2xhaW1zOiBDbGFpbXMgPSB7fSxcbiAgICBkYXRhID0ge30sXG4gICAgc2lnbmF0dXJlID0gJyc7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJykgYXMgb2JqZWN0O1xuICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpIGFzIENsYWltcztcbiAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcbiAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgZGVsZXRlIGNsYWltc1snZCddO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHJldHVybiB7XG4gICAgaGVhZGVyLFxuICAgIGNsYWltcyxcbiAgICBkYXRhLFxuICAgIHNpZ25hdHVyZVxuICB9O1xufTtcblxuaW50ZXJmYWNlIERlY29kZWRUb2tlbiB7XG4gIGhlYWRlcjogb2JqZWN0O1xuICBjbGFpbXM6IENsYWltcztcbiAgZGF0YTogb2JqZWN0O1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW46IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBjbGFpbXM6IENsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICBjb25zdCBub3c6IG51bWJlciA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgbGV0IHZhbGlkU2luY2U6IG51bWJlciA9IDAsXG4gICAgdmFsaWRVbnRpbDogbnVtYmVyID0gMDtcblxuICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xuICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ10gYXMgbnVtYmVyO1xuICAgIH0gZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xuICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J10gYXMgbnVtYmVyO1xuICAgIH1cblxuICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XG4gICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXSBhcyBudW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XG4gICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgISFub3cgJiZcbiAgICAhIXZhbGlkU2luY2UgJiZcbiAgICAhIXZhbGlkVW50aWwgJiZcbiAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxuICAgIG5vdyA8PSB2YWxpZFVudGlsXG4gICk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3QgY2xhaW1zOiBDbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICByZXR1cm4gY2xhaW1zWydpYXQnXSBhcyBudW1iZXI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRm9ybWF0ID0gZnVuY3Rpb24gKHRva2VuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksXG4gICAgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XG5cbiAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNsYWltczogQ2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zPFQgZXh0ZW5kcyBvYmplY3Q+KG9iajogVCwga2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYWZlR2V0PFQgZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgb2JqOiBULFxuICBrZXk6IEtcbik6IFRbS10gfCB1bmRlZmluZWQge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iajogb2JqZWN0KTogb2JqIGlzIHt9IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXA8SyBleHRlbmRzIHN0cmluZywgViwgVT4oXG4gIG9iajogeyBba2V5IGluIEtdOiBWIH0sXG4gIGZuOiAodmFsdWU6IFYsIGtleTogSywgb2JqOiB7IFtrZXkgaW4gS106IFYgfSkgPT4gVSxcbiAgY29udGV4dE9iaj86IHVua25vd25cbik6IHsgW2tleSBpbiBLXTogVSB9IHtcbiAgY29uc3QgcmVzOiBQYXJ0aWFsPHsgW2tleSBpbiBLXTogVSB9PiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBmbi5jYWxsKGNvbnRleHRPYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMgYXMgeyBba2V5IGluIEtdOiBVIH07XG59XG5cbi8qKlxuICogRGVlcCBlcXVhbCB0d28gb2JqZWN0cy4gU3VwcG9ydCBBcnJheXMgYW5kIE9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXF1YWwoYTogb2JqZWN0LCBiOiBvYmplY3QpOiBib29sZWFuIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xuICAgIGlmICghYktleXMuaW5jbHVkZXMoaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBhUHJvcCA9IChhIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrXTtcbiAgICBjb25zdCBiUHJvcCA9IChiIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrXTtcbiAgICBpZiAoaXNPYmplY3QoYVByb3ApICYmIGlzT2JqZWN0KGJQcm9wKSkge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVByb3AsIGJQcm9wKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhUHJvcCAhPT0gYlByb3ApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGsgb2YgYktleXMpIHtcbiAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh0aGluZzogdW5rbm93bik6IHRoaW5nIGlzIG9iamVjdCB7XG4gIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICcuL2RlZmVycmVkJztcblxuLyoqXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dDxUPihcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcbiAgdGltZUluTVMgPSAyMDAwXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IERlZmVycmVkPFQ+KCk7XG4gIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xuICBwcm9taXNlLnRoZW4oZGVmZXJyZWRQcm9taXNlLnJlc29sdmUsIGRlZmVycmVkUHJvbWlzZS5yZWplY3QpO1xuICByZXR1cm4gZGVmZXJyZWRQcm9taXNlLnByb21pc2U7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXG4gKiBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxuICogTm90ZTogWW91IG11c3QgcHJlcGVuZCBpdCB3aXRoID8gd2hlbiBhZGRpbmcgaXQgdG8gYSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtczoge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXI7XG59KTogc3RyaW5nIHtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChhcnJheVZhbCA9PiB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3Qgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcblxuICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSB0b2tlbi5zcGxpdCgnPScpO1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gIGlmICghcXVlcnlTdGFydCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoXG4gICAgcXVlcnlTdGFydCxcbiAgICBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWRcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2guXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXG4gKlxuICogVXNhZ2U6XG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcbiAqICAgc2hhMS51cGRhdGUoYnl0ZXMpO1xuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XG4gKlxuICogUGVyZm9ybWFuY2U6XG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcbiAqXG4gKi9cblxuLyoqXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICovXG5leHBvcnQgY2xhc3MgU2hhMSB7XG4gIC8qKlxuICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xuICAgKiBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY2hhaW5fOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGJ1Zl86IG51bWJlcltdID0gW107XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIDgwIGJ5dGVzLCBlYWNoIGEgcGFydCBvZiB0aGUgbWVzc2FnZSB0byBiZSBoYXNoZWQuICBSZWZlcnJlZCB0b1xuICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgV186IG51bWJlcltdID0gW107XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIGRhdGEgbmVlZGVkIHRvIHBhZCBtZXNzYWdlcyBsZXNzIHRoYW4gNjQgYnl0ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHBhZF86IG51bWJlcltdID0gW107XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICBwcml2YXRlIGluYnVmXzogbnVtYmVyID0gMDtcblxuICAvKipcbiAgICogQHByaXZhdGUge251bWJlcn1cbiAgICovXG4gIHByaXZhdGUgdG90YWxfOiBudW1iZXIgPSAwO1xuXG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcblxuICAgIHRoaXMucGFkX1swXSA9IDEyODtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcbiAgICAgIHRoaXMucGFkX1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcbiAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XG4gICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcblxuICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICB0aGlzLnRvdGFsXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxuICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXByZXNzXyhidWY6IG51bWJlcltdIHwgVWludDhBcnJheSB8IHN0cmluZywgb2Zmc2V0PzogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgY29uc3QgVyA9IHRoaXMuV187XG5cbiAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcbiAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcbiAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcbiAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcbiAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxuICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXG4gICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcbiAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICBXW2ldID1cbiAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxuICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxuICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4KSB8XG4gICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgV1tpXSA9XG4gICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgICAgKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXG4gICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgIH1cblxuICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgbGV0IGIgPSB0aGlzLmNoYWluX1sxXTtcbiAgICBsZXQgYyA9IHRoaXMuY2hhaW5fWzJdO1xuICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgbGV0IGUgPSB0aGlzLmNoYWluX1s0XTtcbiAgICBsZXQgZiwgaztcblxuICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGlmIChpIDwgNDApIHtcbiAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgayA9IDB4Y2E2MmMxZDY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdCA9ICgoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgayArIFdbaV0pICYgMHhmZmZmZmZmZjtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgJiAweGZmZmZmZmZmO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcbiAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcbiAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcbiAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcbiAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcbiAgfVxuXG4gIHVwZGF0ZShieXRlcz86IG51bWJlcltdIHwgVWludDhBcnJheSB8IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcbiAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBsZXQgbiA9IDA7XG4gICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXG4gICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xuICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xuXG4gICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cbiAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXG4gICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxuICAgICAgLy8gc3BlZWR1cCBvbiBDaHJvbWUgMjMgYW5kIH4xNSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LCBidXQgcmVxdWlyZXMgdGhhdFxuICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxuICAgICAgaWYgKGluYnVmID09PSAwKSB7XG4gICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcbiAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XG4gICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlcy5jaGFyQ29kZUF0KG4pO1xuICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgKytuO1xuICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgKytuO1xuICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xuICAgIHRoaXMudG90YWxfICs9IGxlbmd0aDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGlnZXN0KCk6IG51bWJlcltdIHtcbiAgICBjb25zdCBkaWdlc3Q6IG51bWJlcltdID0gW107XG4gICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcblxuICAgIC8vIEFkZCBwYWQgMHg4MCAweDAwKi5cbiAgICBpZiAodGhpcy5pbmJ1Zl8gPCA1Nikge1xuICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XG4gICAgfVxuXG4gICAgLy8gQWRkICMgYml0cy5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcbiAgICAgIHRoaXMuYnVmX1tpXSA9IHRvdGFsQml0cyAmIDI1NTtcbiAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcbiAgICB9XG5cbiAgICB0aGlzLmNvbXByZXNzXyh0aGlzLmJ1Zl8pO1xuXG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcbiAgICAgICAgKytuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlnZXN0O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEZuPFQ+ID0gKHZhbHVlOiBUKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgRXJyb3JGbiA9IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBDb21wbGV0ZUZuID0gKCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZlcjxUPiB7XG4gIC8vIENhbGxlZCBvbmNlIGZvciBlYWNoIHZhbHVlIGluIGEgc3RyZWFtIG9mIHZhbHVlcy5cbiAgbmV4dDogTmV4dEZuPFQ+O1xuXG4gIC8vIEEgc3RyZWFtIHRlcm1pbmF0ZXMgYnkgYSBzaW5nbGUgY2FsbCB0byBFSVRIRVIgZXJyb3IoKSBvciBjb21wbGV0ZSgpLlxuICBlcnJvcjogRXJyb3JGbjtcblxuICAvLyBObyBldmVudHMgd2lsbCBiZSBzZW50IHRvIG5leHQoKSBvbmNlIGNvbXBsZXRlKCkgaXMgY2FsbGVkLlxuICBjb21wbGV0ZTogQ29tcGxldGVGbjtcbn1cblxuZXhwb3J0IHR5cGUgUGFydGlhbE9ic2VydmVyPFQ+ID0gUGFydGlhbDxPYnNlcnZlcjxUPj47XG5cbi8vIFRPRE86IFN1cHBvcnQgYWxzbyBVbnN1YnNjcmliZS51bnN1YnNjcmliZT9cbmV4cG9ydCB0eXBlIFVuc3Vic2NyaWJlID0gKCkgPT4gdm9pZDtcblxuLyoqXG4gKiBUaGUgU3Vic2NyaWJlIGludGVyZmFjZSBoYXMgdHdvIGZvcm1zIC0gcGFzc2luZyB0aGUgaW5saW5lIGZ1bmN0aW9uXG4gKiBjYWxsYmFja3MsIG9yIGEgb2JqZWN0IGludGVyZmFjZSB3aXRoIGNhbGxiYWNrIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaWJlPFQ+IHtcbiAgKG5leHQ/OiBOZXh0Rm48VD4sIGVycm9yPzogRXJyb3JGbiwgY29tcGxldGU/OiBDb21wbGV0ZUZuKTogVW5zdWJzY3JpYmU7XG4gIChvYnNlcnZlcjogUGFydGlhbE9ic2VydmVyPFQ+KTogVW5zdWJzY3JpYmU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gIC8vIFN1YnNjcmliZSBtZXRob2RcbiAgc3Vic2NyaWJlOiBTdWJzY3JpYmU8VD47XG59XG5cbmV4cG9ydCB0eXBlIEV4ZWN1dG9yPFQ+ID0gKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4gdm9pZDtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXG4gKiBUaGVuYWJsZSkuXG4gKlxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gKiAgICAgYXMgYSBwcm94eS5cbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZTxUPihcbiAgZXhlY3V0b3I6IEV4ZWN1dG9yPFQ+LFxuICBvbk5vT2JzZXJ2ZXJzPzogRXhlY3V0b3I8VD5cbik6IFN1YnNjcmliZTxUPiB7XG4gIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHk8VD4oZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xuICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xufVxuXG4vKipcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcbiAqIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBPYnNlcnZlclByb3h5PFQ+IGltcGxlbWVudHMgT2JzZXJ2ZXI8VD4ge1xuICBwcml2YXRlIG9ic2VydmVyczogQXJyYXk8T2JzZXJ2ZXI8VD4+IHwgdW5kZWZpbmVkID0gW107XG4gIHByaXZhdGUgdW5zdWJzY3JpYmVzOiBVbnN1YnNjcmliZVtdID0gW107XG4gIHByaXZhdGUgb25Ob09ic2VydmVyczogRXhlY3V0b3I8VD4gfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgb2JzZXJ2ZXJDb3VudCA9IDA7XG4gIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxuICBwcml2YXRlIHRhc2sgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcHJpdmF0ZSBmaW5hbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBmaW5hbEVycm9yPzogRXJyb3I7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICAgKiAgICAgYXMgYSBwcm94eS5cbiAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZXhlY3V0b3I6IEV4ZWN1dG9yPFQ+LCBvbk5vT2JzZXJ2ZXJzPzogRXhlY3V0b3I8VD4pIHtcbiAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxuICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cbiAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgIHRoaXMudGFza1xuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBleGVjdXRvcih0aGlzKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIG5leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGVycm9yKGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlKGVycm9yKTtcbiAgfVxuXG4gIGNvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxuICAgKlxuICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeWNocm9ub3VzbHkgdG8gdGhlaXJcbiAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxuICAgKi9cbiAgc3Vic2NyaWJlKFxuICAgIG5leHRPck9ic2VydmVyPzogTmV4dEZuPFQ+IHwgUGFydGlhbE9ic2VydmVyPFQ+LFxuICAgIGVycm9yPzogRXJyb3JGbixcbiAgICBjb21wbGV0ZT86IENvbXBsZXRlRm5cbiAgKTogVW5zdWJzY3JpYmUge1xuICAgIGxldCBvYnNlcnZlcjogT2JzZXJ2ZXI8VD47XG5cbiAgICBpZiAoXG4gICAgICBuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICBpZiAoXG4gICAgICBpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciBhcyB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSwgW1xuICAgICAgICAnbmV4dCcsXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgICdjb21wbGV0ZSdcbiAgICAgIF0pXG4gICAgKSB7XG4gICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyIGFzIE9ic2VydmVyPFQ+O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIgYXMgTmV4dEZuPFQ+LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgY29tcGxldGVcbiAgICAgIH0gYXMgT2JzZXJ2ZXI8VD47XG4gICAgfVxuXG4gICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3AgYXMgTmV4dEZuPFQ+O1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wIGFzIEVycm9yRm47XG4gICAgfVxuICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3AgYXMgQ29tcGxldGVGbjtcbiAgICB9XG5cbiAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycyEubGVuZ3RoKTtcblxuICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcbiAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXG4gICAgLy8gZXZlbnQuXG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmluYWxFcnJvcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5vYnNlcnZlcnMhLnB1c2gob2JzZXJ2ZXIgYXMgT2JzZXJ2ZXI8VD4pO1xuXG4gICAgcmV0dXJuIHVuc3ViO1xuICB9XG5cbiAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cbiAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cbiAgcHJpdmF0ZSB1bnN1YnNjcmliZU9uZShpOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xuXG4gICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJDb3VudCA9PT0gMCAmJiB0aGlzLm9uTm9PYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZm9yRWFjaE9ic2VydmVyKGZuOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XG4gICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnNlbmRPbmUoaSwgZm4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgdGhlIE9ic2VydmVyIHZpYSBvbmUgb2YgaXQncyBjYWxsYmFjayBmdW5jdGlvbi4gV2UgYXJlIGNhcmVmdWwgdG9cbiAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxuICBwcml2YXRlIHNlbmRPbmUoaTogbnVtYmVyLCBmbjogKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxuICAgICAgICAgIC8vIE9ic2VydmVyLlxuICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjbG9zZShlcnI/OiBFcnJvcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZpbmFsRXJyb3IgPSBlcnI7XG4gICAgfVxuICAgIC8vIFByb3h5IGlzIG5vIGxvbmdlciBuZWVkZWQgLSBnYXJiYWdlIGNvbGxlY3QgcmVmZXJlbmNlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jKGZuOiBGdW5jdGlvbiwgb25FcnJvcj86IEVycm9yRm4pOiBGdW5jdGlvbiB7XG4gIHJldHVybiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgcGFzc2VkIGluIGltcGxlbWVudHMgYW55IG9mIHRoZSBuYW1lZCBtZXRob2RzLlxuICovXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhcbiAgb2JqOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSxcbiAgbWV0aG9kczogc3RyaW5nW11cbik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgIGlmIChtZXRob2QgaW4gb2JqICYmIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBub29wKCk6IHZvaWQge1xuICAvLyBkbyBub3RoaW5nXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICpcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgbWluQ291bnQ6IG51bWJlcixcbiAgbWF4Q291bnQ6IG51bWJlcixcbiAgYXJnQ291bnQ6IG51bWJlclxuKTogdm9pZCB7XG4gIGxldCBhcmdFcnJvcjtcbiAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcbiAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XG4gIH0gZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xuICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcbiAgfVxuICBpZiAoYXJnRXJyb3IpIHtcbiAgICBjb25zdCBlcnJvciA9XG4gICAgICBmbk5hbWUgK1xuICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcbiAgICAgIGFyZ0NvdW50ICtcbiAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcbiAgICAgICcgRXhwZWN0cyAnICtcbiAgICAgIGFyZ0Vycm9yICtcbiAgICAgICcuJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxuICpcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSBhcmdOYW1lIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgdGhyb3duIGZvciB2YWxpZGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JQcmVmaXgoZm5OYW1lOiBzdHJpbmcsIGFyZ05hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xufVxuXG4vKipcbiAqIEBwYXJhbSBmbk5hbWVcbiAqIEBwYXJhbSBhcmd1bWVudE51bWJlclxuICogQHBhcmFtIG5hbWVzcGFjZVxuICogQHBhcmFtIG9wdGlvbmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIG5hbWVzcGFjZTogc3RyaW5nLFxuICBvcHRpb25hbDogYm9vbGVhblxuKTogdm9pZCB7XG4gIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJ1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE5hbWU6IHN0cmluZyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgY2FsbGJhY2s6IEZ1bmN0aW9uLFxuICBvcHRpb25hbDogYm9vbGVhblxuKTogdm9pZCB7XG4gIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJ1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dE9iamVjdChcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIGFyZ3VtZW50TmFtZTogc3RyaW5nLFxuICBjb250ZXh0OiB1bmtub3duLFxuICBvcHRpb25hbDogYm9vbGVhblxuKTogdm9pZCB7XG4gIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGNvbnRleHQgb2JqZWN0LidcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5cbi8vIENvZGUgb3JpZ2luYWxseSBjYW1lIGZyb20gZ29vZy5jcnlwdC5zdHJpbmdUb1V0ZjhCeXRlQXJyYXksIGJ1dCBmb3Igc29tZSByZWFzb24gdGhleVxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cblxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXG4vLyBmcm9tQ2hhckNvZGUgcmV0dXJucyB0aGUgVVRGLTE2IGVuY29kaW5nIG9mIGEgY2hhcmFjdGVyIC0gc28gc29tZSBVbmljb2RlIGNoYXJhY3RlcnNcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3Rcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxuLy8gcGFpcikuXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gIGNvbnN0IG91dDogbnVtYmVyW10gPSBbXTtcbiAgbGV0IHAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyBJcyB0aGlzIHRoZSBsZWFkIHN1cnJvZ2F0ZSBpbiBhIHN1cnJvZ2F0ZSBwYWlyP1xuICAgIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXG4gICAgICBpKys7XG4gICAgICBhc3NlcnQoaSA8IHN0ci5sZW5ndGgsICdTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS4nKTtcbiAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXG4gICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcbiAgICB9XG5cbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgb3V0W3ArK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH0gZWxzZSBpZiAoYyA8IDY1NTM2KSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gIGxldCBwID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgIHArKztcbiAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICBwICs9IDI7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cbiAgICAgIHAgKz0gNDtcbiAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHAgKz0gMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuICogR2VuZXJhdGVzIGEgbmV3IHV1aWQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1dWlkdjQgPSBmdW5jdGlvbiAoKTogc3RyaW5nIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcbiAgICAgIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxuICovXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMX01JTExJUyA9IDEwMDA7XG5cbi8qKlxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxuICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcblxuLyoqXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXG5cbi8qKlxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cbiAqIFNlZVxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXG4gKiBmb3IgY29udGV4dC5cbiAqXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xuXG4vKipcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9leHBvbmVudGlhbGJhY2tvZmYuanMuXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKFxuICBiYWNrb2ZmQ291bnQ6IG51bWJlcixcbiAgaW50ZXJ2YWxNaWxsaXM6IG51bWJlciA9IERFRkFVTFRfSU5URVJWQUxfTUlMTElTLFxuICBiYWNrb2ZmRmFjdG9yOiBudW1iZXIgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SXG4pOiBudW1iZXIge1xuICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cbiAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXG4gIC8vIGFuZCBjb3VudCB0byByZXN0b3JlIHN0YXRlLlxuICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xuXG4gIC8vIEEgcmFuZG9tIFwiZnV6elwiIHRvIGF2b2lkIHdhdmVzIG9mIHJldHJpZXMuXG4gIC8vIERldmlhdGlvbjogcmFuZG9tRmFjdG9yIGlzIHJlcXVpcmVkLlxuICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cbiAgICAvLyBEZXZpYXRpb246IGNoYW5nZXMgbXVsdGlwbGljYXRpb24gb3JkZXIgdG8gaW1wcm92ZSByZWFkYWJpbGl0eS5cbiAgICBSQU5ET01fRkFDVE9SICpcbiAgICAgIGN1cnJCYXNlVmFsdWUgKlxuICAgICAgLy8gQSByYW5kb20gZmxvYXQgKHJvdW5kZWQgdG8gaW50IGJ5IE1hdGgucm91bmQgYWJvdmUpIGluIHRoZSByYW5nZSBbLTEsIDFdLiBEZXRlcm1pbmVzXG4gICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXG4gICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKlxuICAgICAgMlxuICApO1xuXG4gIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cbiAgcmV0dXJuIE1hdGgubWluKE1BWF9WQUxVRV9NSUxMSVMsIGN1cnJCYXNlVmFsdWUgKyByYW5kb21XYWl0KTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUHJvdmlkZSBFbmdsaXNoIG9yZGluYWwgbGV0dGVycyBhZnRlciBhIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbChpOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkge1xuICAgIHJldHVybiBgJHtpfWA7XG4gIH1cbiAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XG59XG5cbmZ1bmN0aW9uIGluZGljYXRvcihpOiBudW1iZXIpOiBzdHJpbmcge1xuICBpID0gTWF0aC5hYnMoaSk7XG4gIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xuICBpZiAoY2VudCA+PSAxMCAmJiBjZW50IDw9IDIwKSB7XG4gICAgcmV0dXJuICd0aCc7XG4gIH1cbiAgY29uc3QgZGVjID0gaSAlIDEwO1xuICBpZiAoZGVjID09PSAxKSB7XG4gICAgcmV0dXJuICdzdCc7XG4gIH1cbiAgaWYgKGRlYyA9PT0gMikge1xuICAgIHJldHVybiAnbmQnO1xuICB9XG4gIGlmIChkZWMgPT09IDMpIHtcbiAgICByZXR1cm4gJ3JkJztcbiAgfVxuICByZXR1cm4gJ3RoJztcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGF0PFQ+IHtcbiAgX2RlbGVnYXRlOiBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlPEV4cFNlcnZpY2U+KFxuICBzZXJ2aWNlOiBDb21wYXQ8RXhwU2VydmljZT4gfCBFeHBTZXJ2aWNlXG4pOiBFeHBTZXJ2aWNlIHtcbiAgaWYgKHNlcnZpY2UgJiYgKHNlcnZpY2UgYXMgQ29tcGF0PEV4cFNlcnZpY2U+KS5fZGVsZWdhdGUpIHtcbiAgICByZXR1cm4gKHNlcnZpY2UgYXMgQ29tcGF0PEV4cFNlcnZpY2U+KS5fZGVsZWdhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlcnZpY2UgYXMgRXhwU2VydmljZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5PREVfQ0xJRU5UIiwiTk9ERV9BRE1JTiIsIlNES19WRVJTSU9OIiwiYXNzZXJ0IiwiYXNzZXJ0aW9uIiwibWVzc2FnZSIsImFzc2VydGlvbkVycm9yIiwiRXJyb3IiLCJDT05TVEFOVFMiLCJzdHJpbmdUb0J5dGVBcnJheSIsInN0ciIsIm91dCIsInAiLCJpIiwibGVuZ3RoIiwiYyIsImNoYXJDb2RlQXQiLCJieXRlQXJyYXlUb1N0cmluZyIsImJ5dGVzIiwicG9zIiwiYzEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjMiIsImMzIiwiYzQiLCJ1Iiwiam9pbiIsImJ5dGVUb0NoYXJNYXBfIiwiY2hhclRvQnl0ZU1hcF8iLCJieXRlVG9DaGFyTWFwV2ViU2FmZV8iLCJjaGFyVG9CeXRlTWFwV2ViU2FmZV8iLCJFTkNPREVEX1ZBTFNfQkFTRSIsIkVOQ09ERURfVkFMUyIsIkVOQ09ERURfVkFMU19XRUJTQUZFIiwiSEFTX05BVElWRV9TVVBQT1JUIiwiYXRvYiIsImVuY29kZUJ5dGVBcnJheSIsImlucHV0Iiwid2ViU2FmZSIsIkFycmF5IiwiaXNBcnJheSIsImluaXRfIiwiYnl0ZVRvQ2hhck1hcCIsIm91dHB1dCIsImJ5dGUxIiwiaGF2ZUJ5dGUyIiwiYnl0ZTIiLCJoYXZlQnl0ZTMiLCJieXRlMyIsIm91dEJ5dGUxIiwib3V0Qnl0ZTIiLCJvdXRCeXRlMyIsIm91dEJ5dGU0IiwicHVzaCIsImVuY29kZVN0cmluZyIsImJ0b2EiLCJkZWNvZGVTdHJpbmciLCJkZWNvZGVTdHJpbmdUb0J5dGVBcnJheSIsImNoYXJUb0J5dGVNYXAiLCJjaGFyQXQiLCJoYXZlQnl0ZTQiLCJieXRlNCIsImJhc2U2NEVuY29kZSIsInV0ZjhCeXRlcyIsImJhc2U2NCIsImJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nIiwicmVwbGFjZSIsImJhc2U2NERlY29kZSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJkZWVwQ29weSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInVuZGVmaW5lZCIsInRhcmdldCIsInNvdXJjZSIsIk9iamVjdCIsImNvbnN0cnVjdG9yIiwiRGF0ZSIsImRhdGVWYWx1ZSIsImdldFRpbWUiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiZ2V0VUEiLCJuYXZpZ2F0b3IiLCJpc01vYmlsZUNvcmRvdmEiLCJ3aW5kb3ciLCJ0ZXN0IiwiaXNOb2RlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiZ2xvYmFsIiwicHJvY2VzcyIsImlzQnJvd3NlciIsInNlbGYiLCJpc0Jyb3dzZXJFeHRlbnNpb24iLCJydW50aW1lIiwiY2hyb21lIiwiYnJvd3NlciIsImlkIiwiaXNSZWFjdE5hdGl2ZSIsImlzRWxlY3Ryb24iLCJpbmRleE9mIiwiaXNJRSIsInVhIiwiaXNVV1AiLCJpc05vZGVTZGsiLCJpc1NhZmFyaSIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiaXNJbmRleGVkREJBdmFpbGFibGUiLCJpbmRleGVkREIiLCJ2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwcmVFeGlzdCIsIkRCX0NIRUNLX05BTUUiLCJyZXF1ZXN0Iiwib3BlbiIsIm9uc3VjY2VzcyIsInJlc3VsdCIsImNsb3NlIiwiZGVsZXRlRGF0YWJhc2UiLCJvbnVwZ3JhZGVuZWVkZWQiLCJvbmVycm9yIiwiYXJlQ29va2llc0VuYWJsZWQiLCJjb29raWVFbmFibGVkIiwiZ2V0R2xvYmFsIiwiZ2V0RGVmYXVsdHNGcm9tR2xvYmFsIiwiX19GSVJFQkFTRV9ERUZBVUxUU19fIiwiZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUiLCJlbnYiLCJkZWZhdWx0c0pzb25TdHJpbmciLCJKU09OIiwicGFyc2UiLCJnZXREZWZhdWx0c0Zyb21Db29raWUiLCJkb2N1bWVudCIsIm1hdGNoIiwiY29va2llIiwiZGVjb2RlZCIsImdldERlZmF1bHRzIiwiaW5mbyIsImdldERlZmF1bHRFbXVsYXRvckhvc3QiLCJwcm9kdWN0TmFtZSIsImdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCIsImhvc3QiLCJzZXBhcmF0b3JJbmRleCIsImxhc3RJbmRleE9mIiwicG9ydCIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImNvbmZpZyIsImdldEV4cGVyaW1lbnRhbFNldHRpbmciLCJuYW1lIiwiRGVmZXJyZWQiLCJwcm9taXNlIiwiY2FsbGJhY2siLCJ0b2tlbiIsInByb2plY3RJZCIsInVpZCIsImhlYWRlciIsImFsZyIsInR5cGUiLCJwcm9qZWN0IiwiaWF0Iiwic3ViIiwidXNlcl9pZCIsInBheWxvYWQiLCJpc3MiLCJhdWQiLCJleHAiLCJhdXRoX3RpbWUiLCJmaXJlYmFzZSIsInNpZ25faW5fcHJvdmlkZXIiLCJpZGVudGl0aWVzIiwic2lnbmF0dXJlIiwic3RyaW5naWZ5IiwiRVJST1JfTkFNRSIsIkZpcmViYXNlRXJyb3IiLCJjb2RlIiwiY3VzdG9tRGF0YSIsInNldFByb3RvdHlwZU9mIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJFcnJvckZhY3RvcnkiLCJjcmVhdGUiLCJzZXJ2aWNlIiwic2VydmljZU5hbWUiLCJlcnJvcnMiLCJmdWxsQ29kZSIsInRlbXBsYXRlIiwicmVwbGFjZVRlbXBsYXRlIiwiZnVsbE1lc3NhZ2UiLCJkYXRhIiwiUEFUVEVSTiIsIl8iLCJqc29uRXZhbCIsImRlY29kZSIsImNsYWltcyIsInBhcnRzIiwic3BsaXQiLCJpc1ZhbGlkVGltZXN0YW1wIiwibm93IiwiTWF0aCIsImZsb29yIiwidmFsaWRTaW5jZSIsInZhbGlkVW50aWwiLCJpc3N1ZWRBdFRpbWUiLCJpc1ZhbGlkRm9ybWF0IiwiaXNBZG1pbiIsIm9iaiIsImlzRW1wdHkiLCJtYXAiLCJmbiIsImNvbnRleHRPYmoiLCJyZXMiLCJhIiwiYiIsImFLZXlzIiwia2V5cyIsImJLZXlzIiwiayIsImFQcm9wIiwiYlByb3AiLCJpc09iamVjdCIsImRlZXBFcXVhbCIsInRoaW5nIiwicHJvbWlzZVdpdGhUaW1lb3V0IiwidGltZUluTVMiLCJkZWZlcnJlZFByb21pc2UiLCJzZXRUaW1lb3V0IiwidGhlbiIsInF1ZXJ5c3RyaW5nIiwicXVlcnlzdHJpbmdQYXJhbXMiLCJwYXJhbXMiLCJmb3JFYWNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYXJyYXlWYWwiLCJlbnRyaWVzIiwicXVlcnlzdHJpbmdEZWNvZGUiLCJ0b2tlbnMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJleHRyYWN0UXVlcnlzdHJpbmciLCJ1cmwiLCJxdWVyeVN0YXJ0IiwiZnJhZ21lbnRTdGFydCIsIlNoYTEiLCJibG9ja1NpemUiLCJwYWRfIiwicmVzZXQiLCJjaGFpbl8iLCJpbmJ1Zl8iLCJ0b3RhbF8iLCJidWYiLCJvZmZzZXQiLCJXIiwiV18iLCJ0IiwiZCIsImYiLCJsZW5ndGhNaW51c0Jsb2NrIiwibiIsImJ1Zl8iLCJpbmJ1ZiIsImNvbXByZXNzXyIsImRpZ2VzdCIsInRvdGFsQml0cyIsInVwZGF0ZSIsImoiLCJleGVjdXRvciIsIm9uTm9PYnNlcnZlcnMiLCJwcm94eSIsIk9ic2VydmVyUHJveHkiLCJzdWJzY3JpYmUiLCJiaW5kIiwidGFzayIsImZvckVhY2hPYnNlcnZlciIsIm9ic2VydmVyIiwibmV4dCIsImNvbXBsZXRlIiwibmV4dE9yT2JzZXJ2ZXIiLCJpbXBsZW1lbnRzQW55TWV0aG9kcyIsIm5vb3AiLCJ1bnN1YiIsInVuc3Vic2NyaWJlT25lIiwib2JzZXJ2ZXJzIiwiZmluYWxpemVkIiwiZmluYWxFcnJvciIsIm9ic2VydmVyQ291bnQiLCJzZW5kT25lIiwiZXJyIiwib25FcnJvciIsImFyZ3MiLCJtZXRob2RzIiwibWV0aG9kIiwidmFsaWRhdGVBcmdDb3VudCIsImZuTmFtZSIsIm1pbkNvdW50IiwibWF4Q291bnQiLCJhcmdDb3VudCIsImFyZ0Vycm9yIiwiYXJnTmFtZSIsInZhbGlkYXRlTmFtZXNwYWNlIiwibmFtZXNwYWNlIiwib3B0aW9uYWwiLCJlcnJvclByZWZpeCIsImFyZ3VtZW50TmFtZSIsInZhbGlkYXRlQ29udGV4dE9iamVjdCIsImNvbnRleHQiLCJoaWdoIiwibG93Iiwic3RyaW5nTGVuZ3RoIiwidXVpZHY0IiwiciIsInJhbmRvbSIsInYiLCJERUZBVUxUX0lOVEVSVkFMX01JTExJUyIsIkRFRkFVTFRfQkFDS09GRl9GQUNUT1IiLCJNQVhfVkFMVUVfTUlMTElTIiwiUkFORE9NX0ZBQ1RPUiIsImNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMiLCJiYWNrb2ZmQ291bnQiLCJpbnRlcnZhbE1pbGxpcyIsImJhY2tvZmZGYWN0b3IiLCJjdXJyQmFzZVZhbHVlIiwicG93IiwicmFuZG9tV2FpdCIsInJvdW5kIiwibWluIiwib3JkaW5hbCIsIk51bWJlciIsImlzRmluaXRlIiwiaW5kaWNhdG9yIiwiYWJzIiwiY2VudCIsImRlYyIsImdldE1vZHVsYXJJbnN0YW5jZSIsIl9kZWxlZ2F0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@firebase/util/dist/index.esm2017.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVVDLHNCQUFzQixFQUFFO0VBQ2pELElBQUlDLElBQUksR0FBRyxFQUFFOztFQUViO0VBQ0FBLElBQUksQ0FBQ0MsUUFBUSxHQUFHLFNBQVNBLFFBQVEsR0FBRztJQUNsQyxPQUFPLElBQUksQ0FBQ0MsR0FBRyxDQUFDLFVBQVVDLElBQUksRUFBRTtNQUM5QixJQUFJQyxPQUFPLEdBQUcsRUFBRTtNQUNoQixJQUFJQyxTQUFTLEdBQUcsT0FBT0YsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLFdBQVc7TUFDOUMsSUFBSUEsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ1hDLE9BQU8sSUFBSSxhQUFhLENBQUNFLE1BQU0sQ0FBQ0gsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQztNQUNqRDtNQUNBLElBQUlBLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNYQyxPQUFPLElBQUksU0FBUyxDQUFDRSxNQUFNLENBQUNILElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM7TUFDNUM7TUFDQSxJQUFJRSxTQUFTLEVBQUU7UUFDYkQsT0FBTyxJQUFJLFFBQVEsQ0FBQ0UsTUFBTSxDQUFDSCxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUNJLE1BQU0sR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDRCxNQUFNLENBQUNILElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUM7TUFDakY7TUFDQUMsT0FBTyxJQUFJTCxzQkFBc0IsQ0FBQ0ksSUFBSSxDQUFDO01BQ3ZDLElBQUlFLFNBQVMsRUFBRTtRQUNiRCxPQUFPLElBQUksR0FBRztNQUNoQjtNQUNBLElBQUlELElBQUksQ0FBQyxDQUFDLENBQUMsRUFB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SUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDRyxNQUFNLENBQUNILElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7VUFDbkVBLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBR1UsUUFBUTtRQUNwQjtNQUNGO01BQ0FiLElBQUksQ0FBQ29CLElBQUksQ0FBQ2pCLElBQUksQ0FBQztJQUNqQjtFQUNGLENBQUM7RUFDRCxPQUFPSCxJQUFJO0FBQ2IsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJsaXN0IiwidG9TdHJpbmciLCJtYXAiLCJpdGVtIiwiY29udGVudCIsIm5lZWRMYXllciIsImNvbmNhdCIsImxlbmd0aCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhIiwiZGVkdXBlIiwic3VwcG9ydHMiLCJsYXllciIsInVuZGVmaW5lZCIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJrIiwiaWQiLCJfayIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBVUMsSUFBSSxFQUFFO0VBQy9CLElBQUlDLE9BQU8sR0FBR0QsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUNyQixJQUFJRSxVQUFVLEdBQUdGLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDeEIsSUFBSSxDQUFDRSxVQUFVLEVBQUU7SUFDZixPQUFPRCxPQUFPO0VBQ2hCO0VBQ0EsSUFBSSxPQUFPRSxJQUFJLEtBQUssVUFBVSxFQUFFO0lBQzlCLElBQUlDLE1BQU0sR0FBR0QsSUFBSSxDQUFDRSxRQUFRLENBQUNDLGtCQUFrQixDQUFDQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ04sVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNFLElBQUlPLElBQUksR0FBRyw4REFBOEQsQ0FBQ0MsTUFBTSxDQUFDTixNQUFNLENBQUM7SUFDeEYsSUFBSU8sYUFBYSxHQUFHLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRCxJQUFJLEVBQUUsS0FBSyxDQUFDO0lBQzlDLE9BQU8sQ0FBQ1IsT0FBTyxDQUFDLENBQUNTLE1BQU0sQ0FBQyxDQUFDQyxhQUFhLENBQUMsQ0FBQyxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO0VBQ3JEO0VBQ0EsT0FBTyxDQUFDWCxPQUFPLENBQUMsQ0FBQ1csSUFBSSxDQUFDLElBQUksQ0FBQztBQUM3QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlicmFyeS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIml0ZW0iLCJjb250ZW50IiwiY3NzTWFwcGluZyIsImJ0b2EiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwiY29uY2F0Iiwic291cmNlTWFwcGluZyIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore/lite */ \"./node_modules/firebase/firestore/lite/dist/esm/index.esm.js\");\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar openModal = document.querySelectorAll('[data-modal-target]');\nvar closeModal = document.querySelectorAll('[data-close-button]');\nvar overlay = document.getElementById('overlay');\nvar submit = document.getElementById('submit');\nvar author = document.getElementById('card-author');\nvar title = document.getElementById('card-title');\nvar pages = document.getElementById('card-pages');\nvar cardholder = document.querySelector('.cardholder');\nvar form = document.querySelector('#user-form');\nvar input = document.querySelector('input');\nvar dummy = document.querySelector('#dummy');\nvar firebaseConfig = {\n  apiKey: \"AIzaSyBJsvFKHr3agdq2Fu4SNAyk53hGuyi0RQ4\",\n  authDomain: \"todolist-9d800.firebaseapp.com\",\n  projectId: \"todolist-9d800\",\n  storageBucket: \"todolist-9d800.appspot.com\",\n  messagingSenderId: \"930080224034\",\n  appId: \"1:930080224034:web:5dd5952cb72ed245332b7b\"\n};\nvar app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nvar db = (0,firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\nfunction getBooks(_x) {\n  return _getBooks.apply(this, arguments);\n}\nfunction _getBooks() {\n  _getBooks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(db) {\n    var bookCol, bookSnapshot, bookList;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            bookCol = (0,firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_1__.collection)(db, 'books');\n            _context.next = 3;\n            return (0,firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_1__.getDocs)(bookCol);\n          case 3:\n            bookSnapshot = _context.sent;\n            bookList = bookSnapshot.docs.map(function (doc) {\n              return doc.data();\n            });\n            console.log(bookList);\n            return _context.abrupt(\"return\", bookList);\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getBooks.apply(this, arguments);\n}\ndummy.addEventListener('click', function () {\n  return getBooks(db);\n});\nopenModal.forEach(function (button) {\n  button.addEventListener('click', function () {\n    var modal = document.querySelector(button.dataset.modalTarget);\n    openModalFunction(modal);\n  });\n});\nfunction openModalFunction(modal) {\n  if (modal == null) return;\n  modal.classList.add('active');\n  overlay.classList.add('active');\n}\ncloseModal.forEach(function (button) {\n  button.addEventListener('click', function () {\n    var modal = button.closest('.modal');\n    closeModalFunction(modal);\n  });\n});\nfunction closeModalFunction(modal) {\n  if (modal == null) return;\n  modal.classList.remove('active');\n  overlay.classList.remove('active');\n}\noverlay.addEventListener('click', function () {\n  var modals = document.querySelectorAll('.modal.active');\n  modals.forEach(function (modal) {\n    return closeModalFunction(modal);\n  });\n});\nvar array = [];\nvar Book = /*#__PURE__*/_createClass(function Book(title, author, pages, read) {\n  _classCallCheck(this, Book);\n  this.title = title;\n  this.author = author;\n  this.pages = pages;\n  this.read = read;\n}); // const book1 = new Book(\"The Hobbit\", \"JRR Tolkien\", \"256 pages\")\n// const book2 = new Book(\"Song of Ice and Fire\", \"George RR Martin\", \"3,000 pages\")\n// const book3 = new Book(\"Begin to Code with JAvascript\", \"Rob Miles\", \"500 pages\")\nfunction addBook(e) {\n  var title = document.querySelector('input[name=title]').value;\n  var author = document.querySelector('input[name=author-name]').value;\n  var pages = document.querySelector('input[name=pages]').value;\n  var read = document.querySelector('input[name=checkbox]').checked;\n  var book = new Book(title, author, pages, read);\n  array.push(book);\n  makeNewCard(book);\n  reset();\n}\nsubmit.addEventListener('click', function (e) {\n  var isValid = form.checkValidity();\n  if (!isValid) {\n    console.log('error');\n  }\n  if (isValid) {\n    e.preventDefault();\n    addBook(e);\n  }\n});\ninput.addEventListener('change', function (e) {\n  var isValid = e.target.reportValidity();\n  e.target.setAttribute('aria-invalid', !isValid);\n});\nfunction makeNewCard(book) {\n  //\n  var newCard = document.createElement('div');\n  newCard.className = \"card\";\n  cardholder.appendChild(newCard);\n  //\n  var newDiv = document.createElement('div');\n  newDiv.classList.add('close-card');\n  newDiv.innerHTML = '<span id=\"close-button\" onclick=\"this.parentNode.parentNode.remove(); return false;\">&times;</span>';\n  newCard.appendChild(newDiv);\n  //\n  var cardTitle = document.createElement('p');\n  cardTitle.id = \"card-title\";\n  cardTitle.textContent = \"\".concat(book.title);\n  newCard.appendChild(cardTitle);\n  //\n  var cardAuthor = document.createElement('p');\n  cardAuthor.id = \"card-author\";\n  cardAuthor.textContent = \"\".concat(book.author);\n  newCard.appendChild(cardAuthor);\n  //\n  var cardPages = document.createElement('p');\n  cardPages.id = \"card-pages\";\n  cardPages.textContent = \"\".concat(book.pages);\n  newCard.appendChild(cardPages);\n  //\n  var readDiv = document.createElement('div');\n  readDiv.classList.add('readDiv');\n  var read = document.createElement('p');\n  read.textContent = \"Read?\";\n  var inputElement = document.createElement('input');\n  inputElement.type = 'checkbox';\n  inputElement.classList.add('checkbox');\n  inputElement.checked = book.read ? true : false;\n  inputElement.addEventListener('click', function () {\n    if (book.read == false) {\n      return inputElement.checked == false;\n    } else {\n      inputElement.checked == true;\n    }\n  });\n  readDiv.appendChild(read);\n  readDiv.appendChild(inputElement);\n  newCard.appendChild(readDiv);\n  //\n}\n\nfunction reset() {\n  document.querySelector('#user-form').reset();\n  var modal = document.getElementById('modal');\n  modal.classList.remove('active');\n  overlay.classList.remove('active');\n}\n\n//function//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdwQyxRQUFRLENBQUNJLGNBQWMsQ0FBQyxPQUFPLENBQUM7RUFDNUNnQyxLQUFLLENBQUNJLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQztFQUNoQ3pDLE9BQU8sQ0FBQ3FDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQztBQUN0Qzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0aWFsaXplQXBwfSBmcm9tICdmaXJlYmFzZS9hcHAnO1xyXG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGdldERvY3MgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSdcclxuaW1wb3J0IHN0eWxlc2hlZXQgZnJvbSAnLi9zdHlsZXMuY3NzJ1xyXG5jb25zdCBvcGVuTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tb2RhbC10YXJnZXRdJyk7XHJcbmNvbnN0IGNsb3NlTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jbG9zZS1idXR0b25dJylcclxuY29uc3Qgb3ZlcmxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdmVybGF5JylcclxuY29uc3Qgc3VibWl0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1Ym1pdCcpXHJcbmNvbnN0IGF1dGhvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXJkLWF1dGhvcicpXHJcbmNvbnN0IHRpdGxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhcmQtdGl0bGUnKVxyXG5jb25zdCBwYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXJkLXBhZ2VzJylcclxuY29uc3QgY2FyZGhvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJkaG9sZGVyJylcclxuY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN1c2VyLWZvcm0nKVxyXG5jb25zdCBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JylcclxuY29uc3QgZHVtbXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZHVtbXknKVxyXG5cclxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XHJcbiAgICBhcGlLZXk6IFwiQUl6YVN5QkpzdkZLSHIzYWdkcTJGdTRTTkF5azUzaEd1eWkwUlE0XCIsXHJcbiAgICBhdXRoRG9tYWluOiBcInRvZG9saXN0LTlkODAwLmZpcmViYXNlYXBwLmNvbVwiLFxyXG4gICAgcHJvamVjdElkOiBcInRvZG9saXN0LTlkODAwXCIsXHJcbiAgICBzdG9yYWdlQnVja2V0OiBcInRvZG9saXN0LTlkODAwLmFwcHNwb3QuY29tXCIsXHJcbiAgICBtZXNzYWdpbmdTZW5kZXJJZDogXCI5MzAwODAyMjQwMzRcIixcclxuICAgIGFwcElkOiBcIjE6OTMwMDgwMjI0MDM0OndlYjo1ZGQ1OTUyY2I3MmVkMjQ1MzMyYjdiXCJcclxuICB9O1xyXG5cclxuY29uc3QgYXBwID0gaW5pdGlhbGl6ZUFwcChmaXJlYmFzZUNvbmZpZyk7XHJcbmNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRCb29rcyhkYikge1xyXG4gICAgY29uc3QgYm9va0NvbCA9IGNvbGxlY3Rpb24oZGIsICdib29rcycpO1xyXG4gICAgY29uc3QgYm9va1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhib29rQ29sKTtcclxuICAgIGNvbnN0IGJvb2tMaXN0ID0gYm9va1NuYXBzaG90LmRvY3MubWFwKGRvYyA9PiBkb2MuZGF0YSgpKTtcclxuICAgIGNvbnNvbGUubG9nKGJvb2tMaXN0KVxyXG4gICAgcmV0dXJuIGJvb2tMaXN0O1xyXG4gIH1cclxuXHJcbiAgZHVtbXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBnZXRCb29rcyhkYikpXHJcblxyXG5vcGVuTW9kYWwuZm9yRWFjaChidXR0b24gPT4gXHJcbiAgICB7YnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihidXR0b24uZGF0YXNldC5tb2RhbFRhcmdldClcclxuICAgICAgICBvcGVuTW9kYWxGdW5jdGlvbihtb2RhbClcclxuICAgIH0pfSlcclxuXHJcbmZ1bmN0aW9uIG9wZW5Nb2RhbEZ1bmN0aW9uKG1vZGFsKSB7XHJcbiAgICBpZiAobW9kYWwgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgbW9kYWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXHJcbn1cclxuXHJcbmNsb3NlTW9kYWwuZm9yRWFjaChidXR0b24gPT5cclxuICAgIHtidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW9kYWwgPSBidXR0b24uY2xvc2VzdCgnLm1vZGFsJylcclxuICAgICAgICBjbG9zZU1vZGFsRnVuY3Rpb24obW9kYWwpXHJcbiAgICB9KX0pXHJcblxyXG5mdW5jdGlvbiBjbG9zZU1vZGFsRnVuY3Rpb24obW9kYWwpIHtcclxuICAgIGlmIChtb2RhbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgIG92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcclxufVxyXG5cclxub3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgIGNvbnN0IG1vZGFscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbC5hY3RpdmUnKVxyXG4gICAgbW9kYWxzLmZvckVhY2gobW9kYWwgPT4gY2xvc2VNb2RhbEZ1bmN0aW9uKG1vZGFsKSlcclxufSlcclxuXHJcbmxldCBhcnJheSA9IFtdXHJcblxyXG5jbGFzcyBCb29rIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpdGxlLCBhdXRob3IsIHBhZ2VzLCByZWFkKSB7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlXHJcbiAgICAgICAgdGhpcy5hdXRob3IgPSBhdXRob3JcclxuICAgICAgICB0aGlzLnBhZ2VzID0gcGFnZXNcclxuICAgICAgICB0aGlzLnJlYWQgPSByZWFkXHJcbiAgICB9fVxyXG5cclxuLy8gY29uc3QgYm9vazEgPSBuZXcgQm9vayhcIlRoZSBIb2JiaXRcIiwgXCJKUlIgVG9sa2llblwiLCBcIjI1NiBwYWdlc1wiKVxyXG4vLyBjb25zdCBib29rMiA9IG5ldyBCb29rKFwiU29uZyBvZiBJY2UgYW5kIEZpcmVcIiwgXCJHZW9yZ2UgUlIgTWFydGluXCIsIFwiMywwMDAgcGFnZXNcIilcclxuLy8gY29uc3QgYm9vazMgPSBuZXcgQm9vayhcIkJlZ2luIHRvIENvZGUgd2l0aCBKQXZhc2NyaXB0XCIsIFwiUm9iIE1pbGVzXCIsIFwiNTAwIHBhZ2VzXCIpXHJcblxyXG5mdW5jdGlvbiBhZGRCb29rKGUpIHtcclxuICAgIGxldCB0aXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9dGl0bGVdJykudmFsdWVcclxuICAgIGxldCBhdXRob3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPWF1dGhvci1uYW1lXScpLnZhbHVlXHJcbiAgICBsZXQgcGFnZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPXBhZ2VzXScpLnZhbHVlXHJcbiAgICBsZXQgcmVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9Y2hlY2tib3hdJykuY2hlY2tlZFxyXG4gICAgbGV0IGJvb2sgPSBuZXcgQm9vayh0aXRsZSwgYXV0aG9yLCBwYWdlcywgcmVhZClcclxuICAgIGFycmF5LnB1c2goYm9vaylcclxuICAgIG1ha2VOZXdDYXJkKGJvb2spXHJcbiAgICByZXNldCgpXHJcbn1cclxuXHJcbnN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICBsZXQgaXNWYWxpZCA9IGZvcm0uY2hlY2tWYWxpZGl0eSgpXHJcbiAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InKX1cclxuICAgIGlmIChpc1ZhbGlkKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgYWRkQm9vayhlKX19XHJcbiAgICApO1xyXG5cclxuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcclxuICAgIGNvbnN0IGlzVmFsaWQgPSBlLnRhcmdldC5yZXBvcnRWYWxpZGl0eSgpXHJcbiAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICFpc1ZhbGlkKVxyXG59KVxyXG5cclxuZnVuY3Rpb24gbWFrZU5ld0NhcmQoYm9vaykge1xyXG4gICAgLy9cclxuICAgIGxldCBuZXdDYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBuZXdDYXJkLmNsYXNzTmFtZSA9IFwiY2FyZFwiO1xyXG4gICAgY2FyZGhvbGRlci5hcHBlbmRDaGlsZChuZXdDYXJkKVxyXG4gICAgLy9cclxuICAgIGxldCBuZXdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgbmV3RGl2LmNsYXNzTGlzdC5hZGQoJ2Nsb3NlLWNhcmQnKVxyXG4gICAgbmV3RGl2LmlubmVySFRNTCA9ICc8c3BhbiBpZD1cImNsb3NlLWJ1dHRvblwiIG9uY2xpY2s9XCJ0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTsgcmV0dXJuIGZhbHNlO1wiPiZ0aW1lczs8L3NwYW4+J1xyXG4gICAgbmV3Q2FyZC5hcHBlbmRDaGlsZChuZXdEaXYpXHJcbiAgICAvL1xyXG4gICAgbGV0IGNhcmRUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxyXG4gICAgY2FyZFRpdGxlLmlkID0gXCJjYXJkLXRpdGxlXCJcclxuICAgIGNhcmRUaXRsZS50ZXh0Q29udGVudCA9IGAke2Jvb2sudGl0bGV9YFxyXG4gICAgbmV3Q2FyZC5hcHBlbmRDaGlsZChjYXJkVGl0bGUpXHJcbiAgICAvL1xyXG4gICAgbGV0IGNhcmRBdXRob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcclxuICAgIGNhcmRBdXRob3IuaWQgPSBcImNhcmQtYXV0aG9yXCJcclxuICAgIGNhcmRBdXRob3IudGV4dENvbnRlbnQgPSBgJHtib29rLmF1dGhvcn1gXHJcbiAgICBuZXdDYXJkLmFwcGVuZENoaWxkKGNhcmRBdXRob3IpXHJcbiAgICAvL1xyXG4gICAgbGV0IGNhcmRQYWdlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxyXG4gICAgY2FyZFBhZ2VzLmlkID0gXCJjYXJkLXBhZ2VzXCJcclxuICAgIGNhcmRQYWdlcy50ZXh0Q29udGVudCA9IGAke2Jvb2sucGFnZXN9YFxyXG4gICAgbmV3Q2FyZC5hcHBlbmRDaGlsZChjYXJkUGFnZXMpXHJcbiAgICAvL1xyXG4gICAgbGV0IHJlYWREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgcmVhZERpdi5jbGFzc0xpc3QuYWRkKCdyZWFkRGl2JylcclxuICAgIGxldCByZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXHJcbiAgICByZWFkLnRleHRDb250ZW50PVwiUmVhZD9cIlxyXG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxyXG4gICAgaW5wdXRFbGVtZW50LnR5cGUgPSAnY2hlY2tib3gnXHJcbiAgICBpbnB1dEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3gnKVxyXG4gICAgaW5wdXRFbGVtZW50LmNoZWNrZWQgPSAoYm9vay5yZWFkID8gdHJ1ZSA6IGZhbHNlKVxyXG4gICAgaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGJvb2sucmVhZCA9PSBmYWxzZSkge3JldHVybiBpbnB1dEVsZW1lbnQuY2hlY2tlZCA9PSBmYWxzZX1cclxuICAgICAgICBlbHNlIHtpbnB1dEVsZW1lbnQuY2hlY2tlZCA9PSB0cnVlfVxyXG4gICAgfSlcclxuICAgIHJlYWREaXYuYXBwZW5kQ2hpbGQocmVhZClcclxuICAgIHJlYWREaXYuYXBwZW5kQ2hpbGQoaW5wdXRFbGVtZW50KVxyXG4gICAgbmV3Q2FyZC5hcHBlbmRDaGlsZChyZWFkRGl2KVxyXG4gICAgLy9cclxuICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3VzZXItZm9ybScpLnJlc2V0KClcclxuICAgIGxldCBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2RhbCcpXHJcbiAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgIG92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcclxufVxyXG5cclxuLy9mdW5jdGlvbiAiXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJnZXREb2NzIiwic3R5bGVzaGVldCIsIm9wZW5Nb2RhbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImNsb3NlTW9kYWwiLCJvdmVybGF5IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdWJtaXQiLCJhdXRob3IiLCJ0aXRsZSIsInBhZ2VzIiwiY2FyZGhvbGRlciIsInF1ZXJ5U2VsZWN0b3IiLCJmb3JtIiwiaW5wdXQiLCJkdW1teSIsImZpcmViYXNlQ29uZmlnIiwiYXBpS2V5IiwiYXV0aERvbWFpbiIsInByb2plY3RJZCIsInN0b3JhZ2VCdWNrZXQiLCJtZXNzYWdpbmdTZW5kZXJJZCIsImFwcElkIiwiYXBwIiwiZGIiLCJnZXRCb29rcyIsImJvb2tDb2wiLCJib29rU25hcHNob3QiLCJib29rTGlzdCIsImRvY3MiLCJtYXAiLCJkb2MiLCJkYXRhIiwiY29uc29sZSIsImxvZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJmb3JFYWNoIiwiYnV0dG9uIiwibW9kYWwiLCJkYXRhc2V0IiwibW9kYWxUYXJnZXQiLCJvcGVuTW9kYWxGdW5jdGlvbiIsImNsYXNzTGlzdCIsImFkZCIsImNsb3Nlc3QiLCJjbG9zZU1vZGFsRnVuY3Rpb24iLCJyZW1vdmUiLCJtb2RhbHMiLCJhcnJheSIsIkJvb2siLCJyZWFkIiwiYWRkQm9vayIsImUiLCJ2YWx1ZSIsImNoZWNrZWQiLCJib29rIiwicHVzaCIsIm1ha2VOZXdDYXJkIiwicmVzZXQiLCJpc1ZhbGlkIiwiY2hlY2tWYWxpZGl0eSIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0IiwicmVwb3J0VmFsaWRpdHkiLCJzZXRBdHRyaWJ1dGUiLCJuZXdDYXJkIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwibmV3RGl2IiwiaW5uZXJIVE1MIiwiY2FyZFRpdGxlIiwiaWQiLCJ0ZXh0Q29udGVudCIsImNhcmRBdXRob3IiLCJjYXJkUGFnZXMiLCJyZWFkRGl2IiwiaW5wdXRFbGVtZW50IiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"* {\\r\\n    margin:0;\\r\\n    padding:0;\\r\\n    font-family:\\\"Merienda\\\", sans-serif;\\r\\n}\\r\\n\\r\\n.container {\\r\\n    display:grid;\\r\\n    grid-template-rows: 150px 50px 1fr;\\r\\n    grid-template-columns: 1fr;\\r\\n    gap:1em;\\r\\n}\\r\\n\\r\\n.header {\\r\\n    grid-area: 1 / 1 / 2 / 2;\\r\\n    background-image: linear-gradient(to bottom, #bbc4ff, #cfd2ff, #e1e0ff, #f1efff, #ffffff);\\r\\n    display:flex;\\r\\n    justify-content: center;\\r\\n    gap: 1em;\\r\\n}\\r\\n\\r\\n.title_bar {\\r\\n    margin: 20px;\\r\\n    font-size: 40px; \\r\\n    color: #5e0913;\\r\\n}\\r\\n\\r\\n.user_info {\\r\\n    display:flex;\\r\\n    align-items:center;\\r\\n    gap: 15px;\\r\\n    margin: 20px;\\r\\n    font-size: 20px;\\r\\n    color:#5e0913\\r\\n}\\r\\n\\r\\n.avatar {\\r\\n    height: 40px;\\r\\n}\\r\\n\\r\\n.cardholder {\\r\\n    display:grid;\\r\\n    grid-template-rows: repeat(auto-fit);\\r\\n    grid-template-columns: repeat(auto-fit, minmax(200px, 400px))\\r\\n}\\r\\n\\r\\n.card {\\r\\n    border: 1px solid black;\\r\\n    margin-left:15px;\\r\\n    margin-right:15px;\\r\\n    margin-bottom:15px;\\r\\n    padding:15px;\\r\\n    display:flex;\\r\\n    border-radius: 10px;\\r\\n    flex-direction: column;\\r\\n    font-size: 20px;\\r\\n    margin-top:0px;\\r\\n    padding-top:0px;\\r\\n    box-shadow: rgba(100, 100, 111, 0.2) 0px 7px 29px 0px;\\r\\n    border:#5e0913 1px dotted\\r\\n}\\r\\n\\r\\n.card > * {\\r\\n    padding:5px;\\r\\n}\\r\\n\\r\\n.close-card {\\r\\n    align-self:flex-end;\\r\\n    height:15px\\r\\n}\\r\\n\\r\\n.readDiv {\\r\\n    display:flex;\\r\\n    gap: 1rem;\\r\\n}\\r\\n\\r\\n.modal {\\r\\n    position:fixed;\\r\\n    top:50%;\\r\\n    left: 50%;\\r\\n    transform:translate(-50%, -50%) scale(0);\\r\\n    transition: 200ms ease-in-out;\\r\\n    border:1px solid black;\\r\\n    border-radius:10px;\\r\\n    padding: 20px;\\r\\n    z-index:10;\\r\\n    background-color:white;\\r\\n    width:35%;\\r\\n    max-width:80%;\\r\\n    color:#5e0913\\r\\n}\\r\\n\\r\\n.modal.active {\\r\\n    transform:translate(-50%, -50%) scale(1);\\r\\n}\\r\\n\\r\\n.modal-header {\\r\\n    display:flex;\\r\\n    justify-content: space-between;\\r\\n    align-items: center;\\r\\n    padding:20px;\\r\\n}\\r\\n\\r\\n.modal-close-button {\\r\\n    cursor:pointer;\\r\\n    border:none;\\r\\n    outline:none;\\r\\n    background:none;\\r\\n    font-size:1.25rem;\\r\\n    font-weight:bold;\\r\\n}\\r\\n\\r\\n#overlay {\\r\\n    position:fixed;\\r\\n    opacity:0;\\r\\n    top:0;\\r\\n    bottom:0;\\r\\n    left:0;\\r\\n    right:0;\\r\\n    background-color:rgba(0, 0, 0, .5);\\r\\n    transition: 200ms ease-in-out;\\r\\n    pointer-events:none;\\r\\n}\\r\\n\\r\\n#overlay.active {\\r\\n    opacity: 1;\\r\\n    pointer-events:all;\\r\\n\\r\\n}\\r\\n\\r\\n#close-button {\\r\\n    cursor:pointer;\\r\\n    font-weight:bold;\\r\\n    font-size: 1.5rem;\\r\\n    color:#5e0913\\r\\n}\\r\\n\\r\\n#modal-button {\\r\\n    position:relative;\\r\\n    left:40%;\\r\\n    font-size: 20px;\\r\\n    background-color:#e5e9fc;\\r\\n    cursor:pointer;\\r\\n    border-radius: 15px;\\r\\n    padding:12px;\\r\\n    border:.5px solid #5e0913;\\r\\n    box-shadow: rgba(100, 100, 111, 0.2) 0px 7px 29px 0px;\\r\\n}\\r\\n\\r\\n#modal-button:hover {\\r\\n    border: 2px solid #5e0913;\\r\\n    background-color: #cbd3ff;\\r\\n}\\r\\n\\r\\n#user-form {\\r\\n    align-items:center;\\r\\n    justify-content:center;\\r\\n    padding: 10px;\\r\\n    color:#5e0913;\\r\\n    margin-left:25%;\\r\\n}\\r\\n\\r\\n#user-form > * {\\r\\n    margin: 10px;\\r\\n}\\r\\n\\r\\n#submit {\\r\\n    font-size: 20px;\\r\\n    background-color: #cbd3ff;\\r\\n    cursor:pointer;\\r\\n    border-radius: 20px;\\r\\n    padding:10px;\\r\\n    border:.5px solid #5e0913;\\r\\n    color:#5e0913;\\r\\n    box-shadow: rgba(100, 100, 111, 0.2) 0px 7px 29px 0px;\\r\\n}\\r\\n\\r\\n#submit:hover {\\r\\n    background-color:#bbc4ff; \\r\\n}\\r\\n\\r\\ninput:invalid {\\r\\n    border:#5e0913 1px solid\\r\\n}\\r\\n\\r\\ninput:focus:invalid {\\r\\n    background:#bbc4ffa3\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/styles.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,QAAQ;IACR,SAAS;IACT,kCAAkC;AACtC;;AAEA;IACI,YAAY;IACZ,kCAAkC;IAClC,0BAA0B;IAC1B,OAAO;AACX;;AAEA;IACI,wBAAwB;IACxB,yFAAyF;IACzF,YAAY;IACZ,uBAAuB;IACvB,QAAQ;AACZ;;AAEA;IACI,YAAY;IACZ,eAAe;IACf,cAAc;AAClB;;AAEA;IACI,YAAY;IACZ,kBAAkB;IAClB,SAAS;IACT,YAAY;IACZ,eAAe;IACf;AACJ;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,oCAAoC;IACpC;AACJ;;AAEA;IACI,uBAAuB;IACvB,gBAAgB;IAChB,iBAAiB;IACjB,kBAAkB;IAClB,YAAY;IACZ,YAAY;IACZ,mBAAmB;IACnB,sBAAsB;IACtB,eAAe;IACf,cAAc;IACd,eAAe;IACf,qDAAqD;IACrD;AACJ;;AAEA;IACI,WAAW;AACf;;AAEA;IACI,mBAAmB;IACnB;AACJ;;AAEA;IACI,YAAY;IACZ,SAAS;AACb;;AAEA;IACI,cAAc;IACd,OAAO;IACP,SAAS;IACT,wCAAwC;IACxC,6BAA6B;IAC7B,sBAAsB;IACtB,kBAAkB;IAClB,aAAa;IACb,UAAU;IACV,sBAAsB;IACtB,SAAS;IACT,aAAa;IACb;AACJ;;AAEA;IACI,wCAAwC;AAC5C;;AAEA;IACI,YAAY;IACZ,8BAA8B;IAC9B,mBAAmB;IACnB,YAAY;AAChB;;AAEA;IACI,cAAc;IACd,WAAW;IACX,YAAY;IACZ,eAAe;IACf,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,cAAc;IACd,SAAS;IACT,KAAK;IACL,QAAQ;IACR,MAAM;IACN,OAAO;IACP,kCAAkC;IAClC,6BAA6B;IAC7B,mBAAmB;AACvB;;AAEA;IACI,UAAU;IACV,kBAAkB;;AAEtB;;AAEA;IACI,cAAc;IACd,gBAAgB;IAChB,iBAAiB;IACjB;AACJ;;AAEA;IACI,iBAAiB;IACjB,QAAQ;IACR,eAAe;IACf,wBAAwB;IACxB,cAAc;IACd,mBAAmB;IACnB,YAAY;IACZ,yBAAyB;IACzB,qDAAqD;AACzD;;AAEA;IACI,yBAAyB;IACzB,yBAAyB;AAC7B;;AAEA;IACI,kBAAkB;IAClB,sBAAsB;IACtB,aAAa;IACb,aAAa;IACb,eAAe;AACnB;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,yBAAyB;IACzB,cAAc;IACd,mBAAmB;IACnB,YAAY;IACZ,yBAAyB;IACzB,aAAa;IACb,qDAAqD;AACzD;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI;AACJ;;AAEA;IACI;AACJ\",\"sourcesContent\":[\"* {\\r\\n    margin:0;\\r\\n    padding:0;\\r\\n    font-family:\\\"Merienda\\\", sans-serif;\\r\\n}\\r\\n\\r\\n.container {\\r\\n    display:grid;\\r\\n    grid-template-rows: 150px 50px 1fr;\\r\\n    grid-template-columns: 1fr;\\r\\n    gap:1em;\\r\\n}\\r\\n\\r\\n.header {\\r\\n    grid-area: 1 / 1 / 2 / 2;\\r\\n    background-image: linear-gradient(to bottom, #bbc4ff, #cfd2ff, #e1e0ff, #f1efff, #ffffff);\\r\\n    display:flex;\\r\\n    justify-content: center;\\r\\n    gap: 1em;\\r\\n}\\r\\n\\r\\n.title_bar {\\r\\n    margin: 20px;\\r\\n    font-size: 40px; \\r\\n    color: #5e0913;\\r\\n}\\r\\n\\r\\n.user_info {\\r\\n    display:flex;\\r\\n    align-items:center;\\r\\n    gap: 15px;\\r\\n    margin: 20px;\\r\\n    font-size: 20px;\\r\\n    color:#5e0913\\r\\n}\\r\\n\\r\\n.avatar {\\r\\n    height: 40px;\\r\\n}\\r\\n\\r\\n.cardholder {\\r\\n    display:grid;\\r\\n    grid-template-rows: repeat(auto-fit);\\r\\n    grid-template-columns: repeat(auto-fit, minmax(200px, 400px))\\r\\n}\\r\\n\\r\\n.card {\\r\\n    border: 1px solid black;\\r\\n    margin-left:15px;\\r\\n    margin-right:15px;\\r\\n    margin-bottom:15px;\\r\\n    padding:15px;\\r\\n    display:flex;\\r\\n    border-radius: 10px;\\r\\n    flex-direction: column;\\r\\n    font-size: 20px;\\r\\n    margin-top:0px;\\r\\n    padding-top:0px;\\r\\n    box-shadow: rgba(100, 100, 111, 0.2) 0px 7px 29px 0px;\\r\\n    border:#5e0913 1px dotted\\r\\n}\\r\\n\\r\\n.card > * {\\r\\n    padding:5px;\\r\\n}\\r\\n\\r\\n.close-card {\\r\\n    align-self:flex-end;\\r\\n    height:15px\\r\\n}\\r\\n\\r\\n.readDiv {\\r\\n    display:flex;\\r\\n    gap: 1rem;\\r\\n}\\r\\n\\r\\n.modal {\\r\\n    position:fixed;\\r\\n    top:50%;\\r\\n    left: 50%;\\r\\n    transform:translate(-50%, -50%) scale(0);\\r\\n    transition: 200ms ease-in-out;\\r\\n    border:1px solid black;\\r\\n    border-radius:10px;\\r\\n    padding: 20px;\\r\\n    z-index:10;\\r\\n    background-color:white;\\r\\n    width:35%;\\r\\n    max-width:80%;\\r\\n    color:#5e0913\\r\\n}\\r\\n\\r\\n.modal.active {\\r\\n    transform:translate(-50%, -50%) scale(1);\\r\\n}\\r\\n\\r\\n.modal-header {\\r\\n    display:flex;\\r\\n    justify-content: space-between;\\r\\n    align-items: center;\\r\\n    padding:20px;\\r\\n}\\r\\n\\r\\n.modal-close-button {\\r\\n    cursor:pointer;\\r\\n    border:none;\\r\\n    outline:none;\\r\\n    background:none;\\r\\n    font-size:1.25rem;\\r\\n    font-weight:bold;\\r\\n}\\r\\n\\r\\n#overlay {\\r\\n    position:fixed;\\r\\n    opacity:0;\\r\\n    top:0;\\r\\n    bottom:0;\\r\\n    left:0;\\r\\n    right:0;\\r\\n    background-color:rgba(0, 0, 0, .5);\\r\\n    transition: 200ms ease-in-out;\\r\\n    pointer-events:none;\\r\\n}\\r\\n\\r\\n#overlay.active {\\r\\n    opacity: 1;\\r\\n    pointer-events:all;\\r\\n\\r\\n}\\r\\n\\r\\n#close-button {\\r\\n    cursor:pointer;\\r\\n    font-weight:bold;\\r\\n    font-size: 1.5rem;\\r\\n    color:#5e0913\\r\\n}\\r\\n\\r\\n#modal-button {\\r\\n    position:relative;\\r\\n    left:40%;\\r\\n    font-size: 20px;\\r\\n    background-color:#e5e9fc;\\r\\n    cursor:pointer;\\r\\n    border-radius: 15px;\\r\\n    padding:12px;\\r\\n    border:.5px solid #5e0913;\\r\\n    box-shadow: rgba(100, 100, 111, 0.2) 0px 7px 29px 0px;\\r\\n}\\r\\n\\r\\n#modal-button:hover {\\r\\n    border: 2px solid #5e0913;\\r\\n    background-color: #cbd3ff;\\r\\n}\\r\\n\\r\\n#user-form {\\r\\n    align-items:center;\\r\\n    justify-content:center;\\r\\n    padding: 10px;\\r\\n    color:#5e0913;\\r\\n    margin-left:25%;\\r\\n}\\r\\n\\r\\n#user-form > * {\\r\\n    margin: 10px;\\r\\n}\\r\\n\\r\\n#submit {\\r\\n    font-size: 20px;\\r\\n    background-color: #cbd3ff;\\r\\n    cursor:pointer;\\r\\n    border-radius: 20px;\\r\\n    padding:10px;\\r\\n    border:.5px solid #5e0913;\\r\\n    color:#5e0913;\\r\\n    box-shadow: rgba(100, 100, 111, 0.2) 0px 7px 29px 0px;\\r\\n}\\r\\n\\r\\n#submit:hover {\\r\\n    background-color:#bbc4ff; \\r\\n}\\r\\n\\r\\ninput:invalid {\\r\\n    border:#5e0913 1px solid\\r\\n}\\r\\n\\r\\ninput:focus:invalid {\\r\\n    background:#bbc4ffa3\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZXMuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEc7QUFDakI7QUFDekYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBLDZDQUE2QyxpQkFBaUIsa0JBQWtCLDZDQUE2QyxLQUFLLG9CQUFvQixxQkFBcUIsMkNBQTJDLG1DQUFtQyxnQkFBZ0IsS0FBSyxpQkFBaUIsaUNBQWlDLGtHQUFrRyxxQkFBcUIsZ0NBQWdDLGlCQUFpQixLQUFLLG9CQUFvQixxQkFBcUIseUJBQXlCLHVCQUF1QixLQUFLLG9CQUFvQixxQkFBcUIsMkJBQTJCLGtCQUFrQixxQkFBcUIsd0JBQXdCLDBCQUEwQixpQkFBaUIscUJBQXFCLEtBQUsscUJBQXFCLHFCQUFxQiw2Q0FBNkMsMEVBQTBFLGVBQWUsZ0NBQWdDLHlCQUF5QiwwQkFBMEIsMkJBQTJCLHFCQUFxQixxQkFBcUIsNEJBQTRCLCtCQUErQix3QkFBd0IsdUJBQXVCLHdCQUF3Qiw4REFBOEQsc0NBQXNDLG1CQUFtQixvQkFBb0IsS0FBSyxxQkFBcUIsNEJBQTRCLHdCQUF3QixrQkFBa0IscUJBQXFCLGtCQUFrQixLQUFLLGdCQUFnQix1QkFBdUIsZ0JBQWdCLGtCQUFrQixpREFBaUQsc0NBQXNDLCtCQUErQiwyQkFBMkIsc0JBQXNCLG1CQUFtQiwrQkFBK0Isa0JBQWtCLHNCQUFzQiwwQkFBMEIsdUJBQXVCLGlEQUFpRCxLQUFLLHVCQUF1QixxQkFBcUIsdUNBQXVDLDRCQUE0QixxQkFBcUIsS0FBSyw2QkFBNkIsdUJBQXVCLG9CQUFvQixxQkFBcUIsd0JBQXdCLDBCQUEwQix5QkFBeUIsS0FBSyxrQkFBa0IsdUJBQXVCLGtCQUFrQixjQUFjLGlCQUFpQixlQUFlLGdCQUFnQiwyQ0FBMkMsc0NBQXNDLDRCQUE0QixLQUFLLHlCQUF5QixtQkFBbUIsMkJBQTJCLFNBQVMsdUJBQXVCLHVCQUF1Qix5QkFBeUIs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LHlCQUF5QixtQkFBbUIsMkJBQTJCLFNBQVMsdUJBQXVCLHVCQUF1Qix5QkFBeUIsMEJBQTBCLDBCQUEwQix1QkFBdUIsMEJBQTBCLGlCQUFpQix3QkFBd0IsaUNBQWlDLHVCQUF1Qiw0QkFBNEIscUJBQXFCLGtDQUFrQyw4REFBOEQsS0FBSyw2QkFBNkIsa0NBQWtDLGtDQUFrQyxLQUFLLG9CQUFvQiwyQkFBMkIsK0JBQStCLHNCQUFzQixzQkFBc0Isd0JBQXdCLEtBQUssd0JBQXdCLHFCQUFxQixLQUFLLGlCQUFpQix3QkFBd0Isa0NBQWtDLHVCQUF1Qiw0QkFBNEIscUJBQXFCLGtDQUFrQyxzQkFBc0IsOERBQThELEtBQUssdUJBQXVCLGtDQUFrQyxLQUFLLHVCQUF1QixxQ0FBcUMsNkJBQTZCLGlDQUFpQyxtQkFBbUI7QUFDNzNSO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saWJyYXJ5Ly4vc3JjL3N0eWxlcy5jc3M/ZTlhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIioge1xcclxcbiAgICBtYXJnaW46MDtcXHJcXG4gICAgcGFkZGluZzowO1xcclxcbiAgICBmb250LWZhbWlseTpcXFwiTWVyaWVuZGFcXFwiLCBzYW5zLXNlcmlmO1xcclxcbn1cXHJcXG5cXHJcXG4uY29udGFpbmVyIHtcXHJcXG4gICAgZGlzcGxheTpncmlkO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IDE1MHB4IDUwcHggMWZyO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcXHJcXG4gICAgZ2FwOjFlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciB7XFxyXFxuICAgIGdyaWQtYXJlYTogMSAvIDEgLyAyIC8gMjtcXHJcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgI2JiYzRmZiwgI2NmZDJmZiwgI2UxZTBmZiwgI2YxZWZmZiwgI2ZmZmZmZik7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgIGdhcDogMWVtO1xcclxcbn1cXHJcXG5cXHJcXG4udGl0bGVfYmFyIHtcXHJcXG4gICAgbWFyZ2luOiAyMHB4O1xcclxcbiAgICBmb250LXNpemU6IDQwcHg7IFxcclxcbiAgICBjb2xvcjogIzVlMDkxMztcXHJcXG59XFxyXFxuXFxyXFxuLnVzZXJfaW5mbyB7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAgYWxpZ24taXRlbXM6Y2VudGVyO1xcclxcbiAgICBnYXA6IDE1cHg7XFxyXFxuICAgIG1hcmdpbjogMjBweDtcXHJcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcclxcbiAgICBjb2xvcjojNWUwOTEzXFxyXFxufVxcclxcblxcclxcbi5hdmF0YXIge1xcclxcbiAgICBoZWlnaHQ6IDQwcHg7XFxyXFxufVxcclxcblxcclxcbi5jYXJkaG9sZGVyIHtcXHJcXG4gICAgZGlzcGxheTpncmlkO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdChhdXRvLWZpdCk7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMjAwcHgsIDQwMHB4KSlcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXHJcXG4gICAgbWFyZ2luLWxlZnQ6MTVweDtcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OjE1cHg7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206MTVweDtcXHJcXG4gICAgcGFkZGluZzoxNXB4O1xcclxcbiAgICBkaXNwbGF5OmZsZXg7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXHJcXG4gICAgbWFyZ2luLXRvcDowcHg7XFxyXFxuICAgIHBhZGRpbmctdG9wOjBweDtcXHJcXG4gICAgYm94LXNoYWRvdzogcmdiYSgxMDAsIDEwMCwgMTExLCAwLjIpIDBweCA3cHggMjlweCAwcHg7XFxyXFxuICAgIGJvcmRlcjojNWUwOTEzIDFweCBkb3R0ZWRcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQgPiAqIHtcXHJcXG4gICAgcGFkZGluZzo1cHg7XFxyXFxufVxcclxcblxcclxcbi5jbG9zZS1jYXJkIHtcXHJcXG4gICAgYWxpZ24tc2VsZjpmbGV4LWVuZDtcXHJcXG4gICAgaGVpZ2h0OjE1cHhcXHJcXG59XFxyXFxuXFxyXFxuLnJlYWREaXYge1xcclxcbiAgICBkaXNwbGF5OmZsZXg7XFxyXFxuICAgIGdhcDogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsIHtcXHJcXG4gICAgcG9zaXRpb246Zml4ZWQ7XFxyXFxuICAgIHRvcDo1MCU7XFxyXFxuICAgIGxlZnQ6IDUwJTtcXHJcXG4gICAgdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgwKTtcXHJcXG4gICAgdHJhbnNpdGlvbjogMjAwbXMgZWFzZS1pbi1vdXQ7XFxyXFxuICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6MTBweDtcXHJcXG4gICAgcGFkZGluZzogMjBweDtcXHJcXG4gICAgei1pbmRleDoxMDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtcXHJcXG4gICAgd2lkdGg6MzUlO1xcclxcbiAgICBtYXgtd2lkdGg6ODAlO1xcclxcbiAgICBjb2xvcjojNWUwOTEzXFxyXFxufVxcclxcblxcclxcbi5tb2RhbC5hY3RpdmUge1xcclxcbiAgICB0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpIHNjYWxlKDEpO1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwtaGVhZGVyIHtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIHBhZGRpbmc6MjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWNsb3NlLWJ1dHRvbiB7XFxyXFxuICAgIGN1cnNvcjpwb2ludGVyO1xcclxcbiAgICBib3JkZXI6bm9uZTtcXHJcXG4gICAgb3V0bGluZTpub25lO1xcclxcbiAgICBiYWNrZ3JvdW5kOm5vbmU7XFxyXFxuICAgIGZvbnQtc2l6ZToxLjI1cmVtO1xcclxcbiAgICBmb250LXdlaWdodDpib2xkO1xcclxcbn1cXHJcXG5cXHJcXG4jb3ZlcmxheSB7XFxyXFxuICAgIHBvc2l0aW9uOmZpeGVkO1xcclxcbiAgICBvcGFjaXR5OjA7XFxyXFxuICAgIHRvcDowO1xcclxcbiAgICBib3R0b206MDtcXHJcXG4gICAgbGVmdDowO1xcclxcbiAgICByaWdodDowO1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwgMCwgMCwgLjUpO1xcclxcbiAgICB0cmFuc2l0aW9uOiAyMDBtcyBlYXNlLWluLW91dDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6bm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuI292ZXJsYXkuYWN0aXZlIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6YWxsO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4jY2xvc2UtYnV0dG9uIHtcXHJcXG4gICAgY3Vyc29yOnBvaW50ZXI7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbiAgICBjb2xvcjojNWUwOTEzXFxyXFxufVxcclxcblxcclxcbiNtb2RhbC1idXR0b24ge1xcclxcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcXHJcXG4gICAgbGVmdDo0MCU7XFxyXFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZTVlOWZjO1xcclxcbiAgICBjdXJzb3I6cG9pbnRlcjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTVweDtcXHJcXG4gICAgcGFkZGluZzoxMnB4O1xcclxcbiAgICBib3JkZXI6LjVweCBzb2xpZCAjNWUwOTEzO1xcclxcbiAgICBib3gtc2hhZG93OiByZ2JhKDEwMCwgMTAwLCAxMTEsIDAuMikgMHB4IDdweCAyOXB4IDBweDtcXHJcXG59XFxyXFxuXFxyXFxuI21vZGFsLWJ1dHRvbjpob3ZlciB7XFxyXFxuICAgIGJvcmRlcjogMnB4IHNvbGlkICM1ZTA5MTM7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNjYmQzZmY7XFxyXFxufVxcclxcblxcclxcbiN1c2VyLWZvcm0ge1xcclxcbiAgICBhbGlnbi1pdGVtczpjZW50ZXI7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDpjZW50ZXI7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAgIGNvbG9yOiM1ZTA5MTM7XFxyXFxuICAgIG1hcmdpbi1sZWZ0OjI1JTtcXHJcXG59XFxyXFxuXFxyXFxuI3VzZXItZm9ybSA+ICoge1xcclxcbiAgICBtYXJnaW46IDEwcHg7XFxyXFxufVxcclxcblxcclxcbiNzdWJtaXQge1xcclxcbiAgICBmb250LXNpemU6IDIwcHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNjYmQzZmY7XFxyXFxuICAgIGN1cnNvcjpwb2ludGVyO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgICBwYWRkaW5nOjEwcHg7XFxyXFxuICAgIGJvcmRlcjouNXB4IHNvbGlkICM1ZTA5MTM7XFxyXFxuICAgIGNvbG9yOiM1ZTA5MTM7XFxyXFxuICAgIGJveC1zaGFkb3c6IHJnYmEoMTAwLCAxMDAsIDExMSwgMC4yKSAwcHggN3B4IDI5cHggMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4jc3VibWl0OmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojYmJjNGZmOyBcXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQ6aW52YWxpZCB7XFxyXFxuICAgIGJvcmRlcjojNWUwOTEzIDFweCBzb2xpZFxcclxcbn1cXHJcXG5cXHJcXG5pbnB1dDpmb2N1czppbnZhbGlkIHtcXHJcXG4gICAgYmFja2dyb3VuZDojYmJjNGZmYTNcXHJcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxRQUFRO0lBQ1IsU0FBUztJQUNULGtDQUFrQztBQUN0Qzs7QUFFQTtJQUNJLFlBQVk7SUFDWixrQ0FBa0M7SUFDbEMsMEJBQTBCO0lBQzFCLE9BQU87QUFDWDs7QUFFQTtJQUNJLHdCQUF3QjtJQUN4Qix5RkFBeUY7SUFDekYsWUFBWTtJQUNaLHVCQUF1QjtJQUN2QixRQUFRO0FBQ1o7O0FBRUE7SUFDSSxZQUFZO0lBQ1osZUFBZTtJQUNmLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLFNBQVM7SUFDVCxZQUFZO0lBQ1osZUFBZTtJQUNmO0FBQ0o7O0FBRUE7SUFDSSxZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksWUFBWTtJQUNaLG9DQUFvQztJQUNwQztBQUNKOztBQUVBO0lBQ0ksdUJBQXVCO0lBQ3ZCLGdCQUFnQjtJQUNoQixpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLFlBQVk7SUFDWixZQUFZO0lBQ1osbUJBQW1CO0lBQ25CLHNCQUFzQjtJQUN0QixlQUFlO0lBQ2YsY0FBYztJQUNkLGVBQWU7SUFDZixxREFBcUQ7SUFDckQ7QUFDSjs7QUFFQTtJQUNJLFdBQVc7QUFDZjs7QUFFQTtJQUNJLG1CQUFtQjtJQUNuQjtBQUNKOztBQUVBO0lBQ0ksWUFBWTtJQUNaLFNBQVM7QUFDYjs7QUFFQTtJQUNJLGNBQWM7SUFDZCxPQUFPO0lBQ1AsU0FBUztJQUNULHdDQUF3QztJQUN4Qyw2QkFBNkI7SUFDN0Isc0JBQXNCO0lBQ3RCLGtCQUFrQjtJQUNsQixhQUFhO0lBQ2IsVUFBVTtJQUNWLHNCQUFzQjtJQUN0QixTQUFTO0lBQ1QsYUFBYTtJQUNiO0FBQ0o7O0FBRUE7SUFDSSx3Q0FBd0M7QUFDNUM7O0FBRUE7SUFDSSxZQUFZO0lBQ1osOEJBQThCO0lBQzlCLG1CQUFtQjtJQUNuQixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksY0FBYztJQUNkLFdBQVc7SUFDWCxZQUFZO0lBQ1osZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxjQUFjO0lBQ2QsU0FBUztJQUNULEtBQUs7SUFDTCxRQUFRO0lBQ1IsTUFBTTtJQUNOLE9BQU87SUFDUCxrQ0FBa0M7SUFDbEMsNkJBQTZCO0lBQzdCLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLFVBQVU7SUFDVixrQkFBa0I7O0FBRXRCOztBQUVBO0lBQ0ksY0FBYztJQUNkLGdCQUFnQjtJQUNoQixpQkFBaUI7SUFDakI7QUFDSjs7QUFFQTtJQUNJLGlCQUFpQjtJQUNqQixRQUFRO0lBQ1IsZUFBZTtJQUNmLHdCQUF3QjtJQUN4QixjQUFjO0lBQ2QsbUJBQW1CO0lBQ25CLFlBQVk7SUFDWix5QkFBeUI7SUFDekIscURBQXFEO0FBQ3pEOztBQUVBO0lBQ0kseUJBQXlCO0lBQ3pCLHlCQUF5QjtBQUM3Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixzQkFBc0I7SUFDdEIsYUFBYTtJQUNiLGFBQWE7SUFDYixlQUFlO0FBQ25COztBQUVBO0lBQ0ksWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGVBQWU7SUFDZix5QkFBeUI7SUFDekIsY0FBYztJQUNkLG1CQUFtQjtJQUNuQixZQUFZO0lBQ1oseUJBQXlCO0lBQ3pCLGFBQWE7SUFDYixxREFBcUQ7QUFDekQ7O0FBRUE7SUFDSSx3QkFBd0I7QUFDNUI7O0FBRUE7SUFDSTtBQUNKOztBQUVBO0lBQ0k7QUFDSlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIqIHtcXHJcXG4gICAgbWFyZ2luOjA7XFxyXFxuICAgIHBhZGRpbmc6MDtcXHJcXG4gICAgZm9udC1mYW1pbHk6XFxcIk1lcmllbmRhXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbnRhaW5lciB7XFxyXFxuICAgIGRpc3BsYXk6Z3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxNTBweCA1MHB4IDFmcjtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7XFxyXFxuICAgIGdhcDoxZW07XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXIge1xcclxcbiAgICBncmlkLWFyZWE6IDEgLyAxIC8gMiAvIDI7XFxyXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICNiYmM0ZmYsICNjZmQyZmYsICNlMWUwZmYsICNmMWVmZmYsICNmZmZmZmYpO1xcclxcbiAgICBkaXNwbGF5OmZsZXg7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgICBnYXA6IDFlbTtcXHJcXG59XFxyXFxuXFxyXFxuLnRpdGxlX2JhciB7XFxyXFxuICAgIG1hcmdpbjogMjBweDtcXHJcXG4gICAgZm9udC1zaXplOiA0MHB4OyBcXHJcXG4gICAgY29sb3I6ICM1ZTA5MTM7XFxyXFxufVxcclxcblxcclxcbi51c2VyX2luZm8ge1xcclxcbiAgICBkaXNwbGF5OmZsZXg7XFxyXFxuICAgIGFsaWduLWl0ZW1zOmNlbnRlcjtcXHJcXG4gICAgZ2FwOiAxNXB4O1xcclxcbiAgICBtYXJnaW46IDIwcHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXHJcXG4gICAgY29sb3I6IzVlMDkxM1xcclxcbn1cXHJcXG5cXHJcXG4uYXZhdGFyIHtcXHJcXG4gICAgaGVpZ2h0OiA0MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZGhvbGRlciB7XFxyXFxuICAgIGRpc3BsYXk6Z3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoYXV0by1maXQpO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDIwMHB4LCA0MDBweCkpXFxyXFxufVxcclxcblxcclxcbi5jYXJkIHtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxyXFxuICAgIG1hcmdpbi1sZWZ0OjE1cHg7XFxyXFxuICAgIG1hcmdpbi1yaWdodDoxNXB4O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOjE1cHg7XFxyXFxuICAgIHBhZGRpbmc6MTVweDtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBmb250LXNpemU6IDIwcHg7XFxyXFxuICAgIG1hcmdpbi10b3A6MHB4O1xcclxcbiAgICBwYWRkaW5nLXRvcDowcHg7XFxyXFxuICAgIGJveC1zaGFkb3c6IHJnYmEoMTAwLCAxMDAsIDExMSwgMC4yKSAwcHggN3B4IDI5cHggMHB4O1xcclxcbiAgICBib3JkZXI6IzVlMDkxMyAxcHggZG90dGVkXFxyXFxufVxcclxcblxcclxcbi5jYXJkID4gKiB7XFxyXFxuICAgIHBhZGRpbmc6NXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2xvc2UtY2FyZCB7XFxyXFxuICAgIGFsaWduLXNlbGY6ZmxleC1lbmQ7XFxyXFxuICAgIGhlaWdodDoxNXB4XFxyXFxufVxcclxcblxcclxcbi5yZWFkRGl2IHtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBnYXA6IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5tb2RhbCB7XFxyXFxuICAgIHBvc2l0aW9uOmZpeGVkO1xcclxcbiAgICB0b3A6NTAlO1xcclxcbiAgICBsZWZ0OiA1MCU7XFxyXFxuICAgIHRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSkgc2NhbGUoMCk7XFxyXFxuICAgIHRyYW5zaXRpb246IDIwMG1zIGVhc2UtaW4tb3V0O1xcclxcbiAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xcclxcbiAgICBib3JkZXItcmFkaXVzOjEwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDIwcHg7XFxyXFxuICAgIHotaW5kZXg6MTA7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6d2hpdGU7XFxyXFxuICAgIHdpZHRoOjM1JTtcXHJcXG4gICAgbWF4LXdpZHRoOjgwJTtcXHJcXG4gICAgY29sb3I6IzVlMDkxM1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwuYWN0aXZlIHtcXHJcXG4gICAgdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgxKTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWhlYWRlciB7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICBwYWRkaW5nOjIwcHg7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jbG9zZS1idXR0b24ge1xcclxcbiAgICBjdXJzb3I6cG9pbnRlcjtcXHJcXG4gICAgYm9yZGVyOm5vbmU7XFxyXFxuICAgIG91dGxpbmU6bm9uZTtcXHJcXG4gICAgYmFja2dyb3VuZDpub25lO1xcclxcbiAgICBmb250LXNpemU6MS4yNXJlbTtcXHJcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDtcXHJcXG59XFxyXFxuXFxyXFxuI292ZXJsYXkge1xcclxcbiAgICBwb3NpdGlvbjpmaXhlZDtcXHJcXG4gICAgb3BhY2l0eTowO1xcclxcbiAgICB0b3A6MDtcXHJcXG4gICAgYm90dG9tOjA7XFxyXFxuICAgIGxlZnQ6MDtcXHJcXG4gICAgcmlnaHQ6MDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsIDAsIDAsIC41KTtcXHJcXG4gICAgdHJhbnNpdGlvbjogMjAwbXMgZWFzZS1pbi1vdXQ7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOm5vbmU7XFxyXFxufVxcclxcblxcclxcbiNvdmVybGF5LmFjdGl2ZSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOmFsbDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuI2Nsb3NlLWJ1dHRvbiB7XFxyXFxuICAgIGN1cnNvcjpwb2ludGVyO1xcclxcbiAgICBmb250LXdlaWdodDpib2xkO1xcclxcbiAgICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG4gICAgY29sb3I6IzVlMDkxM1xcclxcbn1cXHJcXG5cXHJcXG4jbW9kYWwtYnV0dG9uIHtcXHJcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7XFxyXFxuICAgIGxlZnQ6NDAlO1xcclxcbiAgICBmb250LXNpemU6IDIwcHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2U1ZTlmYztcXHJcXG4gICAgY3Vyc29yOnBvaW50ZXI7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxyXFxuICAgIHBhZGRpbmc6MTJweDtcXHJcXG4gICAgYm9yZGVyOi41cHggc29saWQgIzVlMDkxMztcXHJcXG4gICAgYm94LXNoYWRvdzogcmdiYSgxMDAsIDEwMCwgMTExLCAwLjIpIDBweCA3cHggMjlweCAwcHg7XFxyXFxufVxcclxcblxcclxcbiNtb2RhbC1idXR0b246aG92ZXIge1xcclxcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjNWUwOTEzO1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2JkM2ZmO1xcclxcbn1cXHJcXG5cXHJcXG4jdXNlci1mb3JtIHtcXHJcXG4gICAgYWxpZ24taXRlbXM6Y2VudGVyO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBjb2xvcjojNWUwOTEzO1xcclxcbiAgICBtYXJnaW4tbGVmdDoyNSU7XFxyXFxufVxcclxcblxcclxcbiN1c2VyLWZvcm0gPiAqIHtcXHJcXG4gICAgbWFyZ2luOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4jc3VibWl0IHtcXHJcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2JkM2ZmO1xcclxcbiAgICBjdXJzb3I6cG9pbnRlcjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgcGFkZGluZzoxMHB4O1xcclxcbiAgICBib3JkZXI6LjVweCBzb2xpZCAjNWUwOTEzO1xcclxcbiAgICBjb2xvcjojNWUwOTEzO1xcclxcbiAgICBib3gtc2hhZG93OiByZ2JhKDEwMCwgMTAwLCAxMTEsIDAuMikgMHB4IDdweCAyOXB4IDBweDtcXHJcXG59XFxyXFxuXFxyXFxuI3N1Ym1pdDpob3ZlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2JiYzRmZjsgXFxyXFxufVxcclxcblxcclxcbmlucHV0OmludmFsaWQge1xcclxcbiAgICBib3JkZXI6IzVlMDkxMyAxcHggc29saWRcXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQ6Zm9jdXM6aW52YWxpZCB7XFxyXFxuICAgIGJhY2tncm91bmQ6I2JiYzRmZmEzXFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/styles.css\n");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxNQUErRjtBQUMvRixNQUFxRjtBQUNyRixNQUE0RjtBQUM1RixNQUErRztBQUMvRyxNQUF3RztBQUN4RyxNQUF3RztBQUN4RyxNQUFvRztBQUNwRztBQUNBOztBQUVBOztBQUVBLDRCQUE0QixxR0FBbUI7QUFDL0Msd0JBQXdCLGtIQUFhOztBQUVyQyx1QkFBdUIsdUdBQWE7QUFDcEM7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLHVGQUFPOzs7O0FBSThDO0FBQ3RFLE9BQU8saUVBQWUsdUZBQU8sSUFBSSw4RkFBYyxHQUFHLDhGQUFjLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9zcmMvc3R5bGVzLmNzcz80NGIyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzP2IyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saWJyYXJ5Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzP2RlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakY7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsSUFBSTs7QUFFSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlicmFyeS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlicmFyeS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FirebaseError\": () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   \"SDK_VERSION\": () => (/* binding */ SDK_VERSION),\n/* harmony export */   \"_DEFAULT_ENTRY_NAME\": () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   \"_addComponent\": () => (/* binding */ _addComponent),\n/* harmony export */   \"_addOrOverwriteComponent\": () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   \"_apps\": () => (/* binding */ _apps),\n/* harmony export */   \"_clearComponents\": () => (/* binding */ _clearComponents),\n/* harmony export */   \"_components\": () => (/* binding */ _components),\n/* harmony export */   \"_getProvider\": () => (/* binding */ _getProvider),\n/* harmony export */   \"_registerComponent\": () => (/* binding */ _registerComponent),\n/* harmony export */   \"_removeServiceInstance\": () => (/* binding */ _removeServiceInstance),\n/* harmony export */   \"deleteApp\": () => (/* binding */ deleteApp),\n/* harmony export */   \"getApp\": () => (/* binding */ getApp),\n/* harmony export */   \"getApps\": () => (/* binding */ getApps),\n/* harmony export */   \"initializeApp\": () => (/* binding */ initializeApp),\n/* harmony export */   \"onLog\": () => (/* binding */ onLog),\n/* harmony export */   \"registerVersion\": () => (/* binding */ registerVersion),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.esm2017.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"./node_modules/idb/build/index.js\");\nvar _PLATFORM_LOG_STRING, _ERRORS;\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar PlatformLoggerServiceImpl = /*#__PURE__*/function () {\n  function PlatformLoggerServiceImpl(container) {\n    _classCallCheck(this, PlatformLoggerServiceImpl);\n    this.container = container;\n  }\n  // In initial implementation, this will be called by installations on\n  // auth token refresh, and installations will send this string.\n  _createClass(PlatformLoggerServiceImpl, [{\n    key: \"getPlatformInfoString\",\n    value: function getPlatformInfoString() {\n      var providers = this.container.getProviders();\n      // Loop through providers and get library/version pairs from any that are\n      // version components.\n      return providers.map(function (provider) {\n        if (isVersionServiceProvider(provider)) {\n          var service = provider.getImmediate();\n          return \"\".concat(service.library, \"/\").concat(service.version);\n        } else {\n          return null;\n        }\n      }).filter(function (logString) {\n        return logString;\n      }).join(' ');\n    }\n  }]);\n  return PlatformLoggerServiceImpl;\n}();\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\nfunction isVersionServiceProvider(provider) {\n  var component = provider.getComponent();\n  return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nvar name$o = \"@firebase/app\";\nvar version$1 = \"0.9.0\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\nvar name$n = \"@firebase/app-compat\";\nvar name$m = \"@firebase/analytics-compat\";\nvar name$l = \"@firebase/analytics\";\nvar name$k = \"@firebase/app-check-compat\";\nvar name$j = \"@firebase/app-check\";\nvar name$i = \"@firebase/auth\";\nvar name$h = \"@firebase/auth-compat\";\nvar name$g = \"@firebase/database\";\nvar name$f = \"@firebase/database-compat\";\nvar name$e = \"@firebase/functions\";\nvar name$d = \"@firebase/functions-compat\";\nvar name$c = \"@firebase/installations\";\nvar name$b = \"@firebase/installations-compat\";\nvar name$a = \"@firebase/messaging\";\nvar name$9 = \"@firebase/messaging-compat\";\nvar name$8 = \"@firebase/performance\";\nvar name$7 = \"@firebase/performance-compat\";\nvar name$6 = \"@firebase/remote-config\";\nvar name$5 = \"@firebase/remote-config-compat\";\nvar name$4 = \"@firebase/storage\";\nvar name$3 = \"@firebase/storage-compat\";\nvar name$2 = \"@firebase/firestore\";\nvar name$1 = \"@firebase/firestore-compat\";\nvar name = \"firebase\";\nvar version = \"9.15.0\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * The default app name\r\n *\r\n * @internal\r\n */\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\nvar PLATFORM_LOG_STRING = (_PLATFORM_LOG_STRING = {}, _defineProperty(_PLATFORM_LOG_STRING, name$o, 'fire-core'), _defineProperty(_PLATFORM_LOG_STRING, name$n, 'fire-core-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$l, 'fire-analytics'), _defineProperty(_PLATFORM_LOG_STRING, name$m, 'fire-analytics-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$j, 'fire-app-check'), _defineProperty(_PLATFORM_LOG_STRING, name$k, 'fire-app-check-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$i, 'fire-auth'), _defineProperty(_PLATFORM_LOG_STRING, name$h, 'fire-auth-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$g, 'fire-rtdb'), _defineProperty(_PLATFORM_LOG_STRING, name$f, 'fire-rtdb-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$e, 'fire-fn'), _defineProperty(_PLATFORM_LOG_STRING, name$d, 'fire-fn-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$c, 'fire-iid'), _defineProperty(_PLATFORM_LOG_STRING, name$b, 'fire-iid-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$a, 'fire-fcm'), _defineProperty(_PLATFORM_LOG_STRING, name$9, 'fire-fcm-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$8, 'fire-perf'), _defineProperty(_PLATFORM_LOG_STRING, name$7, 'fire-perf-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$6, 'fire-rc'), _defineProperty(_PLATFORM_LOG_STRING, name$5, 'fire-rc-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$4, 'fire-gcs'), _defineProperty(_PLATFORM_LOG_STRING, name$3, 'fire-gcs-compat'), _defineProperty(_PLATFORM_LOG_STRING, name$2, 'fire-fst'), _defineProperty(_PLATFORM_LOG_STRING, name$1, 'fire-fst-compat'), _defineProperty(_PLATFORM_LOG_STRING, 'fire-js', 'fire-js'), _defineProperty(_PLATFORM_LOG_STRING, name, 'fire-js-all'), _PLATFORM_LOG_STRING);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * @internal\r\n */\nvar _apps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */\nfunction _addComponent(app, component) {\n  try {\n    app.container.addComponent(component);\n  } catch (e) {\n    logger.debug(\"Component \".concat(component.name, \" failed to register with FirebaseApp \").concat(app.name), e);\n  }\n}\n/**\r\n *\r\n * @internal\r\n */\nfunction _addOrOverwriteComponent(app, component) {\n  app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */\nfunction _registerComponent(component) {\n  var componentName = component.name;\n  if (_components.has(componentName)) {\n    logger.debug(\"There were multiple attempts to register component \".concat(componentName, \".\"));\n    return false;\n  }\n  _components.set(componentName, component);\n  // add the component to existing app instances\n  var _iterator = _createForOfIteratorHelper(_apps.values()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var app = _step.value;\n      _addComponent(app, component);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */\nfunction _getProvider(app, name) {\n  var heartbeatController = app.container.getProvider('heartbeat').getImmediate({\n    optional: true\n  });\n  if (heartbeatController) {\n    void heartbeatController.triggerHeartbeat();\n  }\n  return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */\nfunction _removeServiceInstance(app, name) {\n  var instanceIdentifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENTRY_NAME;\n  _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */\nfunction _clearComponents() {\n  _components.clear();\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar ERRORS = (_ERRORS = {}, _defineProperty(_ERRORS, \"no-app\" /* AppError.NO_APP */, \"No Firebase App '{$appName}' has been created - \" + 'call Firebase App.initializeApp()'), _defineProperty(_ERRORS, \"bad-app-name\" /* AppError.BAD_APP_NAME */, \"Illegal App name: '{$appName}\"), _defineProperty(_ERRORS, \"duplicate-app\" /* AppError.DUPLICATE_APP */, \"Firebase App named '{$appName}' already exists with different options or config\"), _defineProperty(_ERRORS, \"app-deleted\" /* AppError.APP_DELETED */, \"Firebase App named '{$appName}' already deleted\"), _defineProperty(_ERRORS, \"no-options\" /* AppError.NO_OPTIONS */, 'Need to provide options, when not being deployed to hosting via source.'), _defineProperty(_ERRORS, \"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */, 'firebase.{$appName}() takes either no argument or a ' + 'Firebase App instance.'), _defineProperty(_ERRORS, \"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */, 'First argument to `onLog` must be null or a function.'), _defineProperty(_ERRORS, \"idb-open\" /* AppError.IDB_OPEN */, 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.'), _defineProperty(_ERRORS, \"idb-get\" /* AppError.IDB_GET */, 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.'), _defineProperty(_ERRORS, \"idb-set\" /* AppError.IDB_WRITE */, 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.'), _defineProperty(_ERRORS, \"idb-delete\" /* AppError.IDB_DELETE */, 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'), _ERRORS);\nvar ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar FirebaseAppImpl = /*#__PURE__*/function () {\n  function FirebaseAppImpl(options, config, container) {\n    var _this = this;\n    _classCallCheck(this, FirebaseAppImpl);\n    this._isDeleted = false;\n    this._options = Object.assign({}, options);\n    this._config = Object.assign({}, config);\n    this._name = config.name;\n    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n    this._container = container;\n    this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', function () {\n      return _this;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */));\n  }\n  _createClass(FirebaseAppImpl, [{\n    key: \"automaticDataCollectionEnabled\",\n    get: function get() {\n      this.checkDestroyed();\n      return this._automaticDataCollectionEnabled;\n    },\n    set: function set(val) {\n      this.checkDestroyed();\n      this._automaticDataCollectionEnabled = val;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      this.checkDestroyed();\n      return this._name;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      this.checkDestroyed();\n      return this._options;\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      this.checkDestroyed();\n      return this._config;\n    }\n  }, {\n    key: \"container\",\n    get: function get() {\n      return this._container;\n    }\n  }, {\n    key: \"isDeleted\",\n    get: function get() {\n      return this._isDeleted;\n    },\n    set: function set(val) {\n      this._isDeleted = val;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\n  }, {\n    key: \"checkDestroyed\",\n    value: function checkDestroyed() {\n      if (this.isDeleted) {\n        throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, {\n          appName: this._name\n        });\n      }\n    }\n  }]);\n  return FirebaseAppImpl;\n}();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */\nvar SDK_VERSION = version;\nfunction initializeApp(_options) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var options = _options;\n  if (_typeof(rawConfig) !== 'object') {\n    var _name = rawConfig;\n    rawConfig = {\n      name: _name\n    };\n  }\n  var config = Object.assign({\n    name: DEFAULT_ENTRY_NAME,\n    automaticDataCollectionEnabled: false\n  }, rawConfig);\n  var name = config.name;\n  if (typeof name !== 'string' || !name) {\n    throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n      appName: String(name)\n    });\n  }\n  options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n  if (!options) {\n    throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n  }\n\n  var existingApp = _apps.get(name);\n  if (existingApp) {\n    // return the existing app if options and config deep equal the ones in the existing app.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n      return existingApp;\n    } else {\n      throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, {\n        appName: name\n      });\n    }\n  }\n  var container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n  var _iterator2 = _createForOfIteratorHelper(_components.values()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var component = _step2.value;\n      container.addComponent(component);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var newApp = new FirebaseAppImpl(options, config, container);\n  _apps.set(name, newApp);\n  return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */\nfunction getApp() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENTRY_NAME;\n  var app = _apps.get(name);\n  if (!app && name === DEFAULT_ENTRY_NAME) {\n    return initializeApp();\n  }\n  if (!app) {\n    throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, {\n      appName: name\n    });\n  }\n  return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */\nfunction getApps() {\n  return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */\nfunction deleteApp(_x) {\n  return _deleteApp.apply(this, arguments);\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */\nfunction _deleteApp() {\n  _deleteApp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(app) {\n    var name;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            name = app.name;\n            if (!_apps.has(name)) {\n              _context7.next = 6;\n              break;\n            }\n            _apps[\"delete\"](name);\n            _context7.next = 5;\n            return Promise.all(app.container.getProviders().map(function (provider) {\n              return provider[\"delete\"]();\n            }));\n          case 5:\n            app.isDeleted = true;\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _deleteApp.apply(this, arguments);\n}\nfunction registerVersion(libraryKeyOrName, version, variant) {\n  var _a;\n  // TODO: We can use this check to whitelist strings when/if we set up\n  // a good whitelist system.\n  var library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n  if (variant) {\n    library += \"-\".concat(variant);\n  }\n  var libraryMismatch = library.match(/\\s|\\//);\n  var versionMismatch = version.match(/\\s|\\//);\n  if (libraryMismatch || versionMismatch) {\n    var warning = [\"Unable to register library \\\"\".concat(library, \"\\\" with version \\\"\").concat(version, \"\\\":\")];\n    if (libraryMismatch) {\n      warning.push(\"library name \\\"\".concat(library, \"\\\" contains illegal characters (whitespace or \\\"/\\\")\"));\n    }\n    if (libraryMismatch && versionMismatch) {\n      warning.push('and');\n    }\n    if (versionMismatch) {\n      warning.push(\"version name \\\"\".concat(version, \"\\\" contains illegal characters (whitespace or \\\"/\\\")\"));\n    }\n    logger.warn(warning.join(' '));\n    return;\n  }\n  _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"\".concat(library, \"-version\"), function () {\n    return {\n      library: library,\n      version: version\n    };\n  }, \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */\nfunction onLog(logCallback, options) {\n  if (logCallback !== null && typeof logCallback !== 'function') {\n    throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n  }\n\n  (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */\nfunction setLogLevel(logLevel) {\n  (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar DB_NAME = 'firebase-heartbeat-database';\nvar DB_VERSION = 1;\nvar STORE_NAME = 'firebase-heartbeat-store';\nvar dbPromise = null;\nfunction getDbPromise() {\n  if (!dbPromise) {\n    dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n      upgrade: function upgrade(db, oldVersion) {\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME);\n        }\n      }\n    })[\"catch\"](function (e) {\n      throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n        originalErrorMessage: e.message\n      });\n    });\n  }\n  return dbPromise;\n}\nfunction readHeartbeatsFromIndexedDB(_x2) {\n  return _readHeartbeatsFromIndexedDB.apply(this, arguments);\n}\nfunction _readHeartbeatsFromIndexedDB() {\n  _readHeartbeatsFromIndexedDB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(app) {\n    var db, idbGetError;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.prev = 0;\n            _context8.next = 3;\n            return getDbPromise();\n          case 3:\n            db = _context8.sent;\n            return _context8.abrupt(\"return\", db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app)));\n          case 7:\n            _context8.prev = 7;\n            _context8.t0 = _context8[\"catch\"](0);\n            if (_context8.t0 instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n              logger.warn(_context8.t0.message);\n            } else {\n              idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: _context8.t0 === null || _context8.t0 === void 0 ? void 0 : _context8.t0.message\n              });\n              logger.warn(idbGetError.message);\n            }\n          case 10:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[0, 7]]);\n  }));\n  return _readHeartbeatsFromIndexedDB.apply(this, arguments);\n}\nfunction writeHeartbeatsToIndexedDB(_x3, _x4) {\n  return _writeHeartbeatsToIndexedDB.apply(this, arguments);\n}\nfunction _writeHeartbeatsToIndexedDB() {\n  _writeHeartbeatsToIndexedDB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(app, heartbeatObject) {\n    var db, tx, objectStore, idbGetError;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.prev = 0;\n            _context9.next = 3;\n            return getDbPromise();\n          case 3:\n            db = _context9.sent;\n            tx = db.transaction(STORE_NAME, 'readwrite');\n            objectStore = tx.objectStore(STORE_NAME);\n            _context9.next = 8;\n            return objectStore.put(heartbeatObject, computeKey(app));\n          case 8:\n            return _context9.abrupt(\"return\", tx.done);\n          case 11:\n            _context9.prev = 11;\n            _context9.t0 = _context9[\"catch\"](0);\n            if (_context9.t0 instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n              logger.warn(_context9.t0.message);\n            } else {\n              idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: _context9.t0 === null || _context9.t0 === void 0 ? void 0 : _context9.t0.message\n              });\n              logger.warn(idbGetError.message);\n            }\n          case 14:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[0, 11]]);\n  }));\n  return _writeHeartbeatsToIndexedDB.apply(this, arguments);\n}\nfunction computeKey(app) {\n  return \"\".concat(app.name, \"!\").concat(app.options.appId);\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar MAX_HEADER_BYTES = 1024;\n// 30 days\nvar STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nvar HeartbeatServiceImpl = /*#__PURE__*/function () {\n  function HeartbeatServiceImpl(container) {\n    var _this2 = this;\n    _classCallCheck(this, HeartbeatServiceImpl);\n    this.container = container;\n    /**\r\n     * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n     * the header string.\r\n     * Stores one record per date. This will be consolidated into the standard\r\n     * format of one record per user agent string before being sent as a header.\r\n     * Populated from indexedDB when the controller is instantiated and should\r\n     * be kept in sync with indexedDB.\r\n     * Leave public for easier testing.\r\n     */\n    this._heartbeatsCache = null;\n    var app = this.container.getProvider('app').getImmediate();\n    this._storage = new HeartbeatStorageImpl(app);\n    this._heartbeatsCachePromise = this._storage.read().then(function (result) {\n      _this2._heartbeatsCache = result;\n      return result;\n    });\n  }\n  /**\r\n   * Called to report a heartbeat. The function will generate\r\n   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n   * to IndexedDB.\r\n   * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n   * already logged, subsequent calls to this function in the same day will be ignored.\r\n   */\n  _createClass(HeartbeatServiceImpl, [{\n    key: \"triggerHeartbeat\",\n    value: function () {\n      var _triggerHeartbeat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var platformLogger, agent, date;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                platformLogger = this.container.getProvider('platform-logger').getImmediate(); // This is the \"Firebase user agent\" string from the platform logger\n                // service, not the browser user agent.\n                agent = platformLogger.getPlatformInfoString();\n                date = getUTCDateString();\n                if (!(this._heartbeatsCache === null)) {\n                  _context.next = 7;\n                  break;\n                }\n                _context.next = 6;\n                return this._heartbeatsCachePromise;\n              case 6:\n                this._heartbeatsCache = _context.sent;\n              case 7:\n                if (!(this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some(function (singleDateHeartbeat) {\n                  return singleDateHeartbeat.date === date;\n                }))) {\n                  _context.next = 11;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 11:\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({\n                  date: date,\n                  agent: agent\n                });\n              case 12:\n                // Remove entries older than 30 days.\n                this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(function (singleDateHeartbeat) {\n                  var hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n                  var now = Date.now();\n                  return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n                });\n                return _context.abrupt(\"return\", this._storage.overwrite(this._heartbeatsCache));\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function triggerHeartbeat() {\n        return _triggerHeartbeat.apply(this, arguments);\n      }\n      return triggerHeartbeat;\n    }()\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */\n  }, {\n    key: \"getHeartbeatsHeader\",\n    value: function () {\n      var _getHeartbeatsHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var date, _extractHeartbeatsFor, heartbeatsToSend, unsentEntries, headerString;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._heartbeatsCache === null)) {\n                  _context2.next = 3;\n                  break;\n                }\n                _context2.next = 3;\n                return this._heartbeatsCachePromise;\n              case 3:\n                if (!(this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)) {\n                  _context2.next = 5;\n                  break;\n                }\n                return _context2.abrupt(\"return\", '');\n              case 5:\n                date = getUTCDateString(); // Extract as many heartbeats from the cache as will fit under the size limit.\n                _extractHeartbeatsFor = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats), heartbeatsToSend = _extractHeartbeatsFor.heartbeatsToSend, unsentEntries = _extractHeartbeatsFor.unsentEntries;\n                headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({\n                  version: 2,\n                  heartbeats: heartbeatsToSend\n                })); // Store last sent date to prevent another being logged/sent for the same day.\n                this._heartbeatsCache.lastSentHeartbeatDate = date;\n                if (!(unsentEntries.length > 0)) {\n                  _context2.next = 15;\n                  break;\n                }\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                _context2.next = 13;\n                return this._storage.overwrite(this._heartbeatsCache);\n              case 13:\n                _context2.next = 17;\n                break;\n              case 15:\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n              case 17:\n                return _context2.abrupt(\"return\", headerString);\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function getHeartbeatsHeader() {\n        return _getHeartbeatsHeader.apply(this, arguments);\n      }\n      return getHeartbeatsHeader;\n    }()\n  }]);\n  return HeartbeatServiceImpl;\n}();\nfunction getUTCDateString() {\n  var today = new Date();\n  // Returns date format 'YYYY-MM-DD'\n  return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache) {\n  var maxSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_HEADER_BYTES;\n  // Heartbeats grouped by user agent in the standard format to be sent in\n  // the header.\n  var heartbeatsToSend = [];\n  // Single date format heartbeats that are not sent.\n  var unsentEntries = heartbeatsCache.slice();\n  var _iterator3 = _createForOfIteratorHelper(heartbeatsCache),\n    _step3;\n  try {\n    var _loop = function _loop() {\n      var singleDateHeartbeat = _step3.value;\n      // Look for an existing entry with the same user agent.\n      var heartbeatEntry = heartbeatsToSend.find(function (hb) {\n        return hb.agent === singleDateHeartbeat.agent;\n      });\n      if (!heartbeatEntry) {\n        // If no entry for this user agent exists, create one.\n        heartbeatsToSend.push({\n          agent: singleDateHeartbeat.agent,\n          dates: [singleDateHeartbeat.date]\n        });\n        if (countBytes(heartbeatsToSend) > maxSize) {\n          // If the header would exceed max size, remove the added heartbeat\n          // entry and stop adding to the header.\n          heartbeatsToSend.pop();\n          return \"break\";\n        }\n      } else {\n        heartbeatEntry.dates.push(singleDateHeartbeat.date);\n        // If the header would exceed max size, remove the added date\n        // and stop adding to the header.\n        if (countBytes(heartbeatsToSend) > maxSize) {\n          heartbeatEntry.dates.pop();\n          return \"break\";\n        }\n      }\n      // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n      // quota and the loop breaks early.)\n      unsentEntries = unsentEntries.slice(1);\n    };\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ret = _loop();\n      if (_ret === \"break\") break;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return {\n    heartbeatsToSend: heartbeatsToSend,\n    unsentEntries: unsentEntries\n  };\n}\nvar HeartbeatStorageImpl = /*#__PURE__*/function () {\n  function HeartbeatStorageImpl(app) {\n    _classCallCheck(this, HeartbeatStorageImpl);\n    this.app = app;\n    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n  }\n  _createClass(HeartbeatStorageImpl, [{\n    key: \"runIndexedDBEnvironmentCheck\",\n    value: function () {\n      var _runIndexedDBEnvironmentCheck = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n                  _context3.next = 4;\n                  break;\n                }\n                return _context3.abrupt(\"return\", false);\n              case 4:\n                return _context3.abrupt(\"return\", (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)().then(function () {\n                  return true;\n                })[\"catch\"](function () {\n                  return false;\n                }));\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function runIndexedDBEnvironmentCheck() {\n        return _runIndexedDBEnvironmentCheck.apply(this, arguments);\n      }\n      return runIndexedDBEnvironmentCheck;\n    }()\n    /**\r\n     * Read all heartbeats.\r\n     */\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var canUseIndexedDB, idbHeartbeatObject;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._canUseIndexedDBPromise;\n              case 2:\n                canUseIndexedDB = _context4.sent;\n                if (canUseIndexedDB) {\n                  _context4.next = 7;\n                  break;\n                }\n                return _context4.abrupt(\"return\", {\n                  heartbeats: []\n                });\n              case 7:\n                _context4.next = 9;\n                return readHeartbeatsFromIndexedDB(this.app);\n              case 9:\n                idbHeartbeatObject = _context4.sent;\n                return _context4.abrupt(\"return\", idbHeartbeatObject || {\n                  heartbeats: []\n                });\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function read() {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }() // overwrite the storage with the provided heartbeats\n  }, {\n    key: \"overwrite\",\n    value: function () {\n      var _overwrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(heartbeatsObject) {\n        var _a, canUseIndexedDB, existingHeartbeatsObject;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._canUseIndexedDBPromise;\n              case 2:\n                canUseIndexedDB = _context5.sent;\n                if (canUseIndexedDB) {\n                  _context5.next = 7;\n                  break;\n                }\n                return _context5.abrupt(\"return\");\n              case 7:\n                _context5.next = 9;\n                return this.read();\n              case 9:\n                existingHeartbeatsObject = _context5.sent;\n                return _context5.abrupt(\"return\", writeHeartbeatsToIndexedDB(this.app, {\n                  lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                  heartbeats: heartbeatsObject.heartbeats\n                }));\n              case 11:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function overwrite(_x5) {\n        return _overwrite.apply(this, arguments);\n      }\n      return overwrite;\n    }() // add heartbeats\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(heartbeatsObject) {\n        var _a, canUseIndexedDB, existingHeartbeatsObject;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._canUseIndexedDBPromise;\n              case 2:\n                canUseIndexedDB = _context6.sent;\n                if (canUseIndexedDB) {\n                  _context6.next = 7;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 7:\n                _context6.next = 9;\n                return this.read();\n              case 9:\n                existingHeartbeatsObject = _context6.sent;\n                return _context6.abrupt(\"return\", writeHeartbeatsToIndexedDB(this.app, {\n                  lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                  heartbeats: [].concat(_toConsumableArray(existingHeartbeatsObject.heartbeats), _toConsumableArray(heartbeatsObject.heartbeats))\n                }));\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function add(_x6) {\n        return _add.apply(this, arguments);\n      }\n      return add;\n    }()\n  }]);\n  return HeartbeatStorageImpl;\n}();\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */\nfunction countBytes(heartbeatsCache) {\n  // base64 has a restricted set of characters, all of which should be 1 byte.\n  return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\n  // heartbeatsCache wrapper properties\n  JSON.stringify({\n    version: 2,\n    heartbeats: heartbeatsCache\n  })).length;\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction registerCoreComponents(variant) {\n  _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', function (container) {\n    return new PlatformLoggerServiceImpl(container);\n  }, \"PRIVATE\" /* ComponentType.PRIVATE */));\n  _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', function (container) {\n    return new HeartbeatServiceImpl(container);\n  }, \"PRIVATE\" /* ComponentType.PRIVATE */));\n  // Register `app` package.\n  registerVersion(name$o, version$1, variant);\n  // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n  registerVersion(name$o, version$1, 'esm2017');\n  // Register platform SDK identifier (no version).\n  registerVersion('fire-js', '');\n}\n\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */\nregisterCoreComponents('');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUc7QUFmSCxJQXlCYUEseUJBQXlCO0VBQ3BDLG1DQUE2QkMsU0FBNkI7SUFBQTtJQUE3QixJQUFTLGFBQVRBLFNBQVM7Ozs7OztXQUd0QyxpQ0FBcUI7TUFDbkIsSUFBTUMsU0FBUyxHQUFHLElBQUksQ0FBQ0QsU0FBUyxDQUFDRSxZQUFZLEVBQUU7OztNQUcvQyxPQUFPRCxTQUFTLENBQ2JFLEdBQUcsQ0FBQyxrQkFBUSxFQUFHO1FBQ2QsSUFBSUMsd0JBQXdCLENBQUNDLFFBQVEsQ0FBQyxFQUFFO1VBQ3RDLElBQU1DLE9BQU8sR0FBR0QsUUFBUSxDQUFDRSxZQUFZLEVBQW9CO1VBQ3pELGlCQUFVRCxPQUFPLENBQUNFLE9BQU8sY0FBSUYsT0FBTyxDQUFDRyxPQUFPO1FBQzdDLE9BQU07VUFDTCxPQUFPLElBQUk7UUFDWjtNQUNILENBQUMsQ0FBQyxDQUNEQyxNQUFNLENBQUMsbUJBQVM7UUFBQSxPQUFJQyxTQUFTO01BQUEsRUFBQyxDQUM5QkMsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7RUFDYjtFQUFBO0FBQUE7QUFFSDs7Ozs7OztBQU9HO0FBQ0gsU0FBU1Isd0JBQXdCLENBQUNDLFFBQXdCO0VBQ3hELElBQU1RLFNBQVMsR0FBR1IsUUFBUSxDQUFDUyxZQUFZLEVBQUU7RUFDekMsT0FBTyxVQUFTLEtBQVQsaUJBQVMsdUJBQVRELFNBQVMsQ0FBRUUsSUFBSTtBQUN4Qjs7Ozs7QUN6REE7Ozs7Ozs7Ozs7Ozs7OztBQWVHO0FBSUksSUFBTUMsTUFBTSxHQUFHLElBQUlDLG9EQUFNLENBQUMsZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQmpEOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQTRCSDs7OztBQUlHO0FBQ0ksSUFBTUMsa0JBQWtCLEdBQUc7QUFFM0IsSUFBTUMsbUJBQW1CLHFFQUM3QkMsTUFBTyxFQUFHLFdBQVcseUNBQ3JCQyxNQUFhLEVBQUcsa0JBQWtCLHlDQUNsQ0MsTUFBYSxFQUFHLGdCQUFnQix5Q0FDaENDLE1BQW1CLEVBQUcsdUJBQXVCLHlDQUM3Q0MsTUFBWSxFQUFHLGdCQUFnQix5Q0FDL0JDLE1BQWtCLEVBQUcsdUJBQXVCLHlDQUM1Q0MsTUFBUSxFQUFHLFdBQVcseUNBQ3RCQyxNQUFjLEVBQUcsa0JBQWtCLHlDQUNuQ0MsTUFBWSxFQUFHLFdBQVcseUNBQzFCQyxNQUFrQixFQUFHLGtCQUFrQix5Q0FDdkNDLE1BQWEsRUFBRyxTQUFTLHlDQUN6QkMsTUFBbUIsRUFBRyxnQkFBZ0IseUNBQ3RDQyxNQUFpQixFQUFHLFVBQVUseUNBQzlCQyxNQUF1QixFQUFHLGlCQUFpQix5Q0FDM0NDLE1BQWEsRUFBRyxVQUFVLHlDQUMxQkMsTUFBbUIsRUFBRyxpQkFBaUIseUNBQ3ZDQyxNQUFlLEVBQUcsV0FBVyx5Q0FDN0JDLE1BQXFCLEVBQUcsa0JBQWtCLHlDQUMxQ0MsTUFBZ0IsRUFBRyxTQUFTLHlDQUM1QkMsTUFBc0IsRUFBRyxnQkFBZ0IseUNBQ3pDQyxNQUFXLEVBQUcsVUFBVSx5Q0FDeEJDLE1BQWlCLEVBQUcsaUJBQWlCLHlDQUNyQ0MsTUFBYSxFQUFHLFVBQVUseUNBQzFCQyxNQUFtQixFQUFHLGlCQUFpQix5Q0FDeEMsU0FBUyxFQUFFLFNBQVMseUNBQ25CQyxJQUFXLEVBQUcsYUFBYSx3QkFDcEI7O0FDN0VWOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQVFIOztBQUVHO0FBQ1UsU0FBSyxHQUFHLElBQUlDLEdBQUc7QUFFNUI7Ozs7QUFJRztBQUNIO0FBQ2EsZUFBVyxHQUFHLElBQUlBLEdBQUc7QUFFbEM7Ozs7QUFJRztBQUNhLHNCQUFhLENBQzNCQyxHQUFnQixFQUNoQmpDLFNBQXVCO0VBRXZCLElBQUk7SUFDRGlDLEdBQXVCLENBQUM5QyxTQUFTLENBQUMrQyxZQUFZLENBQUNsQyxTQUFTLENBQUM7RUFDM0QsRUFBQyxPQUFPbUMsQ0FBQyxFQUFFO0lBQ1ZoQyxNQUFNLENBQUNpQyxLQUFLLHFCQUNHcEMsU0FBUyxDQUFDcUMsSUFBSSxrREFBd0NKLEdBQUcsQ0FBQ0ksSUFBSSxHQUMzRUYsQ0FBQyxDQUNGO0VBQ0Y7QUFDSDtBQUVBOzs7QUFHRztBQUNhLGlDQUF3QixDQUN0Q0YsR0FBZ0IsRUFDaEJqQyxTQUFvQjtFQUVuQmlDLEdBQXVCLENBQUM5QyxTQUFTLENBQUNtRCx1QkFBdUIsQ0FBQ3RDLFNBQVMsQ0FBQztBQUN2RTtBQUVBOzs7Ozs7QUFNRztBQUNHLFNBQVV1QyxrQkFBa0IsQ0FDaEN2QyxTQUF1QjtFQUV2QixJQUFNd0MsYUFBYSxHQUFHeEMsU0FBUyxDQUFDcUMsSUFBSTtFQUNwQyxJQUFJSSxXQUFXLENBQUNDLEdBQUcsQ0FBQ0YsYUFBYSxDQUFDLEVBQUU7SUFDbENyQyxNQUFNLENBQUNpQyxLQUFLLDhEQUM0Q0ksYUFBYSxPQUNwRTtJQUVELE9BQU8sS0FBSztFQUNiO0VBRURDLFdBQVcsQ0FBQ0UsR0FBRyxDQUFDSCxhQUFhLEVBQUV4QyxTQUFTLENBQUM7OzZDQUd2QjRDLEtBQUssQ0FBQ0MsTUFBTSxFQUFFO0lBQUE7RUFBQTtJQUFoQyxvREFBa0M7TUFBQSxJQUF2QlosR0FBRztNQUNaYSxhQUFhLENBQUNiLEdBQXNCLEVBQUVqQyxTQUFTLENBQUM7SUFDakQ7RUFBQTtJQUFBO0VBQUE7SUFBQTtFQUFBO0VBRUQsT0FBTyxJQUFJO0FBQ2I7QUFFQTs7Ozs7Ozs7QUFRRztBQUNhLHFCQUFZLENBQzFCaUMsR0FBZ0IsRUFDaEJJLElBQU87RUFFUCxJQUFNVSxtQkFBbUIsR0FBSWQsR0FBdUIsQ0FBQzlDLFNBQVMsQ0FDM0Q2RCxXQUFXLENBQUMsV0FBVyxDQUFDLENBQ3hCdEQsWUFBWSxDQUFDO0lBQUV1RCxRQUFRLEVBQUU7RUFBSSxDQUFFLENBQUM7RUFDbkMsSUFBSUYsbUJBQW1CLEVBQUU7SUFDdkIsS0FBS0EsbUJBQW1CLENBQUNHLGdCQUFnQixFQUFFO0VBQzVDO0VBQ0QsT0FBUWpCLEdBQXVCLENBQUM5QyxTQUFTLENBQUM2RCxXQUFXLENBQUNYLElBQUksQ0FBQztBQUM3RDtBQUVBOzs7Ozs7O0FBT0c7QUFDRyxTQUFVYyxzQkFBc0IsQ0FDcENsQixHQUFnQixFQUNoQkksSUFBTyxFQUN3QztFQUFBLElBQS9DZSx5RkFBNkIvQyxrQkFBa0I7RUFFL0NnRCxZQUFZLENBQUNwQixHQUFHLEVBQUVJLElBQUksQ0FBQyxDQUFDaUIsYUFBYSxDQUFDRixrQkFBa0IsQ0FBQztBQUMzRDtBQUVBOzs7O0FBSUc7U0FDYUcsZ0JBQWdCO0VBQzlCZCxXQUFXLENBQUNlLEtBQUssRUFBRTtBQUNyQjs7QUM1SUE7Ozs7Ozs7Ozs7Ozs7OztBQWVHO0FBa0JILElBQU1DLE1BQU0sMkNBQ1YsZ0NBQ0Usa0RBQWtELEdBQ2xELG1DQUFtQyw0QkFDckMsNENBQXlCLCtCQUErQiw0QkFDeEQsOENBQ0UsaUZBQWlGLDRCQUNuRiwwQ0FBd0IsaURBQWlELDRCQUN6RSx3Q0FDRSx5RUFBeUUsNEJBQzNFLDREQUNFLHNEQUFzRCxHQUN0RCx3QkFBd0IsNEJBQzFCLDREQUNFLHVEQUF1RCw0QkFDekQsb0NBQ0UsK0VBQStFLDRCQUNqRixrQ0FDRSxvRkFBb0YsNEJBQ3RGLG9DQUNFLGtGQUFrRiw0QkFDcEYsd0NBQ0UscUZBQXFGLFdBQ3hGO0FBY00sSUFBTUMsYUFBYSxHQUFHLElBQUlDLHdEQUFZLENBQzNDLEtBQUssRUFDTCxVQUFVLEVBQ1ZGLE1BQU0sQ0FDUDs7QUMxRUQ7Ozs7Ozs7Ozs7Ozs7OztBQWVHO0FBZkgsSUE2QmFHLGVBQWU7RUFjMUIseUJBQ0VDLE9BQXdCLEVBQ3hCQyxNQUFxQyxFQUNyQzNFLFNBQTZCO0lBQUE7SUFBQTtJQU52QixJQUFVLGNBQUcsS0FBSztJQVF4QixJQUFJLENBQUM0RSxRQUFRLEdBQVFDLHlCQUFPLENBQUU7SUFDOUIsSUFBSSxDQUFDQyxPQUFPLEdBQVFELHdCQUFNLENBQUU7SUFDNUIsSUFBSSxDQUFDRSxLQUFLLEdBQUdKLE1BQU0sQ0FBQ3pCLElBQUk7SUFDeEIsSUFBSSxDQUFDOEIsK0JBQStCLEdBQ2xDTCxNQUFNLENBQUNNLDhCQUE4QjtJQUN2QyxJQUFJLENBQUNDLFVBQVUsR0FBR2xGLFNBQVM7SUFDM0IsSUFBSSxDQUFDQSxTQUFTLENBQUMrQyxZQUFZLENBQ3pCLElBQUlvQywwREFBUyxDQUFDLEtBQUssRUFBRTtNQUFBLE9BQU0sS0FBSTtJQUFBLHVDQUF1QixDQUN2RDs7RUFDRjtJQUFBO0lBQUEsS0FFRCxlQUFrQztNQUNoQyxJQUFJLENBQUNDLGNBQWMsRUFBRTtNQUNyQixPQUFPLElBQUksQ0FBQ0osK0JBQStCO0tBQzVDO0lBQUEsS0FFRCxhQUFtQ0ssR0FBWTtNQUM3QyxJQUFJLENBQUNELGNBQWMsRUFBRTtNQUNyQixJQUFJLENBQUNKLCtCQUErQixHQUFHSyxHQUFHOztFQUMzQztJQUFBO0lBQUEsS0FFRCxlQUFRO01BQ04sSUFBSSxDQUFDRCxjQUFjLEVBQUU7TUFDckIsT0FBTyxJQUFJLENBQUNMLEtBQUs7O0VBQ2xCO0lBQUE7SUFBQSxLQUVELGVBQVc7TUFDVCxJQUFJLENBQUNLLGNBQWMsRUFBRTtNQUNyQixPQUFPLElBQUksQ0FBQ1IsUUFBUTs7RUFDckI7SUFBQTtJQUFBLEtBRUQsZUFBVTtNQUNSLElBQUksQ0FBQ1EsY0FBYyxFQUFFO01BQ3JCLE9BQU8sSUFBSSxDQUFDTixPQUFPOztFQUNwQjtJQUFBO0lBQUEsS0FFRCxlQUFhO01BQ1gsT0FBTyxJQUFJLENBQUNJLFVBQVU7O0VBQ3ZCO0lBQUE7SUFBQSxLQUVELGVBQWE7TUFDWCxPQUFPLElBQUksQ0FBQ0ksVUFBVTtLQUN2QjtJQUFBLEtBRUQsYUFBY0QsR0FBWTtNQUN4QixJQUFJLENBQUNDLFVBQVUsR0FBR0QsR0FBRzs7SUFHdkI7OztBQUdHO0VBSEg7SUFBQTtJQUFBLE9BSVEsMEJBQWM7TUFDcEIsSUFBSSxJQUFJLENBQUNFLFNBQVMsRUFBRTtRQUNsQixNQUFNaEIsYUFBYSxDQUFDaUIsTUFBTSwyQ0FBdUI7VUFBRXBFLE9BQU8sRUFBRSxJQUFJLENBQUMyRDtRQUFLLENBQUUsQ0FBQztNQUMxRTs7RUFDRjtFQUFBO0FBQUE7QUN4R0g7Ozs7Ozs7Ozs7Ozs7OztBQWVHO0FBOEJIOzs7O0FBSUc7QUFDSSxJQUFNVSxXQUFXLEdBQUdoRjtTQW9FWGlGLGFBQWEsQ0FDM0JkLFFBQTBCLEVBQ1o7RUFBQSxJQUFkZSxTQUFTLHVFQUFHLEVBQUU7RUFFZCxJQUFJakIsT0FBTyxHQUFHRSxRQUFRO0VBRXRCLElBQUksUUFBT2UsU0FBUyxNQUFLLFFBQVEsRUFBRTtJQUNqQyxJQUFNekMsS0FBSSxHQUFHeUMsU0FBUztJQUN0QkEsU0FBUyxHQUFHO01BQUV6QyxJQUFJLEVBQUpBO0lBQUksQ0FBRTtFQUNyQjtFQUVELElBQU15QixNQUFNO0lBQ1Z6QixJQUFJLEVBQUVoQyxrQkFBa0I7SUFDeEIrRCw4QkFBOEIsRUFBRTtFQUFLLEdBQ2xDVSxTQUFTLENBQ2I7RUFDRCxJQUFNekMsSUFBSSxHQUFHeUIsTUFBTSxDQUFDekIsSUFBSTtFQUV4QixJQUFJLE9BQU9BLElBQUksS0FBSyxRQUFRLElBQUksQ0FBQ0EsSUFBSSxFQUFFO0lBQ3JDLE1BQU1xQixhQUFhLENBQUNpQixNQUFNLENBQXdCO01BQ2hEcEUsT0FBTyxFQUFFd0UsTUFBTSxDQUFDMUMsSUFBSTtJQUNyQixFQUFDO0VBQ0g7RUFFRHdCLE9BQU8sS0FBUEEsT0FBTyxHQUFLbUIsbUVBQW1CLEVBQUUsQ0FBQztFQUVsQyxJQUFJLENBQUNuQixPQUFPLEVBQUU7SUFDWixNQUFNSCxhQUFhLENBQUNpQixNQUFNLHdDQUFxQjtFQUNoRDs7RUFFRCxJQUFNTSxXQUFXLEdBQUdyQyxLQUFLLENBQUNzQyxHQUFHLENBQUM3QyxJQUFJLENBQW9CO0VBQ3RELElBQUk0QyxXQUFXLEVBQUU7O0lBRWYsSUFDRUUseURBQVMsQ0FBQ3RCLE9BQU8sRUFBRW9CLFdBQVcsQ0FBQ3BCLE9BQU8sQ0FBQyxJQUN2Q3NCLHlEQUFTLENBQUNyQixNQUFNLEVBQUVtQixXQUFXLENBQUNuQixNQUFNLENBQUMsRUFDckM7TUFDQSxPQUFPbUIsV0FBVztJQUNuQixPQUFNO01BQ0wsTUFBTXZCLGFBQWEsQ0FBQ2lCLE1BQU0sQ0FBeUI7UUFBRXBFLE9BQU8sRUFBRThCO01BQUksQ0FBRSxDQUFDO0lBQ3RFO0VBQ0Y7RUFFRCxJQUFNbEQsU0FBUyxHQUFHLElBQUlpRyxtRUFBa0IsQ0FBQy9DLElBQUksQ0FBQztFQUFDLDRDQUN2QkksV0FBVyxDQUFDSSxNQUFNLEVBQUU7SUFBQTtFQUFBO0lBQTVDLHVEQUE4QztNQUFBLElBQW5DN0MsU0FBUztNQUNsQmIsU0FBUyxDQUFDK0MsWUFBWSxDQUFDbEMsU0FBUyxDQUFDO0lBQ2xDO0VBQUE7SUFBQTtFQUFBO0lBQUE7RUFBQTtFQUVELElBQU1xRixNQUFNLEdBQUcsSUFBSXpCLGVBQWUsQ0FBQ0MsT0FBTyxFQUFFQyxNQUFNLEVBQUUzRSxTQUFTLENBQUM7RUFFOUR5RCxLQUFLLENBQUNELEdBQUcsQ0FBQ04sSUFBSSxFQUFFZ0QsTUFBTSxDQUFDO0VBRXZCLE9BQU9BLE1BQU07QUFDZjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJHO0FBQ2EsZUFBTSxHQUFrQztFQUFBLElBQWpDaEQsMkVBQWVoQyxrQkFBa0I7RUFDdEQsSUFBTTRCLEdBQUcsR0FBR1csS0FBSyxDQUFDc0MsR0FBRyxDQUFDN0MsSUFBSSxDQUFDO0VBQzNCLElBQUksQ0FBQ0osR0FBRyxJQUFJSSxJQUFJLEtBQUtoQyxrQkFBa0IsRUFBRTtJQUN2QyxPQUFPd0UsYUFBYSxFQUFFO0VBQ3ZCO0VBQ0QsSUFBSSxDQUFDNUMsR0FBRyxFQUFFO0lBQ1IsTUFBTXlCLGFBQWEsQ0FBQ2lCLE1BQU0sQ0FBa0I7TUFBRXBFLE9BQU8sRUFBRThCO0lBQUksQ0FBRSxDQUFDO0VBQy9EO0VBRUQsT0FBT0osR0FBRztBQUNaO0FBRUE7OztBQUdHO1NBQ2FxRCxPQUFPO0VBQ3JCLE9BQU9DLEtBQUssQ0FBQ0MsSUFBSSxDQUFDNUMsS0FBSyxDQUFDQyxNQUFNLEVBQUUsQ0FBQztBQUNuQztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JHO0FBaEJILFNBaUJzQjRDLFNBQVM7RUFBQTtBQUFBO0FBYS9COzs7Ozs7O0FBT0c7QUFQSDtFQUFBLHdFQWJPLGtCQUF5QnhELEdBQWdCO0lBQUE7SUFBQTtNQUFBO1FBQUE7VUFBQTtZQUN4Q0ksSUFBSSxHQUFHSixHQUFHLENBQUNJLElBQUk7WUFBQSxLQUNqQk8sS0FBSyxDQUFDRixHQUFHLENBQUNMLElBQUksQ0FBQztjQUFBO2NBQUE7WUFBQTtZQUNqQk8sS0FBSyxVQUFPLENBQUNQLElBQUksQ0FBQztZQUFDO1lBQUEsT0FDYnFELE9BQU8sQ0FBQ0MsR0FBRyxDQUNkMUQsR0FBdUIsQ0FBQzlDLFNBQVMsQ0FDL0JFLFlBQVksRUFBRSxDQUNkQyxHQUFHLENBQUMsa0JBQVE7Y0FBQSxPQUFJRSxRQUFRLFVBQU8sRUFBRTtZQUFBLEVBQUMsQ0FDdEM7VUFBQTtZQUNBeUMsR0FBdUIsQ0FBQ3lDLFNBQVMsR0FBRyxJQUFJO1VBQUM7VUFBQTtZQUFBO1FBQUE7TUFBQTtJQUFBO0VBQUEsQ0FFN0M7RUFBQTtBQUFBO1NBVWVrQixlQUFlLENBQzdCQyxnQkFBd0IsRUFDeEJqRyxPQUFlLEVBQ2ZrRyxPQUFnQjs7OztFQUloQixJQUFJbkcsT0FBTyxHQUFHLHlCQUFtQixDQUFDa0csZ0JBQWdCLENBQUMsTUFBSSw2Q0FBZ0I7RUFDdkUsSUFBSUMsT0FBTyxFQUFFO0lBQ1huRyxPQUFPLGVBQVFtRyxPQUFPLENBQUU7RUFDekI7RUFDRCxJQUFNQyxlQUFlLEdBQUdwRyxPQUFPLENBQUNxRyxLQUFLLENBQUMsT0FBTyxDQUFDO0VBQzlDLElBQU1DLGVBQWUsR0FBR3JHLE9BQU8sQ0FBQ29HLEtBQUssQ0FBQyxPQUFPLENBQUM7RUFDOUMsSUFBSUQsZUFBZSxJQUFJRSxlQUFlLEVBQUU7SUFDdEMsSUFBTUMsT0FBTyxHQUFHLHdDQUNpQnZHLE9BQU8sK0JBQW1CQyxPQUFPLFNBQ2pFO0lBQ0QsSUFBSW1HLGVBQWUsRUFBRTtNQUNuQkcsT0FBTyxDQUFDQyxJQUFJLDBCQUNPeEcsT0FBTywwREFDekI7SUFDRjtJQUNELElBQUlvRyxlQUFlLElBQUlFLGVBQWUsRUFBRTtNQUN0Q0MsT0FBTyxDQUFDQyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCO0lBQ0QsSUFBSUYsZUFBZSxFQUFFO01BQ25CQyxPQUFPLENBQUNDLElBQUksMEJBQ092RyxPQUFPLDBEQUN6QjtJQUNGO0lBQ0RPLE1BQU0sQ0FBQ2lHLElBQUksQ0FBQ0YsT0FBTyxDQUFDbkcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCO0VBQ0Q7RUFDRHdDLGtCQUFrQixDQUNoQixJQUFJK0IsMERBQVMsV0FDUjNFLE9BQU8sZUFDVjtJQUFBLE9BQU87TUFBRUEsT0FBTyxFQUFQQSxPQUFPO01BQUVDLE9BQU8sRUFBUEE7SUFBTyxDQUFFO0VBQUEsQ0FBQyx3Q0FFN0IsQ0FDRjtBQUNIO0FBRUE7Ozs7OztBQU1HO0FBQ2EsY0FBSyxDQUNuQnlHLFdBQStCLEVBQy9CeEMsT0FBb0I7RUFFcEIsSUFBSXdDLFdBQVcsS0FBSyxJQUFJLElBQUksT0FBT0EsV0FBVyxLQUFLLFVBQVUsRUFBRTtJQUM3RCxNQUFNM0MsYUFBYSxDQUFDaUIsTUFBTSw0REFBK0I7RUFDMUQ7O0VBQ0QyQixtRUFBaUIsQ0FBQ0QsV0FBVyxFQUFFeEMsT0FBTyxDQUFDO0FBQ3pDO0FBRUE7Ozs7Ozs7O0FBUUc7QUFDRyxTQUFVMEMsV0FBVyxDQUFDQyxRQUF3QjtFQUNsREMsNkRBQWUsQ0FBQ0QsUUFBUSxDQUFDO0FBQzNCOztBQzFVQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUc7QUFTSCxJQUFNRSxPQUFPLEdBQUcsNkJBQTZCO0FBQzdDLElBQU1DLFVBQVUsR0FBRyxDQUFDO0FBQ3BCLElBQU1DLFVBQVUsR0FBRywwQkFBMEI7QUFTN0MsSUFBSUMsU0FBUyxHQUF3QyxJQUFJO0FBQ3pELFNBQVNDLFlBQVk7RUFDbkIsSUFBSSxDQUFDRCxTQUFTLEVBQUU7SUFDZEEsU0FBUyxHQUFHRSwyQ0FBTSxDQUFRTCxPQUFPLEVBQUVDLFVBQVUsRUFBRTtNQUM3Q0ssT0FBTyxFQUFFLGlCQUFDQyxFQUFFLEVBQUVDLFVBQVUsRUFBSTs7Ozs7O1FBTTFCLFFBQVFBLFVBQVU7VUFDaEIsS0FBSyxDQUFDO1lBQ0pELEVBQUUsQ0FBQ0UsaUJBQWlCLENBQUNQLFVBQVUsQ0FBQztRQUFDOztJQUd4QyxFQUFDLFNBQU0sQ0FBQyxXQUFDLEVBQUc7TUFDWCxNQUFNbEQsYUFBYSxDQUFDaUIsTUFBTSxDQUFvQjtRQUM1Q3lDLG9CQUFvQixFQUFFakYsQ0FBQyxDQUFDa0Y7TUFDekIsRUFBQztJQUNKLENBQUMsQ0FBQztFQUNIO0VBQ0QsT0FBT1IsU0FBUztBQUNsQjtBQUFDLFNBRXFCUywyQkFBMkI7RUFBQTtBQUFBO0FBQUE7RUFBQSwwRkFBMUMsa0JBQ0xyRixHQUFnQjtJQUFBO0lBQUE7TUFBQTtRQUFBO1VBQUE7WUFBQTtZQUFBO1lBQUEsT0FHRzZFLFlBQVksRUFBRTtVQUFBO1lBQXpCRyxFQUFFO1lBQUEsa0NBQ0RBLEVBQUUsQ0FDTk0sV0FBVyxDQUFDWCxVQUFVLENBQUMsQ0FDdkJZLFdBQVcsQ0FBQ1osVUFBVSxDQUFDLENBQ3ZCMUIsR0FBRyxDQUFDdUMsVUFBVSxDQUFDeEYsR0FBRyxDQUFDLENBQStDO1VBQUE7WUFBQTtZQUFBO1lBRXJFLElBQUksd0JBQWF5Rix5REFBYSxFQUFFO2NBQzlCdkgsTUFBTSxDQUFDaUcsSUFBSSxDQUFDLGFBQUVpQixPQUFPLENBQUM7WUFDdkIsT0FBTTtjQUNDTSxXQUFXLEdBQUdqRSxhQUFhLENBQUNpQixNQUFNLENBQW1CO2dCQUN6RHlDLG9CQUFvQixFQUFHLGlCQUFXLFFBQVgsZ0RBQWFDO2NBQ3JDLEVBQUM7Y0FDRmxILE1BQU0sQ0FBQ2lHLElBQUksQ0FBQ3VCLFdBQVcsQ0FBQ04sT0FBTyxDQUFDO1lBQ2pDO1VBQUE7VUFBQTtZQUFBO1FBQUE7TUFBQTtJQUFBO0VBQUEsQ0FFSjtFQUFBO0FBQUE7QUFBQSxTQUVxQk8sMEJBQTBCO0VBQUE7QUFBQTtBQUFBO0VBQUEseUZBQXpDLGtCQUNMM0YsR0FBZ0IsRUFDaEI0RixlQUFzQztJQUFBO0lBQUE7TUFBQTtRQUFBO1VBQUE7WUFBQTtZQUFBO1lBQUEsT0FHbkJmLFlBQVksRUFBRTtVQUFBO1lBQXpCRyxFQUFFO1lBQ0ZhLEVBQUUsR0FBR2IsRUFBRSxDQUFDTSxXQUFXLENBQUNYLFVBQVUsRUFBRSxXQUFXLENBQUM7WUFDNUNZLFdBQVcsR0FBR00sRUFBRSxDQUFDTixXQUFXLENBQUNaLFVBQVUsQ0FBQztZQUFBO1lBQUEsT0FDeENZLFdBQVcsQ0FBQ08sR0FBRyxDQUFDRixlQUFlLEVBQUVKLFVBQVUsQ0FBQ3hGLEdBQUcsQ0FBQyxDQUFDO1VBQUE7WUFBQSxrQ0FDaEQ2RixFQUFFLENBQUNFLElBQUk7VUFBQTtZQUFBO1lBQUE7WUFFZCxJQUFJLHdCQUFhTix5REFBYSxFQUFFO2NBQzlCdkgsTUFBTSxDQUFDaUcsSUFBSSxDQUFDLGFBQUVpQixPQUFPLENBQUM7WUFDdkIsT0FBTTtjQUNDTSxXQUFXLEdBQUdqRSxhQUFhLENBQUNpQixNQUFNLENBQXFCO2dCQUMzRHlDLG9CQUFvQixFQUFHLGlCQUFXLFFBQVgsZ0RBQWFDO2NBQ3JDLEVBQUM7Y0FDRmxILE1BQU0sQ0FBQ2lHLElBQUksQ0FBQ3VCLFdBQVcsQ0FBQ04sT0FBTyxDQUFDO1lBQ2pDO1VBQUE7VUFBQTtZQUFBO1FBQUE7TUFBQTtJQUFBO0VBQUEsQ0FFSjtFQUFBO0FBQUE7QUFFRCxTQUFTSSxVQUFVLENBQUN4RixHQUFnQjtFQUNsQyxpQkFBVUEsR0FBRyxDQUFDSSxJQUFJLGNBQUlKLEdBQUcsQ0FBQzRCLE9BQU8sQ0FBQ29FLEtBQUs7QUFDekM7O0FDeEdBOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQXFCSCxJQUFNQyxnQkFBZ0IsR0FBRyxJQUFJO0FBQzdCO0FBQ0EsSUFBTUMscUNBQXFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUk7QUFBQyxJQUUxREMsb0JBQW9CO0VBeUIvQiw4QkFBNkJqSixTQUE2QjtJQUFBO0lBQUE7SUFBN0IsSUFBUyxhQUFUQSxTQUFTO0lBbEJ0Qzs7Ozs7Ozs7QUFRRztJQUNILElBQWdCLG9CQUFpQyxJQUFJO0lBVW5ELElBQU04QyxHQUFHLEdBQUcsSUFBSSxDQUFDOUMsU0FBUyxDQUFDNkQsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDdEQsWUFBWSxFQUFFO0lBQzVELElBQUksQ0FBQzJJLFFBQVEsR0FBRyxJQUFJQyxvQkFBb0IsQ0FBQ3JHLEdBQUcsQ0FBQztJQUM3QyxJQUFJLENBQUNzRyx1QkFBdUIsR0FBRyxJQUFJLENBQUNGLFFBQVEsQ0FBQ0csSUFBSSxFQUFFLENBQUNDLElBQUksQ0FBQyxnQkFBTSxFQUFHO01BQ2hFLE1BQUksQ0FBQ0MsZ0JBQWdCLEdBQUdDLE1BQU07TUFDOUIsT0FBT0EsTUFBTTtJQUNmLENBQUMsQ0FBQzs7RUFHSjs7Ozs7O0FBTUc7RUFOSDtJQUFBO0lBQUE7TUFBQSxtRkFPQTtRQUFBO1FBQUE7VUFBQTtZQUFBO2NBQUE7Z0JBQ1FDLGNBQWMsR0FBRyxJQUFJLENBQUN6SixTQUFTLENBQ2xDNkQsV0FBVyxDQUFDLGlCQUFpQixDQUFDLENBQzlCdEQsWUFBWSxFQUFFOztnQkFJWG1KLEtBQUssR0FBR0QsY0FBYyxDQUFDRSxxQkFBcUIsRUFBRTtnQkFDOUNDLElBQUksR0FBR0MsZ0JBQWdCLEVBQUU7Z0JBQUEsTUFDM0IsSUFBSSxDQUFDTixnQkFBZ0IsS0FBSyxJQUFJO2tCQUFBO2tCQUFBO2dCQUFBO2dCQUFBO2dCQUFBLE9BQ0YsSUFBSSxDQUFDSCx1QkFBdUI7Y0FBQTtnQkFBMUQsSUFBSSxDQUFDRyxnQkFBZ0I7Y0FBQTtnQkFBQSxNQUtyQixJQUFJLENBQUNBLGdCQUFnQixDQUFDTyxxQkFBcUIsS0FBS0YsSUFBSSxJQUNwRCxJQUFJLENBQUNMLGdCQUFnQixDQUFDUSxVQUFVLENBQUNDLElBQUksQ0FDbkMsNkJBQW1CO2tCQUFBLE9BQUlDLG1CQUFtQixDQUFDTCxJQUFJLEtBQUtBLElBQUk7Z0JBQUEsRUFDekQ7a0JBQUE7a0JBQUE7Z0JBQUE7Z0JBQUE7Y0FBQTs7Z0JBS0QsSUFBSSxDQUFDTCxnQkFBZ0IsQ0FBQ1EsVUFBVSxDQUFDL0MsSUFBSSxDQUFDO2tCQUFFNEMsSUFBSSxFQUFKQSxJQUFJO2tCQUFFRixLQUFLLEVBQUxBO2dCQUFLLENBQUUsQ0FBQztjQUFDOztnQkFHekQsSUFBSSxDQUFDSCxnQkFBZ0IsQ0FBQ1EsVUFBVSxHQUFHLElBQUksQ0FBQ1IsZ0JBQWdCLENBQUNRLFVBQVUsQ0FBQ3JKLE1BQU0sQ0FDeEUsNkJBQW1CLEVBQUc7a0JBQ3BCLElBQU13SixXQUFXLEdBQUcsSUFBSUMsSUFBSSxDQUFDRixtQkFBbUIsQ0FBQ0wsSUFBSSxDQUFDLENBQUNRLE9BQU8sRUFBRTtrQkFDaEUsSUFBTUMsR0FBRyxHQUFHRixJQUFJLENBQUNFLEdBQUcsRUFBRTtrQkFDdEIsT0FBT0EsR0FBRyxHQUFHSCxXQUFXLElBQUlsQixxQ0FBcUM7Z0JBQ25FLENBQUMsQ0FDRjtnQkFBQyxpQ0FDSyxJQUFJLENBQUNFLFFBQVEsQ0FBQ29CLFNBQVMsQ0FBQyxJQUFJLENBQUNmLGdCQUFnQixDQUFDO2NBQUE7Y0FBQTtnQkFBQTtZQUFBO1VBQUE7UUFBQTtNQUFBLENBQ3REO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtJQUVEOzs7Ozs7QUFNRztFQU5IO0lBQUE7SUFBQTtNQUFBLHNGQU9BO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FBQTtnQkFBQSxNQUNNLElBQUksQ0FBQ0EsZ0JBQWdCLEtBQUssSUFBSTtrQkFBQTtrQkFBQTtnQkFBQTtnQkFBQTtnQkFBQSxPQUMxQixJQUFJLENBQUNILHVCQUF1QjtjQUFBO2dCQUFBLE1BSWxDLElBQUksQ0FBQ0csZ0JBQWdCLEtBQUssSUFBSSxJQUM5QixJQUFJLENBQUNBLGdCQUFnQixDQUFDUSxVQUFVLENBQUNRLE1BQU0sS0FBSyxDQUFDO2tCQUFBO2tCQUFBO2dCQUFBO2dCQUFBLGtDQUV0QyxFQUFFO2NBQUE7Z0JBRUxYLElBQUksR0FBR0MsZ0JBQWdCLEVBQUU7d0NBRWFXLDBCQUEwQixDQUNwRSxJQUFJLENBQUNqQixnQkFBZ0IsQ0FBQ1EsVUFBVSxDQUNqQyxFQUZPVSxnQkFBZ0IseUJBQWhCQSxnQkFBZ0IsRUFBRUMsYUFBYSx5QkFBYkEsYUFBYTtnQkFHakNDLFlBQVksR0FBR0MsNkVBQTZCLENBQ2hEQyxJQUFJLENBQUNDLFNBQVMsQ0FBQztrQkFBRXJLLE9BQU8sRUFBRSxDQUFDO2tCQUFFc0osVUFBVSxFQUFFVTtnQkFBZ0IsQ0FBRSxDQUFDLENBQzdEO2dCQUVELElBQUksQ0FBQ2xCLGdCQUFnQixDQUFDTyxxQkFBcUIsR0FBR0YsSUFBSTtnQkFBQyxNQUMvQ2MsYUFBYSxDQUFDSCxNQUFNLEdBQUcsQ0FBQztrQkFBQTtrQkFBQTtnQkFBQTs7Z0JBRTFCLElBQUksQ0FBQ2hCLGdCQUFnQixDQUFDUSxVQUFVLEdBQUdXLGFBQWE7Ozs7O3VCQUkxQyxJQUFJLENBQUN4QixRQUFRLENBQUNvQixTQUFTLENBQUMsSUFBSSxDQUFDZixnQkFBZ0IsQ0FBQztjQUFBO2dCQUFBO2dCQUFBO2NBQUE7Z0JBRXBELElBQUksQ0FBQ0EsZ0JBQWdCLENBQUNRLFVBQVUsR0FBRyxFQUFFOztnQkFFckMsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQ29CLFNBQVMsQ0FBQyxJQUFJLENBQUNmLGdCQUFnQixDQUFDO2NBQUM7Z0JBQUEsa0NBRS9Db0IsWUFBWTtjQUFBO2NBQUE7Z0JBQUE7WUFBQTtVQUFBO1FBQUE7TUFBQSxDQUNwQjtNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7RUFBQTtFQUFBO0FBQUE7QUFHSCxTQUFTZCxnQkFBZ0I7RUFDdkIsSUFBTWtCLEtBQUssR0FBRyxJQUFJWixJQUFJLEVBQUU7O0VBRXhCLE9BQU9ZLEtBQUssQ0FBQ0MsV0FBVyxFQUFFLENBQUNDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0FBQzdDO1NBRWdCVCwwQkFBMEIsQ0FDeENVLGVBQXNDLEVBQ1o7RUFBQSxJQUExQkMsT0FBTyx1RUFBR3BDLGdCQUFnQjs7O0VBTzFCLElBQU0wQixnQkFBZ0IsR0FBNEIsRUFBRTs7RUFFcEQsSUFBSUMsYUFBYSxHQUFHUSxlQUFlLENBQUNFLEtBQUssRUFBRTtFQUFDLDRDQUNWRixlQUFlO0lBQUE7RUFBQTtJQUFBO01BQUEsSUFBdENqQixtQkFBbUI7O01BRTVCLElBQU1vQixjQUFjLEdBQUdaLGdCQUFnQixDQUFDYSxJQUFJLENBQzFDLFlBQUU7UUFBQSxPQUFJQyxFQUFFLENBQUM3QixLQUFLLEtBQUtPLG1CQUFtQixDQUFDUCxLQUFLO01BQUEsRUFDN0M7TUFDRCxJQUFJLENBQUMyQixjQUFjLEVBQUU7O1FBRW5CWixnQkFBZ0IsQ0FBQ3pELElBQUksQ0FBQztVQUNwQjBDLEtBQUssRUFBRU8sbUJBQW1CLENBQUNQLEtBQUs7VUFDaEM4QixLQUFLLEVBQUUsQ0FBQ3ZCLG1CQUFtQixDQUFDTCxJQUFJO1FBQ2pDLEVBQUM7UUFDRixJQUFJNkIsVUFBVSxDQUFDaEIsZ0JBQWdCLENBQUMsR0FBR1UsT0FBTyxFQUFFOzs7VUFHMUNWLGdCQUFnQixDQUFDaUIsR0FBRyxFQUFFO1VBQ3RCO1FBQ0Q7TUFDRixPQUFNO1FBQ0xMLGNBQWMsQ0FBQ0csS0FBSyxDQUFDeEUsSUFBSSxDQUFDaUQsbUJBQW1CLENBQUNMLElBQUksQ0FBQzs7O1FBR25ELElBQUk2QixVQUFVLENBQUNoQixnQkFBZ0IsQ0FBQyxHQUFHVSxPQUFPLEVBQUU7VUFDMUNFLGNBQWMsQ0FBQ0csS0FBSyxDQUFDRSxHQUFHLEVBQUU7VUFDMUI7UUFDRDtNQUNGOzs7TUFHRGhCLGFBQWEsR0FBR0EsYUFBYSxDQUFDVSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQUM7SUE1QnpDLHVEQUFtRDtNQUFBO01BQUEsc0JBdUI3QztJQU1MO0VBQUE7SUFBQTtFQUFBO0lBQUE7RUFBQTtFQUNELE9BQU87SUFDTFgsZ0JBQWdCLEVBQWhCQSxnQkFBZ0I7SUFDaEJDLGFBQWEsRUFBYkE7R0FDRDtBQUNIO0FBQUMsSUFFWXZCLG9CQUFvQjtFQUUvQiw4QkFBbUJyRyxHQUFnQjtJQUFBO0lBQWhCLElBQUcsT0FBSEEsR0FBRztJQUNwQixJQUFJLENBQUM2SSx1QkFBdUIsR0FBRyxJQUFJLENBQUNDLDRCQUE0QixFQUFFOztFQUNuRTtJQUFBO0lBQUE7TUFBQSwrRkFDRDtRQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUFBLElBQ09DLG9FQUFvQixFQUFFO2tCQUFBO2tCQUFBO2dCQUFBO2dCQUFBLGtDQUNsQixLQUFLO2NBQUE7Z0JBQUEsa0NBRUxDLHlFQUF5QixFQUFFLENBQy9CeEMsSUFBSSxDQUFDO2tCQUFBLE9BQU0sSUFBSTtnQkFBQSxFQUFDLFNBQ1gsQ0FBQztrQkFBQSxPQUFNLEtBQUs7Z0JBQUEsRUFBQztjQUFBO2NBQUE7Z0JBQUE7WUFBQTtVQUFBO1FBQUE7TUFBQSxDQUV4QjtNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFDRDs7QUFFRztFQUZIO0lBQUE7SUFBQTtNQUFBLHVFQUdBO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FBQTtnQkFBQTtnQkFBQSxPQUNnQyxJQUFJLENBQUNxQyx1QkFBdUI7Y0FBQTtnQkFBcERJLGVBQWU7Z0JBQUEsSUFDaEJBLGVBQWU7a0JBQUE7a0JBQUE7Z0JBQUE7Z0JBQUEsa0NBQ1g7a0JBQUVoQyxVQUFVLEVBQUU7Z0JBQUUsQ0FBRTtjQUFBO2dCQUFBO2dCQUFBLE9BRVE1QiwyQkFBMkIsQ0FBQyxJQUFJLENBQUNyRixHQUFHLENBQUM7Y0FBQTtnQkFBaEVrSixrQkFBa0I7Z0JBQUEsa0NBQ2pCQSxrQkFBa0IsSUFBSTtrQkFBRWpDLFVBQVUsRUFBRTtnQkFBRSxDQUFFO2NBQUE7Y0FBQTtnQkFBQTtZQUFBO1VBQUE7UUFBQTtNQUFBLENBRWxEO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTs7OztrRkFFRCxrQkFBZ0JrQyxnQkFBdUM7UUFBQTtRQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUFBO2dCQUFBLE9BQ3ZCLElBQUksQ0FBQ04sdUJBQXVCO2NBQUE7Z0JBQXBESSxlQUFlO2dCQUFBLElBQ2hCQSxlQUFlO2tCQUFBO2tCQUFBO2dCQUFBO2dCQUFBO2NBQUE7Z0JBQUE7Z0JBQUEsT0FHcUIsSUFBSSxDQUFDMUMsSUFBSSxFQUFFO2NBQUE7Z0JBQTVDNkMsd0JBQXdCO2dCQUFBLGtDQUN2QnpELDBCQUEwQixDQUFDLElBQUksQ0FBQzNGLEdBQUcsRUFBRTtrQkFDMUNnSCxxQkFBcUIsRUFDbkIsc0JBQWdCLENBQUNBLHFCQUFxQixNQUN0QyxxREFBd0IsQ0FBQ0EscUJBQXFCO2tCQUNoREMsVUFBVSxFQUFFa0MsZ0JBQWdCLENBQUNsQztnQkFDOUIsRUFBQztjQUFBO2NBQUE7Z0JBQUE7WUFBQTtVQUFBO1FBQUE7TUFBQSxDQUVMO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTs7Ozs0RUFFRCxrQkFBVWtDLGdCQUF1QztRQUFBO1FBQUE7VUFBQTtZQUFBO2NBQUE7Z0JBQUE7Z0JBQUEsT0FDakIsSUFBSSxDQUFDTix1QkFBdUI7Y0FBQTtnQkFBcERJLGVBQWU7Z0JBQUEsSUFDaEJBLGVBQWU7a0JBQUE7a0JBQUE7Z0JBQUE7Z0JBQUE7Y0FBQTtnQkFBQTtnQkFBQSxPQUdxQixJQUFJLENBQUMxQyxJQUFJLEVBQUU7Y0FBQTtnQkFBNUM2Qyx3QkFBd0I7Z0JBQUEsa0NBQ3ZCekQsMEJBQTBCLENBQUMsSUFBSSxDQUFDM0YsR0FBRyxFQUFFO2tCQUMxQ2dILHFCQUFxQixFQUNuQixzQkFBZ0IsQ0FBQ0EscUJBQXFCLE1BQ3RDLHFEQUF3QixDQUFDQSxxQkFBcUI7a0JBQ2hEQyxVQUFVLCtCQUNMbUMsd0JBQXdCLENBQUNuQyxVQUFVLHNCQUNuQ2tDLGdCQUFnQixDQUFDbEMsVUFBVTtnQkFFakMsRUFBQztjQUFBO2NBQUE7Z0JBQUE7WUFBQTtVQUFBO1FBQUE7TUFBQSxDQUVMO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtFQUFBO0VBQUE7QUFBQTtBQUdIOzs7O0FBSUc7QUFDRyxTQUFVMEIsVUFBVSxDQUFDUCxlQUF3Qzs7RUFFakUsT0FBT04sNkVBQTZCOztFQUVsQ0MsSUFBSSxDQUFDQyxTQUFTLENBQUM7SUFBRXJLLE9BQU8sRUFBRSxDQUFDO0lBQUVzSixVQUFVLEVBQUVtQjtFQUFlLENBQUUsQ0FBQyxDQUM1RCxDQUFDWCxNQUFNO0FBQ1Y7O0FDL1JBOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQVNHLFNBQVU0QixzQkFBc0IsQ0FBQ3hGLE9BQWdCO0VBQ3JEdkQsa0JBQWtCLENBQ2hCLElBQUkrQiwwREFBUyxDQUNYLGlCQUFpQixFQUNqQixtQkFBUztJQUFBLE9BQUksSUFBSXBGLHlCQUF5QixDQUFDQyxTQUFTLENBQUM7RUFBQSx5Q0FFdEQsQ0FDRjtFQUNEb0Qsa0JBQWtCLENBQ2hCLElBQUkrQiwwREFBUyxDQUNYLFdBQVcsRUFDWCxtQkFBUztJQUFBLE9BQUksSUFBSThELG9CQUFvQixDQUFDakosU0FBUyxDQUFDO0VBQUEseUNBRWpELENBQ0Y7O0VBR0R5RyxlQUFlLENBQUN2RCxNQUFJLEVBQUV6QyxTQUFPLEVBQUVrRyxPQUFPLENBQUM7O0VBRXZDRixlQUFlLENBQUN2RCxNQUFJLEVBQUV6QyxTQUFPLEVBQUUsU0FBa0IsQ0FBQzs7RUFFbERnRyxlQUFlLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztBQUNoQzs7QUM5Q0E7Ozs7O0FBS0c7QUF5QkgwRixzQkFBc0IsQ0FBQyxFQUFpQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9zcmMvcGxhdGZvcm1Mb2dnZXJTZXJ2aWNlLnRzPzJlZWIiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9zcmMvbG9nZ2VyLnRzP2YwYjMiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9zcmMvY29uc3RhbnRzLnRzP2RhMjYiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9zcmMvaW50ZXJuYWwudHM/YzUzOCIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uLy4uL3NyYy9lcnJvcnMudHM/YjA4MiIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uLy4uL3NyYy9maXJlYmFzZUFwcC50cz84MjYzIiwid2VicGFjazovL2xpYnJhcnkvLi4vLi4vc3JjL2FwaS50cz81ZGViIiwid2VicGFjazovL2xpYnJhcnkvLi4vLi4vc3JjL2luZGV4ZWRkYi50cz83Zjc3Iiwid2VicGFjazovL2xpYnJhcnkvLi4vLi4vc3JjL2hlYXJ0YmVhdFNlcnZpY2UudHM/N2Y2ZiIsIndlYnBhY2s6Ly9saWJyYXJ5Ly4uLy4uL3NyYy9yZWdpc3RlckNvcmVDb21wb25lbnRzLnRzPzA4MTMiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9zcmMvaW5kZXgudHM/MGUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBDb21wb25lbnRDb250YWluZXIsXG4gIENvbXBvbmVudFR5cGUsXG4gIFByb3ZpZGVyLFxuICBOYW1lXG59IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlLCBWZXJzaW9uU2VydmljZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCBpbXBsZW1lbnRzIFBsYXRmb3JtTG9nZ2VyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXIpIHt9XG4gIC8vIEluIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgaW5zdGFsbGF0aW9ucyBvblxuICAvLyBhdXRoIHRva2VuIHJlZnJlc2gsIGFuZCBpbnN0YWxsYXRpb25zIHdpbGwgc2VuZCB0aGlzIHN0cmluZy5cbiAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgcHJvdmlkZXJzID0gdGhpcy5jb250YWluZXIuZ2V0UHJvdmlkZXJzKCk7XG4gICAgLy8gTG9vcCB0aHJvdWdoIHByb3ZpZGVycyBhbmQgZ2V0IGxpYnJhcnkvdmVyc2lvbiBwYWlycyBmcm9tIGFueSB0aGF0IGFyZVxuICAgIC8vIHZlcnNpb24gY29tcG9uZW50cy5cbiAgICByZXR1cm4gcHJvdmlkZXJzXG4gICAgICAubWFwKHByb3ZpZGVyID0+IHtcbiAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcbiAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCkgYXMgVmVyc2lvblNlcnZpY2U7XG4gICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2UubGlicmFyeX0vJHtzZXJ2aWNlLnZlcnNpb259YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcbiAgICAgIC5qb2luKCcgJyk7XG4gIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm92aWRlciBjaGVjayBpZiB0aGlzIHByb3ZpZGVyIHByb3ZpZGVzIGEgVmVyc2lvblNlcnZpY2VcbiAqXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcbiAqIHByb3ZpZGVzIFZlcnNpb25TZXJ2aWNlLiBUaGUgcHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyaWx5IGEgJ2FwcC12ZXJzaW9uJ1xuICogcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcjogUHJvdmlkZXI8TmFtZT4pOiBib29sZWFuIHtcbiAgY29uc3QgY29tcG9uZW50ID0gcHJvdmlkZXIuZ2V0Q29tcG9uZW50KCk7XG4gIHJldHVybiBjb21wb25lbnQ/LnR5cGUgPT09IENvbXBvbmVudFR5cGUuVkVSU0lPTjtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FwcCcpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgbmFtZSBhcyBhcHBOYW1lIH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYXBwQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uL2FwcC1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYW5hbHl0aWNzQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2FuYWx5dGljcy1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYW5hbHl0aWNzTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2FuYWx5dGljcy9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhcHBDaGVja0NvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9hcHAtY2hlY2stY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGFwcENoZWNrTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2FwcC1jaGVjay9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhdXRoTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2F1dGgvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYXV0aENvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9hdXRoLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBkYXRhYmFzZU5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9kYXRhYmFzZS9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBkYXRhYmFzZUNvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9kYXRhYmFzZS1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgZnVuY3Rpb25zTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2Z1bmN0aW9ucy9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBmdW5jdGlvbnNDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZnVuY3Rpb25zLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBpbnN0YWxsYXRpb25zTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2luc3RhbGxhdGlvbnMvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgaW5zdGFsbGF0aW9uc0NvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9pbnN0YWxsYXRpb25zLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBtZXNzYWdpbmdOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvbWVzc2FnaW5nL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIG1lc3NhZ2luZ0NvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9tZXNzYWdpbmctY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHBlcmZvcm1hbmNlTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL3BlcmZvcm1hbmNlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHBlcmZvcm1hbmNlQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL3BlcmZvcm1hbmNlLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyByZW1vdGVDb25maWdOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvcmVtb3RlLWNvbmZpZy9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyByZW1vdGVDb25maWdDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvcmVtb3RlLWNvbmZpZy1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgc3RvcmFnZU5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9zdG9yYWdlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHN0b3JhZ2VDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvc3RvcmFnZS1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgZmlyZXN0b3JlTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2ZpcmVzdG9yZS9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBmaXJlc3RvcmVDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZmlyZXN0b3JlLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBwYWNrYWdlTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2ZpcmViYXNlL3BhY2thZ2UuanNvbic7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYXBwIG5hbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuXG5leHBvcnQgY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcbiAgW2FwcE5hbWVdOiAnZmlyZS1jb3JlJyxcbiAgW2FwcENvbXBhdE5hbWVdOiAnZmlyZS1jb3JlLWNvbXBhdCcsXG4gIFthbmFseXRpY3NOYW1lXTogJ2ZpcmUtYW5hbHl0aWNzJyxcbiAgW2FuYWx5dGljc0NvbXBhdE5hbWVdOiAnZmlyZS1hbmFseXRpY3MtY29tcGF0JyxcbiAgW2FwcENoZWNrTmFtZV06ICdmaXJlLWFwcC1jaGVjaycsXG4gIFthcHBDaGVja0NvbXBhdE5hbWVdOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcbiAgW2F1dGhOYW1lXTogJ2ZpcmUtYXV0aCcsXG4gIFthdXRoQ29tcGF0TmFtZV06ICdmaXJlLWF1dGgtY29tcGF0JyxcbiAgW2RhdGFiYXNlTmFtZV06ICdmaXJlLXJ0ZGInLFxuICBbZGF0YWJhc2VDb21wYXROYW1lXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxuICBbZnVuY3Rpb25zTmFtZV06ICdmaXJlLWZuJyxcbiAgW2Z1bmN0aW9uc0NvbXBhdE5hbWVdOiAnZmlyZS1mbi1jb21wYXQnLFxuICBbaW5zdGFsbGF0aW9uc05hbWVdOiAnZmlyZS1paWQnLFxuICBbaW5zdGFsbGF0aW9uc0NvbXBhdE5hbWVdOiAnZmlyZS1paWQtY29tcGF0JyxcbiAgW21lc3NhZ2luZ05hbWVdOiAnZmlyZS1mY20nLFxuICBbbWVzc2FnaW5nQ29tcGF0TmFtZV06ICdmaXJlLWZjbS1jb21wYXQnLFxuICBbcGVyZm9ybWFuY2VOYW1lXTogJ2ZpcmUtcGVyZicsXG4gIFtwZXJmb3JtYW5jZUNvbXBhdE5hbWVdOiAnZmlyZS1wZXJmLWNvbXBhdCcsXG4gIFtyZW1vdGVDb25maWdOYW1lXTogJ2ZpcmUtcmMnLFxuICBbcmVtb3RlQ29uZmlnQ29tcGF0TmFtZV06ICdmaXJlLXJjLWNvbXBhdCcsXG4gIFtzdG9yYWdlTmFtZV06ICdmaXJlLWdjcycsXG4gIFtzdG9yYWdlQ29tcGF0TmFtZV06ICdmaXJlLWdjcy1jb21wYXQnLFxuICBbZmlyZXN0b3JlTmFtZV06ICdmaXJlLWZzdCcsXG4gIFtmaXJlc3RvcmVDb21wYXROYW1lXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXG4gICdmaXJlLWpzJzogJ2ZpcmUtanMnLCAvLyBQbGF0Zm9ybSBpZGVudGlmaWVyIGZvciBKUyBTREsuXG4gIFtwYWNrYWdlTmFtZV06ICdmaXJlLWpzLWFsbCdcbn0gYXMgY29uc3Q7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUFwcCB9IGZyb20gJy4vcHVibGljLXR5cGVzJztcbmltcG9ydCB7IENvbXBvbmVudCwgUHJvdmlkZXIsIE5hbWUgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IERFRkFVTFRfRU5UUllfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IEZpcmViYXNlQXBwSW1wbCB9IGZyb20gJy4vZmlyZWJhc2VBcHAnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgX2FwcHMgPSBuZXcgTWFwPHN0cmluZywgRmlyZWJhc2VBcHA+KCk7XG5cbi8qKlxuICogUmVnaXN0ZXJlZCBjb21wb25lbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNvbnN0IF9jb21wb25lbnRzID0gbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudDxhbnk+PigpO1xuXG4vKipcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWRkQ29tcG9uZW50PFQgZXh0ZW5kcyBOYW1lPihcbiAgYXBwOiBGaXJlYmFzZUFwcCxcbiAgY29tcG9uZW50OiBDb21wb25lbnQ8VD5cbik6IHZvaWQge1xuICB0cnkge1xuICAgIChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsKS5jb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZhaWxlZCB0byByZWdpc3RlciB3aXRoIEZpcmViYXNlQXBwICR7YXBwLm5hbWV9YCxcbiAgICAgIGVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50KFxuICBhcHA6IEZpcmViYXNlQXBwLFxuICBjb21wb25lbnQ6IENvbXBvbmVudFxuKTogdm9pZCB7XG4gIChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsKS5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudDxUIGV4dGVuZHMgTmFtZT4oXG4gIGNvbXBvbmVudDogQ29tcG9uZW50PFQ+XG4pOiBib29sZWFuIHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xuICBpZiAoX2NvbXBvbmVudHMuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYFxuICAgICk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcblxuICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byBleGlzdGluZyBhcHAgaW5zdGFuY2VzXG4gIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XG4gICAgX2FkZENvbXBvbmVudChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsLCBjb21wb25lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcbiAqXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQcm92aWRlcjxUIGV4dGVuZHMgTmFtZT4oXG4gIGFwcDogRmlyZWJhc2VBcHAsXG4gIG5hbWU6IFRcbik6IFByb3ZpZGVyPFQ+IHtcbiAgY29uc3QgaGVhcnRiZWF0Q29udHJvbGxlciA9IChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsKS5jb250YWluZXJcbiAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXG4gICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xuICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XG4gIH1cbiAgcmV0dXJuIChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsKS5jb250YWluZXIuZ2V0UHJvdmlkZXIobmFtZSk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2U8VCBleHRlbmRzIE5hbWU+KFxuICBhcHA6IEZpcmViYXNlQXBwLFxuICBuYW1lOiBULFxuICBpbnN0YW5jZUlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRVxuKTogdm9pZCB7XG4gIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpLmNsZWFySW5zdGFuY2UoaW5zdGFuY2VJZGVudGlmaWVyKTtcbn1cblxuLyoqXG4gKiBUZXN0IG9ubHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKTogdm9pZCB7XG4gIF9jb21wb25lbnRzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogRXhwb3J0ZWQgaW4gb3JkZXIgdG8gYmUgdXNlZCBpbiBhcHAtY29tcGF0IHBhY2thZ2VcbiAqL1xuZXhwb3J0IHsgREVGQVVMVF9FTlRSWV9OQU1FIGFzIF9ERUZBVUxUX0VOVFJZX05BTUUgfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgRXJyb3JNYXAgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEFwcEVycm9yIHtcbiAgTk9fQVBQID0gJ25vLWFwcCcsXG4gIEJBRF9BUFBfTkFNRSA9ICdiYWQtYXBwLW5hbWUnLFxuICBEVVBMSUNBVEVfQVBQID0gJ2R1cGxpY2F0ZS1hcHAnLFxuICBBUFBfREVMRVRFRCA9ICdhcHAtZGVsZXRlZCcsXG4gIE5PX09QVElPTlMgPSAnbm8tb3B0aW9ucycsXG4gIElOVkFMSURfQVBQX0FSR1VNRU5UID0gJ2ludmFsaWQtYXBwLWFyZ3VtZW50JyxcbiAgSU5WQUxJRF9MT0dfQVJHVU1FTlQgPSAnaW52YWxpZC1sb2ctYXJndW1lbnQnLFxuICBJREJfT1BFTiA9ICdpZGItb3BlbicsXG4gIElEQl9HRVQgPSAnaWRiLWdldCcsXG4gIElEQl9XUklURSA9ICdpZGItc2V0JyxcbiAgSURCX0RFTEVURSA9ICdpZGItZGVsZXRlJ1xufVxuXG5jb25zdCBFUlJPUlM6IEVycm9yTWFwPEFwcEVycm9yPiA9IHtcbiAgW0FwcEVycm9yLk5PX0FQUF06XG4gICAgXCJObyBGaXJlYmFzZSBBcHAgJ3skYXBwTmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXG4gICAgJ2NhbGwgRmlyZWJhc2UgQXBwLmluaXRpYWxpemVBcHAoKScsXG4gIFtBcHBFcnJvci5CQURfQVBQX05BTUVdOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9XCIsXG4gIFtBcHBFcnJvci5EVVBMSUNBVEVfQVBQXTpcbiAgICBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcbiAgW0FwcEVycm9yLkFQUF9ERUxFVEVEXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxuICBbQXBwRXJyb3IuTk9fT1BUSU9OU106XG4gICAgJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcbiAgW0FwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UXTpcbiAgICAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xuICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcbiAgW0FwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UXTpcbiAgICAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxuICBbQXBwRXJyb3IuSURCX09QRU5dOlxuICAgICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gIFtBcHBFcnJvci5JREJfR0VUXTpcbiAgICAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gIFtBcHBFcnJvci5JREJfV1JJVEVdOlxuICAgICdFcnJvciB0aHJvd24gd2hlbiB3cml0aW5nIHRvIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gIFtBcHBFcnJvci5JREJfREVMRVRFXTpcbiAgICAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nXG59O1xuXG5pbnRlcmZhY2UgRXJyb3JQYXJhbXMge1xuICBbQXBwRXJyb3IuTk9fQVBQXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLkJBRF9BUFBfTkFNRV06IHsgYXBwTmFtZTogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5EVVBMSUNBVEVfQVBQXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLkFQUF9ERUxFVEVEXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9PUEVOXTogeyBvcmlnaW5hbEVycm9yTWVzc2FnZT86IHN0cmluZyB9O1xuICBbQXBwRXJyb3IuSURCX0dFVF06IHsgb3JpZ2luYWxFcnJvck1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9XUklURV06IHsgb3JpZ2luYWxFcnJvck1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9ERUxFVEVdOiB7IG9yaWdpbmFsRXJyb3JNZXNzYWdlPzogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeTxBcHBFcnJvciwgRXJyb3JQYXJhbXM+KFxuICAnYXBwJyxcbiAgJ0ZpcmViYXNlJyxcbiAgRVJST1JTXG4pO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRmlyZWJhc2VBcHAsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgRmlyZWJhc2VBcHBTZXR0aW5nc1xufSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQge1xuICBDb21wb25lbnRDb250YWluZXIsXG4gIENvbXBvbmVudCxcbiAgQ29tcG9uZW50VHlwZVxufSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IEVSUk9SX0ZBQ1RPUlksIEFwcEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VBcHBJbXBsIGltcGxlbWVudHMgRmlyZWJhc2VBcHAge1xuICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBGaXJlYmFzZU9wdGlvbnM7XG4gIHByaXZhdGUgcmVhZG9ubHkgX25hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIE9yaWdpbmFsIGNvbmZpZyB2YWx1ZXMgcGFzc2VkIGluIGFzIGEgY29uc3RydWN0b3IgcGFyYW1ldGVyLlxuICAgKiBJdCBpcyBvbmx5IHVzZWQgdG8gY29tcGFyZSB3aXRoIGFub3RoZXIgY29uZmlnIG9iamVjdCB0byBzdXBwb3J0IGlkZW1wb3RlbnQgaW5pdGlhbGl6ZUFwcCgpLlxuICAgKlxuICAgKiBVcGRhdGluZyBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgb24gdGhlIEFwcCBpbnN0YW5jZSB3aWxsIG5vdCBjaGFuZ2UgaXRzIHZhbHVlIGluIF9jb25maWcuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb25maWc6IFJlcXVpcmVkPEZpcmViYXNlQXBwU2V0dGluZ3M+O1xuICBwcml2YXRlIF9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgX2lzRGVsZXRlZCA9IGZhbHNlO1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb250YWluZXI6IENvbXBvbmVudENvbnRhaW5lcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gICAgY29uZmlnOiBSZXF1aXJlZDxGaXJlYmFzZUFwcFNldHRpbmdzPixcbiAgICBjb250YWluZXI6IENvbXBvbmVudENvbnRhaW5lclxuICApIHtcbiAgICB0aGlzLl9vcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5fY29uZmlnID0geyAuLi5jb25maWcgfTtcbiAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cbiAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChcbiAgICAgIG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIENvbXBvbmVudFR5cGUuUFVCTElDKVxuICAgICk7XG4gIH1cblxuICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICB9XG5cbiAgc2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xuICB9XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpOiBGaXJlYmFzZU9wdGlvbnMge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIGdldCBjb25maWcoKTogUmVxdWlyZWQ8RmlyZWJhc2VBcHBTZXR0aW5ncz4ge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICB9XG5cbiAgZ2V0IGNvbnRhaW5lcigpOiBDb21wb25lbnRDb250YWluZXIge1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH1cblxuICBnZXQgaXNEZWxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc0RlbGV0ZWQ7XG4gIH1cblxuICBzZXQgaXNEZWxldGVkKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2lzRGVsZXRlZCA9IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICovXG4gIHByaXZhdGUgY2hlY2tEZXN0cm95ZWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5BUFBfREVMRVRFRCwgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRmlyZWJhc2VBcHAsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgRmlyZWJhc2VBcHBTZXR0aW5nc1xufSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUsIFBMQVRGT1JNX0xPR19TVFJJTkcgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFUlJPUl9GQUNUT1JZLCBBcHBFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7XG4gIENvbXBvbmVudENvbnRhaW5lcixcbiAgQ29tcG9uZW50LFxuICBOYW1lLFxuICBDb21wb25lbnRUeXBlXG59IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uLy4uL2ZpcmViYXNlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcEltcGwgfSBmcm9tICcuL2ZpcmViYXNlQXBwJztcbmltcG9ydCB7IF9hcHBzLCBfY29tcG9uZW50cywgX3JlZ2lzdGVyQ29tcG9uZW50IH0gZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge1xuICBMb2dMZXZlbFN0cmluZyxcbiAgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWxJbXBsLFxuICBMb2dDYWxsYmFjayxcbiAgTG9nT3B0aW9ucyxcbiAgc2V0VXNlckxvZ0hhbmRsZXJcbn0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBkZWVwRXF1YWwsIGdldERlZmF1bHRBcHBDb25maWcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmV4cG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxuICpcbiAqIFNlZVxuICoge0BsaW5rXG4gKiAgIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3dlYi9zZXR1cCNhZGRfZmlyZWJhc2VfdG9feW91cl9hcHBcbiAqICAgfCBBZGQgRmlyZWJhc2UgdG8geW91ciBhcHB9IGFuZFxuICoge0BsaW5rXG4gKiAgIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3dlYi9zZXR1cCNtdWx0aXBsZS1wcm9qZWN0c1xuICogICB8IEluaXRpYWxpemUgbXVsdGlwbGUgcHJvamVjdHN9IGZvciBkZXRhaWxlZCBkb2N1bWVudGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IGFwcFxuICogLy8gUmV0cmlldmUgeW91ciBvd24gb3B0aW9ucyB2YWx1ZXMgYnkgYWRkaW5nIGEgd2ViIGFwcCBvblxuICogLy8gaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb21cbiAqIGluaXRpYWxpemVBcHAoe1xuICogICBhcGlLZXk6IFwiQUl6YS4uLi5cIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1dGggLyBHZW5lcmFsIFVzZVxuICogICBhdXRoRG9tYWluOiBcIllPVVJfQVBQLmZpcmViYXNlYXBwLmNvbVwiLCAgICAgICAgIC8vIEF1dGggd2l0aCBwb3B1cC9yZWRpcmVjdFxuICogICBkYXRhYmFzZVVSTDogXCJodHRwczovL1lPVVJfQVBQLmZpcmViYXNlaW8uY29tXCIsIC8vIFJlYWx0aW1lIERhdGFiYXNlXG4gKiAgIHN0b3JhZ2VCdWNrZXQ6IFwiWU9VUl9BUFAuYXBwc3BvdC5jb21cIiwgICAgICAgICAgLy8gU3RvcmFnZVxuICogICBtZXNzYWdpbmdTZW5kZXJJZDogXCIxMjM0NTY3ODlcIiAgICAgICAgICAgICAgICAgIC8vIENsb3VkIE1lc3NhZ2luZ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIEluaXRpYWxpemUgYW5vdGhlciBhcHBcbiAqIGNvbnN0IG90aGVyQXBwID0gaW5pdGlhbGl6ZUFwcCh7XG4gKiAgIGRhdGFiYXNlVVJMOiBcImh0dHBzOi8vPE9USEVSX0RBVEFCQVNFX05BTUU+LmZpcmViYXNlaW8uY29tXCIsXG4gKiAgIHN0b3JhZ2VCdWNrZXQ6IFwiPE9USEVSX1NUT1JBR0VfQlVDS0VUPi5hcHBzcG90LmNvbVwiXG4gKiB9LCBcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgYXBwJ3Mgc2VydmljZXMuXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byBpbml0aWFsaXplLiBJZiBubyBuYW1lXG4gKiAgIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGluaXRpYWxpemVkIGFwcC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXBwKFxuICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gIG5hbWU/OiBzdHJpbmdcbik6IEZpcmViYXNlQXBwO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIEZpcmViYXNlQXBwIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGFwcCdzIHNlcnZpY2VzLlxuICogQHBhcmFtIGNvbmZpZyAtIEZpcmViYXNlQXBwIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXBwKFxuICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gIGNvbmZpZz86IEZpcmViYXNlQXBwU2V0dGluZ3Ncbik6IEZpcmViYXNlQXBwO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIEZpcmViYXNlQXBwIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVBcHAoKTogRmlyZWJhc2VBcHA7XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChcbiAgX29wdGlvbnM/OiBGaXJlYmFzZU9wdGlvbnMsXG4gIHJhd0NvbmZpZyA9IHt9XG4pOiBGaXJlYmFzZUFwcCB7XG4gIGxldCBvcHRpb25zID0gX29wdGlvbnM7XG5cbiAgaWYgKHR5cGVvZiByYXdDb25maWcgIT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgbmFtZSA9IHJhd0NvbmZpZztcbiAgICByYXdDb25maWcgPSB7IG5hbWUgfTtcbiAgfVxuXG4gIGNvbnN0IGNvbmZpZzogUmVxdWlyZWQ8RmlyZWJhc2VBcHBTZXR0aW5ncz4gPSB7XG4gICAgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLFxuICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDogZmFsc2UsXG4gICAgLi4ucmF3Q29uZmlnXG4gIH07XG4gIGNvbnN0IG5hbWUgPSBjb25maWcubmFtZTtcblxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuQkFEX0FQUF9OQU1FLCB7XG4gICAgICBhcHBOYW1lOiBTdHJpbmcobmFtZSlcbiAgICB9KTtcbiAgfVxuXG4gIG9wdGlvbnMgfHw9IGdldERlZmF1bHRBcHBDb25maWcoKTtcblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5OT19PUFRJT05TKTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpIGFzIEZpcmViYXNlQXBwSW1wbDtcbiAgaWYgKGV4aXN0aW5nQXBwKSB7XG4gICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cbiAgICBpZiAoXG4gICAgICBkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcbiAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZylcbiAgICApIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuRFVQTElDQVRFX0FQUCwgeyBhcHBOYW1lOiBuYW1lIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XG4gIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XG4gICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICB9XG5cbiAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XG5cbiAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XG5cbiAgcmV0dXJuIG5ld0FwcDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXG4gKiBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcHAobmFtZTogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FKTogRmlyZWJhc2VBcHAge1xuICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XG4gIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XG4gIH1cbiAgaWYgKCFhcHApIHtcbiAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5OT19BUFAsIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgfVxuXG4gIHJldHVybiBhcHA7XG59XG5cbi8qKlxuICogQSAocmVhZC1vbmx5KSBhcnJheSBvZiBhbGwgaW5pdGlhbGl6ZWQgYXBwcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFwcHMoKTogRmlyZWJhc2VBcHBbXSB7XG4gIHJldHVybiBBcnJheS5mcm9tKF9hcHBzLnZhbHVlcygpKTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXG4gKiBzZXJ2aWNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogZGVsZXRlQXBwKGFwcClcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJBcHAgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZGVsZXRpbmcgYXBwOlwiLCBlcnJvcik7XG4gKiAgIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcDogRmlyZWJhc2VBcHApOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgbmFtZSA9IGFwcC5uYW1lO1xuICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XG4gICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgKGFwcCBhcyBGaXJlYmFzZUFwcEltcGwpLmNvbnRhaW5lclxuICAgICAgICAuZ2V0UHJvdmlkZXJzKClcbiAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSlcbiAgICApO1xuICAgIChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsKS5pc0RlbGV0ZWQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbGlicmFyeSdzIG5hbWUgYW5kIHZlcnNpb24gZm9yIHBsYXRmb3JtIGxvZ2dpbmcgcHVycG9zZXMuXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxuICogQHBhcmFtIHZhcmlhbnQgLSBCdW5kbGUgdmFyaWFudCwgZS5nLiwgbm9kZSwgcm4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclZlcnNpb24oXG4gIGxpYnJhcnlLZXlPck5hbWU6IHN0cmluZyxcbiAgdmVyc2lvbjogc3RyaW5nLFxuICB2YXJpYW50Pzogc3RyaW5nXG4pOiB2b2lkIHtcbiAgLy8gVE9ETzogV2UgY2FuIHVzZSB0aGlzIGNoZWNrIHRvIHdoaXRlbGlzdCBzdHJpbmdzIHdoZW4vaWYgd2Ugc2V0IHVwXG4gIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxuICBsZXQgbGlicmFyeSA9IFBMQVRGT1JNX0xPR19TVFJJTkdbbGlicmFyeUtleU9yTmFtZV0gPz8gbGlicmFyeUtleU9yTmFtZTtcbiAgaWYgKHZhcmlhbnQpIHtcbiAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XG4gIH1cbiAgY29uc3QgbGlicmFyeU1pc21hdGNoID0gbGlicmFyeS5tYXRjaCgvXFxzfFxcLy8pO1xuICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XG4gIGlmIChsaWJyYXJ5TWlzbWF0Y2ggfHwgdmVyc2lvbk1pc21hdGNoKSB7XG4gICAgY29uc3Qgd2FybmluZyA9IFtcbiAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxuICAgIF07XG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xuICAgICAgd2FybmluZy5wdXNoKFxuICAgICAgICBgbGlicmFyeSBuYW1lIFwiJHtsaWJyYXJ5fVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobGlicmFyeU1pc21hdGNoICYmIHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgd2FybmluZy5wdXNoKCdhbmQnKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgd2FybmluZy5wdXNoKFxuICAgICAgICBgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgXG4gICAgICApO1xuICAgIH1cbiAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9yZWdpc3RlckNvbXBvbmVudChcbiAgICBuZXcgQ29tcG9uZW50KFxuICAgICAgYCR7bGlicmFyeX0tdmVyc2lvbmAgYXMgTmFtZSxcbiAgICAgICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksXG4gICAgICBDb21wb25lbnRUeXBlLlZFUlNJT05cbiAgICApXG4gICk7XG59XG5cbi8qKlxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXG4gKiBAcGFyYW0gbG9nQ2FsbGJhY2sgLSBBbiBvcHRpb25hbCBjdXN0b20gbG9nIGhhbmRsZXIgdGhhdCBleGVjdXRlcyB1c2VyIGNvZGUgd2hlbmV2ZXJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gb25Mb2coXG4gIGxvZ0NhbGxiYWNrOiBMb2dDYWxsYmFjayB8IG51bGwsXG4gIG9wdGlvbnM/OiBMb2dPcHRpb25zXG4pOiB2b2lkIHtcbiAgaWYgKGxvZ0NhbGxiYWNrICE9PSBudWxsICYmIHR5cGVvZiBsb2dDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UKTtcbiAgfVxuICBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBhcmUgY2FwdHVyZWQgKGkuZS4gaWZcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsOiBMb2dMZXZlbFN0cmluZyk6IHZvaWQge1xuICBzZXRMb2dMZXZlbEltcGwobG9nTGV2ZWwpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IERCU2NoZW1hLCBvcGVuREIsIElEQlBEYXRhYmFzZSB9IGZyb20gJ2lkYic7XG5pbXBvcnQgeyBBcHBFcnJvciwgRVJST1JfRkFDVE9SWSB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEZpcmViYXNlQXBwIH0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHsgSGVhcnRiZWF0c0luSW5kZXhlZERCIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LWRhdGFiYXNlJztcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xuXG5pbnRlcmZhY2UgQXBwREIgZXh0ZW5kcyBEQlNjaGVtYSB7XG4gICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnOiB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgdmFsdWU6IEhlYXJ0YmVhdHNJbkluZGV4ZWREQjtcbiAgfTtcbn1cblxubGV0IGRiUHJvbWlzZTogUHJvbWlzZTxJREJQRGF0YWJhc2U8QXBwREI+PiB8IG51bGwgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCk6IFByb21pc2U8SURCUERhdGFiYXNlPEFwcERCPj4ge1xuICBpZiAoIWRiUHJvbWlzZSkge1xuICAgIGRiUHJvbWlzZSA9IG9wZW5EQjxBcHBEQj4oREJfTkFNRSwgREJfVkVSU0lPTiwge1xuICAgICAgdXBncmFkZTogKGRiLCBvbGRWZXJzaW9uKSA9PiB7XG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxuICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cbiAgICAgICAgLy8gdGhlIG9sZCB2ZXJzaW9uIGFuZCB0aGUgY3VycmVudCB2ZXJzaW9uLCB3ZSB3YW50IEFMTCB0aGUgbWlncmF0aW9uc1xuICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICAgICAgc3dpdGNoIChvbGRWZXJzaW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLklEQl9PUEVOLCB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYlByb21pc2U7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIoXG4gIGFwcDogRmlyZWJhc2VBcHBcbik6IFByb21pc2U8SGVhcnRiZWF0c0luSW5kZXhlZERCIHwgdW5kZWZpbmVkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcbiAgICByZXR1cm4gZGJcbiAgICAgIC50cmFuc2FjdGlvbihTVE9SRV9OQU1FKVxuICAgICAgLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpXG4gICAgICAuZ2V0KGNvbXB1dGVLZXkoYXBwKSkgYXMgUHJvbWlzZTxIZWFydGJlYXRzSW5JbmRleGVkREIgfCB1bmRlZmluZWQ+O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLklEQl9HRVQsIHtcbiAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IChlIGFzIEVycm9yKT8ubWVzc2FnZVxuICAgICAgfSk7XG4gICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKFxuICBhcHA6IEZpcmViYXNlQXBwLFxuICBoZWFydGJlYXRPYmplY3Q6IEhlYXJ0YmVhdHNJbkluZGV4ZWREQlxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgIGF3YWl0IG9iamVjdFN0b3JlLnB1dChoZWFydGJlYXRPYmplY3QsIGNvbXB1dGVLZXkoYXBwKSk7XG4gICAgcmV0dXJuIHR4LmRvbmU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuSURCX1dSSVRFLCB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiAoZSBhcyBFcnJvcik/Lm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwOiBGaXJlYmFzZUFwcCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHthcHAubmFtZX0hJHthcHAub3B0aW9ucy5hcHBJZH1gO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50Q29udGFpbmVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQge1xuICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyxcbiAgaXNJbmRleGVkREJBdmFpbGFibGUsXG4gIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGVcbn0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHtcbiAgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCLFxuICB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQlxufSBmcm9tICcuL2luZGV4ZWRkYic7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcCB9IGZyb20gJy4vcHVibGljLXR5cGVzJztcbmltcG9ydCB7XG4gIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCxcbiAgSGVhcnRiZWF0U2VydmljZSxcbiAgSGVhcnRiZWF0c0luSW5kZXhlZERCLFxuICBIZWFydGJlYXRTdG9yYWdlLFxuICBTaW5nbGVEYXRlSGVhcnRiZWF0XG59IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcbi8vIDMwIGRheXNcbmNvbnN0IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMgPSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbmV4cG9ydCBjbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCBpbXBsZW1lbnRzIEhlYXJ0YmVhdFNlcnZpY2Uge1xuICAvKipcbiAgICogVGhlIHBlcnNpc3RlbmNlIGxheWVyIGZvciBoZWFydGJlYXRzXG4gICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXG4gICAqL1xuICBfc3RvcmFnZTogSGVhcnRiZWF0U3RvcmFnZUltcGw7XG5cbiAgLyoqXG4gICAqIEluLW1lbW9yeSBjYWNoZSBmb3IgaGVhcnRiZWF0cywgdXNlZCBieSBnZXRIZWFydGJlYXRzSGVhZGVyKCkgdG8gZ2VuZXJhdGVcbiAgICogdGhlIGhlYWRlciBzdHJpbmcuXG4gICAqIFN0b3JlcyBvbmUgcmVjb3JkIHBlciBkYXRlLiBUaGlzIHdpbGwgYmUgY29uc29saWRhdGVkIGludG8gdGhlIHN0YW5kYXJkXG4gICAqIGZvcm1hdCBvZiBvbmUgcmVjb3JkIHBlciB1c2VyIGFnZW50IHN0cmluZyBiZWZvcmUgYmVpbmcgc2VudCBhcyBhIGhlYWRlci5cbiAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcbiAgICogYmUga2VwdCBpbiBzeW5jIHdpdGggaW5kZXhlZERCLlxuICAgKiBMZWF2ZSBwdWJsaWMgZm9yIGVhc2llciB0ZXN0aW5nLlxuICAgKi9cbiAgX2hlYXJ0YmVhdHNDYWNoZTogSGVhcnRiZWF0c0luSW5kZXhlZERCIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIHRoZSBpbml0aWFsaXphdGlvbiBwcm9taXNlIGZvciBwb3B1bGF0aW5nIGhlYXJ0YmVhdENhY2hlLlxuICAgKiBJZiBnZXRIZWFydGJlYXRzSGVhZGVyKCkgaXMgY2FsbGVkIGJlZm9yZSB0aGUgcHJvbWlzZSByZXNvbHZlc1xuICAgKiAoaGVhcmJlYXRzQ2FjaGUgPT0gbnVsbCksIGl0IHNob3VsZCB3YWl0IGZvciB0aGlzIHByb21pc2VcbiAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cbiAgICovXG4gIF9oZWFydGJlYXRzQ2FjaGVQcm9taXNlOiBQcm9taXNlPEhlYXJ0YmVhdHNJbkluZGV4ZWREQj47XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXIpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xuICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UgPSB0aGlzLl9zdG9yYWdlLnJlYWQoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byByZXBvcnQgYSBoZWFydGJlYXQuIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlXG4gICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcbiAgICogdG8gSW5kZXhlZERCLlxuICAgKiBOb3RlIHRoYXQgd2Ugb25seSBzdG9yZSBvbmUgaGVhcnRiZWF0IHBlciBkYXkuIFNvIGlmIGEgaGVhcnRiZWF0IGZvciB0b2RheSBpc1xuICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqL1xuICBhc3luYyB0cmlnZ2VySGVhcnRiZWF0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcbiAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcbiAgICAgIC5nZXRJbW1lZGlhdGUoKTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcbiAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cbiAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xuICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcbiAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXG4gICAgaWYgKFxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9PT0gZGF0ZSB8fFxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShcbiAgICAgICAgc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiBzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUgPT09IGRhdGVcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGVudHJpZXMgb2xkZXIgdGhhbiAzMCBkYXlzLlxuICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuZmlsdGVyKFxuICAgICAgc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XG4gICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXG4gICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxuICAgKlxuICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXG4gICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgfVxuICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCBvciB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZXJlIGlzIG5vIGRhdGEgdG8gc2VuZC5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwgfHxcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxuICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoXG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0c1xuICAgICk7XG4gICAgY29uc3QgaGVhZGVyU3RyaW5nID0gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSlcbiAgICApO1xuICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxuICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xuICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFN0b3JlIGFueSB1bnNlbnQgZW50cmllcyBpZiB0aGV5IGV4aXN0LlxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xuICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcbiAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxuICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cbiAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XG4gICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXG4gICAgICB2b2lkIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VVRDRGF0ZVN0cmluZygpOiBzdHJpbmcge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIC8vIFJldHVybnMgZGF0ZSBmb3JtYXQgJ1lZWVktTU0tREQnXG4gIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihcbiAgaGVhcnRiZWF0c0NhY2hlOiBTaW5nbGVEYXRlSGVhcnRiZWF0W10sXG4gIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTXG4pOiB7XG4gIGhlYXJ0YmVhdHNUb1NlbmQ6IEhlYXJ0YmVhdHNCeVVzZXJBZ2VudFtdO1xuICB1bnNlbnRFbnRyaWVzOiBTaW5nbGVEYXRlSGVhcnRiZWF0W107XG59IHtcbiAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXG4gIC8vIHRoZSBoZWFkZXIuXG4gIGNvbnN0IGhlYXJ0YmVhdHNUb1NlbmQ6IEhlYXJ0YmVhdHNCeVVzZXJBZ2VudFtdID0gW107XG4gIC8vIFNpbmdsZSBkYXRlIGZvcm1hdCBoZWFydGJlYXRzIHRoYXQgYXJlIG5vdCBzZW50LlxuICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xuICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XG4gICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxuICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKFxuICAgICAgaGIgPT4gaGIuYWdlbnQgPT09IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnRcbiAgICApO1xuICAgIGlmICghaGVhcnRiZWF0RW50cnkpIHtcbiAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxuICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcbiAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXG4gICAgICAgIGRhdGVzOiBbc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlXVxuICAgICAgfSk7XG4gICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XG4gICAgICAgIC8vIGVudHJ5IGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xuICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxuICAgICAgLy8gYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3AgdW5zZW50IGVudHJ5IGZyb20gcXVldWUuIChTa2lwcGVkIGlmIGFkZGluZyB0aGUgZW50cnkgZXhjZWVkZWRcbiAgICAvLyBxdW90YSBhbmQgdGhlIGxvb3AgYnJlYWtzIGVhcmx5LilcbiAgICB1bnNlbnRFbnRyaWVzID0gdW5zZW50RW50cmllcy5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhlYXJ0YmVhdHNUb1NlbmQsXG4gICAgdW5zZW50RW50cmllc1xuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwgaW1wbGVtZW50cyBIZWFydGJlYXRTdG9yYWdlIHtcbiAgcHJpdmF0ZSBfY2FuVXNlSW5kZXhlZERCUHJvbWlzZTogUHJvbWlzZTxib29sZWFuPjtcbiAgY29uc3RydWN0b3IocHVibGljIGFwcDogRmlyZWJhc2VBcHApIHtcbiAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XG4gIH1cbiAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxuICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhZCBhbGwgaGVhcnRiZWF0cy5cbiAgICovXG4gIGFzeW5jIHJlYWQoKTogUHJvbWlzZTxIZWFydGJlYXRzSW5JbmRleGVkREI+IHtcbiAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xuICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdCB8fCB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgfVxuICB9XG4gIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXG4gIGFzeW5jIG92ZXJ3cml0ZShoZWFydGJlYXRzT2JqZWN0OiBIZWFydGJlYXRzSW5JbmRleGVkREIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTpcbiAgICAgICAgICBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA/P1xuICAgICAgICAgIGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIGFkZCBoZWFydGJlYXRzXG4gIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0OiBIZWFydGJlYXRzSW5JbmRleGVkREIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTpcbiAgICAgICAgICBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA/P1xuICAgICAgICAgIGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgIGhlYXJ0YmVhdHM6IFtcbiAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcbiAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXG4gKiB0byBiYXNlIDY0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGU6IEhlYXJ0YmVhdHNCeVVzZXJBZ2VudFtdKTogbnVtYmVyIHtcbiAgLy8gYmFzZTY0IGhhcyBhIHJlc3RyaWN0ZWQgc2V0IG9mIGNoYXJhY3RlcnMsIGFsbCBvZiB3aGljaCBzaG91bGQgYmUgMSBieXRlLlxuICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pXG4gICkubGVuZ3RoO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRUeXBlIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIH0gZnJvbSAnLi9wbGF0Zm9ybUxvZ2dlclNlcnZpY2UnO1xuaW1wb3J0IHsgbmFtZSwgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBfcmVnaXN0ZXJDb21wb25lbnQgfSBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCB7IHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEhlYXJ0YmVhdFNlcnZpY2VJbXBsIH0gZnJvbSAnLi9oZWFydGJlYXRTZXJ2aWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudD86IHN0cmluZyk6IHZvaWQge1xuICBfcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgbmV3IENvbXBvbmVudChcbiAgICAgICdwbGF0Zm9ybS1sb2dnZXInLFxuICAgICAgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksXG4gICAgICBDb21wb25lbnRUeXBlLlBSSVZBVEVcbiAgICApXG4gICk7XG4gIF9yZWdpc3RlckNvbXBvbmVudChcbiAgICBuZXcgQ29tcG9uZW50KFxuICAgICAgJ2hlYXJ0YmVhdCcsXG4gICAgICBjb250YWluZXIgPT4gbmV3IEhlYXJ0YmVhdFNlcnZpY2VJbXBsKGNvbnRhaW5lciksXG4gICAgICBDb21wb25lbnRUeXBlLlBSSVZBVEVcbiAgICApXG4gICk7XG5cbiAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cbiAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIHZhcmlhbnQpO1xuICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ19fQlVJTERfVEFSR0VUX18nKTtcbiAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxuICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XG59XG4iLCIvKipcbiAqIEZpcmViYXNlIEFwcFxuICpcbiAqIEByZW1hcmtzIFRoaXMgcGFja2FnZSBjb29yZGluYXRlcyB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgRmlyZWJhc2UgY29tcG9uZW50c1xuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyB9IGZyb20gJy4vcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vYXBpJztcbmV4cG9ydCAqIGZyb20gJy4vaW50ZXJuYWwnO1xuZXhwb3J0ICogZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCdfX1JVTlRJTUVfRU5WX18nKTtcbiJdLCJuYW1lcyI6WyJQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIiwiY29udGFpbmVyIiwicHJvdmlkZXJzIiwiZ2V0UHJvdmlkZXJzIiwibWFwIiwiaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyIiwicHJvdmlkZXIiLCJzZXJ2aWNlIiwiZ2V0SW1tZWRpYXRlIiwibGlicmFyeSIsInZlcnNpb24iLCJmaWx0ZXIiLCJsb2dTdHJpbmciLCJqb2luIiwiY29tcG9uZW50IiwiZ2V0Q29tcG9uZW50IiwidHlwZSIsImxvZ2dlciIsIkxvZ2dlciIsIkRFRkFVTFRfRU5UUllfTkFNRSIsIlBMQVRGT1JNX0xPR19TVFJJTkciLCJhcHBOYW1lIiwiYXBwQ29tcGF0TmFtZSIsImFuYWx5dGljc05hbWUiLCJhbmFseXRpY3NDb21wYXROYW1lIiwiYXBwQ2hlY2tOYW1lIiwiYXBwQ2hlY2tDb21wYXROYW1lIiwiYXV0aE5hbWUiLCJhdXRoQ29tcGF0TmFtZSIsImRhdGFiYXNlTmFtZSIsImRhdGFiYXNlQ29tcGF0TmFtZSIsImZ1bmN0aW9uc05hbWUiLCJmdW5jdGlvbnNDb21wYXROYW1lIiwiaW5zdGFsbGF0aW9uc05hbWUiLCJpbnN0YWxsYXRpb25zQ29tcGF0TmFtZSIsIm1lc3NhZ2luZ05hbWUiLCJtZXNzYWdpbmdDb21wYXROYW1lIiwicGVyZm9ybWFuY2VOYW1lIiwicGVyZm9ybWFuY2VDb21wYXROYW1lIiwicmVtb3RlQ29uZmlnTmFtZSIsInJlbW90ZUNvbmZpZ0NvbXBhdE5hbWUiLCJzdG9yYWdlTmFtZSIsInN0b3JhZ2VDb21wYXROYW1lIiwiZmlyZXN0b3JlTmFtZSIsImZpcmVzdG9yZUNvbXBhdE5hbWUiLCJwYWNrYWdlTmFtZSIsIk1hcCIsImFwcCIsImFkZENvbXBvbmVudCIsImUiLCJkZWJ1ZyIsIm5hbWUiLCJhZGRPck92ZXJ3cml0ZUNvbXBvbmVudCIsIl9yZWdpc3RlckNvbXBvbmVudCIsImNvbXBvbmVudE5hbWUiLCJfY29tcG9uZW50cyIsImhhcyIsInNldCIsIl9hcHBzIiwidmFsdWVzIiwiX2FkZENvbXBvbmVudCIsImhlYXJ0YmVhdENvbnRyb2xsZXIiLCJnZXRQcm92aWRlciIsIm9wdGlvbmFsIiwidHJpZ2dlckhlYXJ0YmVhdCIsIl9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJfZ2V0UHJvdmlkZXIiLCJjbGVhckluc3RhbmNlIiwiX2NsZWFyQ29tcG9uZW50cyIsImNsZWFyIiwiRVJST1JTIiwiRVJST1JfRkFDVE9SWSIsIkVycm9yRmFjdG9yeSIsIkZpcmViYXNlQXBwSW1wbCIsIm9wdGlvbnMiLCJjb25maWciLCJfb3B0aW9ucyIsIk9iamVjdCIsIl9jb25maWciLCJfbmFtZSIsIl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJfY29udGFpbmVyIiwiQ29tcG9uZW50IiwiY2hlY2tEZXN0cm95ZWQiLCJ2YWwiLCJfaXNEZWxldGVkIiwiaXNEZWxldGVkIiwiY3JlYXRlIiwiU0RLX1ZFUlNJT04iLCJpbml0aWFsaXplQXBwIiwicmF3Q29uZmlnIiwiU3RyaW5nIiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImV4aXN0aW5nQXBwIiwiZ2V0IiwiZGVlcEVxdWFsIiwiQ29tcG9uZW50Q29udGFpbmVyIiwibmV3QXBwIiwiZ2V0QXBwcyIsIkFycmF5IiwiZnJvbSIsImRlbGV0ZUFwcCIsIlByb21pc2UiLCJhbGwiLCJyZWdpc3RlclZlcnNpb24iLCJsaWJyYXJ5S2V5T3JOYW1lIiwidmFyaWFudCIsImxpYnJhcnlNaXNtYXRjaCIsIm1hdGNoIiwidmVyc2lvbk1pc21hdGNoIiwid2FybmluZyIsInB1c2giLCJ3YXJuIiwibG9nQ2FsbGJhY2siLCJzZXRVc2VyTG9nSGFuZGxlciIsInNldExvZ0xldmVsIiwibG9nTGV2ZWwiLCJzZXRMb2dMZXZlbEltcGwiLCJEQl9OQU1FIiwiREJfVkVSU0lPTiIsIlNUT1JFX05BTUUiLCJkYlByb21pc2UiLCJnZXREYlByb21pc2UiLCJvcGVuREIiLCJ1cGdyYWRlIiwiZGIiLCJvbGRWZXJzaW9uIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJvcmlnaW5hbEVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJyZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIiLCJ0cmFuc2FjdGlvbiIsIm9iamVjdFN0b3JlIiwiY29tcHV0ZUtleSIsIkZpcmViYXNlRXJyb3IiLCJpZGJHZXRFcnJvciIsIndyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCIiwiaGVhcnRiZWF0T2JqZWN0IiwidHgiLCJwdXQiLCJkb25lIiwiYXBwSWQiLCJNQVhfSEVBREVSX0JZVEVTIiwiU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyIsIkhlYXJ0YmVhdFNlcnZpY2VJbXBsIiwiX3N0b3JhZ2UiLCJIZWFydGJlYXRTdG9yYWdlSW1wbCIsIl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlIiwicmVhZCIsInRoZW4iLCJfaGVhcnRiZWF0c0NhY2hlIiwicmVzdWx0IiwicGxhdGZvcm1Mb2dnZXIiLCJhZ2VudCIsImdldFBsYXRmb3JtSW5mb1N0cmluZyIsImRhdGUiLCJnZXRVVENEYXRlU3RyaW5nIiwibGFzdFNlbnRIZWFydGJlYXREYXRlIiwiaGVhcnRiZWF0cyIsInNvbWUiLCJzaW5nbGVEYXRlSGVhcnRiZWF0IiwiaGJUaW1lc3RhbXAiLCJEYXRlIiwidmFsdWVPZiIsIm5vdyIsIm92ZXJ3cml0ZSIsImxlbmd0aCIsImV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyIiwiaGVhcnRiZWF0c1RvU2VuZCIsInVuc2VudEVudHJpZXMiLCJoZWFkZXJTdHJpbmciLCJiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b2RheSIsInRvSVNPU3RyaW5nIiwic3Vic3RyaW5nIiwiaGVhcnRiZWF0c0NhY2hlIiwibWF4U2l6ZSIsInNsaWNlIiwiaGVhcnRiZWF0RW50cnkiLCJmaW5kIiwiaGIiLCJkYXRlcyIsImNvdW50Qnl0ZXMiLCJwb3AiLCJfY2FuVXNlSW5kZXhlZERCUHJvbWlzZSIsInJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2siLCJpc0luZGV4ZWREQkF2YWlsYWJsZSIsInZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUiLCJjYW5Vc2VJbmRleGVkREIiLCJpZGJIZWFydGJlYXRPYmplY3QiLCJoZWFydGJlYXRzT2JqZWN0IiwiZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0IiwicmVnaXN0ZXJDb3JlQ29tcG9uZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"ComponentContainer\": () => (/* binding */ ComponentContainer),\n/* harmony export */   \"Provider\": () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.esm2017.js\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\nvar Component = /*#__PURE__*/function () {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  function Component(name, instanceFactory, type) {\n    _classCallCheck(this, Component);\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n    this.onInstanceCreated = null;\n  }\n  _createClass(Component, [{\n    key: \"setInstantiationMode\",\n    value: function setInstantiationMode(mode) {\n      this.instantiationMode = mode;\n      return this;\n    }\n  }, {\n    key: \"setMultipleInstances\",\n    value: function setMultipleInstances(multipleInstances) {\n      this.multipleInstances = multipleInstances;\n      return this;\n    }\n  }, {\n    key: \"setServiceProps\",\n    value: function setServiceProps(props) {\n      this.serviceProps = props;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCreatedCallback\",\n    value: function setInstanceCreatedCallback(callback) {\n      this.onInstanceCreated = callback;\n      return this;\n    }\n  }]);\n  return Component;\n}();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\nvar Provider = /*#__PURE__*/function () {\n  function Provider(name, container) {\n    _classCallCheck(this, Provider);\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n  _createClass(Provider, [{\n    key: \"get\",\n    value: function get(identifier) {\n      // if multipleInstances is not supported, use the default name\n      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n      if (!this.instancesDeferred.has(normalizedIdentifier)) {\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.instancesDeferred.set(normalizedIdentifier, deferred);\n        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n          // initialize the service if it can be auto-initialized\n          try {\n            var instance = this.getOrInitializeService({\n              instanceIdentifier: normalizedIdentifier\n            });\n            if (instance) {\n              deferred.resolve(instance);\n            }\n          } catch (e) {\n            // when the instance factory throws an exception during get(), it should not cause\n            // a fatal error. We just return the unresolved promise in this case.\n          }\n        }\n      }\n      return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n  }, {\n    key: \"getImmediate\",\n    value: function getImmediate(options) {\n      var _a;\n      // if multipleInstances is not supported, use the default name\n      var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n      var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        try {\n          return this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n        } catch (e) {\n          if (optional) {\n            return null;\n          } else {\n            throw e;\n          }\n        }\n      } else {\n        // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n        if (optional) {\n          return null;\n        } else {\n          throw Error(\"Service \".concat(this.name, \" is not available\"));\n        }\n      }\n    }\n  }, {\n    key: \"getComponent\",\n    value: function getComponent() {\n      return this.component;\n    }\n  }, {\n    key: \"setComponent\",\n    value: function setComponent(component) {\n      if (component.name !== this.name) {\n        throw Error(\"Mismatching Component \".concat(component.name, \" for Provider \").concat(this.name, \".\"));\n      }\n      if (this.component) {\n        throw Error(\"Component for \".concat(this.name, \" has already been provided\"));\n      }\n      this.component = component;\n      // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n      if (!this.shouldAutoInitialize()) {\n        return;\n      }\n      // if the service is eager, initialize the default instance\n      if (isComponentEager(component)) {\n        try {\n          this.getOrInitializeService({\n            instanceIdentifier: DEFAULT_ENTRY_NAME\n          });\n        } catch (e) {\n          // when the instance factory for an eager Component throws an exception during the eager\n          // initialization, it should not cause a fatal error.\n          // TODO: Investigate if we need to make it configurable, because some component may want to cause\n          // a fatal error in this case?\n        }\n      }\n      // Create service instances for the pending promises and resolve them\n      // NOTE: if this.multipleInstances is false, only the default instance will be created\n      // and all promises with resolve with it regardless of the identifier.\n      var _iterator = _createForOfIteratorHelper(this.instancesDeferred.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            instanceIdentifier = _step$value[0],\n            instanceDeferred = _step$value[1];\n          var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n          try {\n            // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n            var instance = this.getOrInitializeService({\n              instanceIdentifier: normalizedIdentifier\n            });\n            instanceDeferred.resolve(instance);\n          } catch (e) {\n            // when the instance factory throws an exception, it should not cause\n            // a fatal error. We just leave the promise unresolved.\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"clearInstance\",\n    value: function clearInstance() {\n      var identifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENTRY_NAME;\n      this.instancesDeferred[\"delete\"](identifier);\n      this.instancesOptions[\"delete\"](identifier);\n      this.instances[\"delete\"](identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var services;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                services = Array.from(this.instances.values());\n                _context.next = 3;\n                return Promise.all([].concat(_toConsumableArray(services.filter(function (service) {\n                  return 'INTERNAL' in service;\n                }) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(function (service) {\n                  return service.INTERNAL[\"delete\"]();\n                })), _toConsumableArray(services.filter(function (service) {\n                  return '_delete' in service;\n                }) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(function (service) {\n                  return service._delete();\n                }))));\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n  }, {\n    key: \"isComponentSet\",\n    value: function isComponentSet() {\n      return this.component != null;\n    }\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      var identifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENTRY_NAME;\n      return this.instances.has(identifier);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var identifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENTRY_NAME;\n      return this.instancesOptions.get(identifier) || {};\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$options = opts.options,\n        options = _opts$options === void 0 ? {} : _opts$options;\n      var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n      if (this.isInitialized(normalizedIdentifier)) {\n        throw Error(\"\".concat(this.name, \"(\").concat(normalizedIdentifier, \") has already been initialized\"));\n      }\n      if (!this.isComponentSet()) {\n        throw Error(\"Component \".concat(this.name, \" has not been registered yet\"));\n      }\n      var instance = this.getOrInitializeService({\n        instanceIdentifier: normalizedIdentifier,\n        options: options\n      });\n      // resolve any pending promise waiting for the service instance\n      var _iterator2 = _createForOfIteratorHelper(this.instancesDeferred.entries()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            instanceIdentifier = _step2$value[0],\n            instanceDeferred = _step2$value[1];\n          var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n          if (normalizedIdentifier === normalizedDeferredIdentifier) {\n            instanceDeferred.resolve(instance);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return instance;\n    }\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\n  }, {\n    key: \"onInit\",\n    value: function onInit(callback, identifier) {\n      var _a;\n      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n      var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n      existingCallbacks.add(callback);\n      this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n      var existingInstance = this.instances.get(normalizedIdentifier);\n      if (existingInstance) {\n        callback(existingInstance, normalizedIdentifier);\n      }\n      return function () {\n        existingCallbacks[\"delete\"](callback);\n      };\n    }\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\n  }, {\n    key: \"invokeOnInitCallbacks\",\n    value: function invokeOnInitCallbacks(instance, identifier) {\n      var callbacks = this.onInitCallbacks.get(identifier);\n      if (!callbacks) {\n        return;\n      }\n      var _iterator3 = _createForOfIteratorHelper(callbacks),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var callback = _step3.value;\n          try {\n            callback(instance, identifier);\n          } catch (_a) {\n            // ignore errors in the onInit callback\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"getOrInitializeService\",\n    value: function getOrInitializeService(_ref) {\n      var instanceIdentifier = _ref.instanceIdentifier,\n        _ref$options = _ref.options,\n        options = _ref$options === void 0 ? {} : _ref$options;\n      var instance = this.instances.get(instanceIdentifier);\n      if (!instance && this.component) {\n        instance = this.component.instanceFactory(this.container, {\n          instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n          options: options\n        });\n        this.instances.set(instanceIdentifier, instance);\n        this.instancesOptions.set(instanceIdentifier, options);\n        /**\r\n         * Invoke onInit listeners.\r\n         * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n         * while onInit listeners are registered by consumers of the provider.\r\n         */\n        this.invokeOnInitCallbacks(instance, instanceIdentifier);\n        /**\r\n         * Order is important\r\n         * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n         * makes `isInitialized()` return true.\r\n         */\n        if (this.component.onInstanceCreated) {\n          try {\n            this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n          } catch (_a) {\n            // ignore errors in the onInstanceCreatedCallback\n          }\n        }\n      }\n      return instance || null;\n    }\n  }, {\n    key: \"normalizeInstanceIdentifier\",\n    value: function normalizeInstanceIdentifier() {\n      var identifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENTRY_NAME;\n      if (this.component) {\n        return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n      } else {\n        return identifier; // assume multiple instances are supported before the component is provided.\n      }\n    }\n  }, {\n    key: \"shouldAutoInitialize\",\n    value: function shouldAutoInitialize() {\n      return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */;\n    }\n  }]);\n  return Provider;\n}(); // undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\nvar ComponentContainer = /*#__PURE__*/function () {\n  function ComponentContainer(name) {\n    _classCallCheck(this, ComponentContainer);\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n  _createClass(ComponentContainer, [{\n    key: \"addComponent\",\n    value: function addComponent(component) {\n      var provider = this.getProvider(component.name);\n      if (provider.isComponentSet()) {\n        throw new Error(\"Component \".concat(component.name, \" has already been registered with \").concat(this.name));\n      }\n      provider.setComponent(component);\n    }\n  }, {\n    key: \"addOrOverwriteComponent\",\n    value: function addOrOverwriteComponent(component) {\n      var provider = this.getProvider(component.name);\n      if (provider.isComponentSet()) {\n        // delete the existing provider from the container, so we can register the new component\n        this.providers[\"delete\"](component.name);\n      }\n      this.addComponent(component);\n    }\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\n  }, {\n    key: \"getProvider\",\n    value: function getProvider(name) {\n      if (this.providers.has(name)) {\n        return this.providers.get(name);\n      }\n      // create a Provider for a service that hasn't registered with Firebase\n      var provider = new Provider(name, this);\n      this.providers.set(name, provider);\n      return provider;\n    }\n  }, {\n    key: \"getProviders\",\n    value: function getProviders() {\n      return Array.from(this.providers.values());\n    }\n  }]);\n  return ComponentContainer;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOztBQUVHO0FBRkgsSUFHYUEsU0FBUztFQVdwQjs7Ozs7QUFLRztFQUNILG1CQUNXQyxJQUFPLEVBQ1BDLGVBQW1DLEVBQ25DQyxJQUFtQjtJQUFBO0lBRm5CLElBQUksUUFBSkYsSUFBSTtJQUNKLElBQWUsbUJBQWZDLGVBQWU7SUFDZixJQUFJLFFBQUpDLElBQUk7SUFuQmYsSUFBaUIscUJBQUcsS0FBSztJQUN6Qjs7QUFFRztJQUNILElBQVksZ0JBQWUsRUFBRTtJQUU3QixzQkFBaUIsR0FBMEI7SUFFM0MsSUFBaUIscUJBQXdDLElBQUk7O0VBWXpEO0lBQUE7SUFBQSxPQUVKLDhCQUFxQkMsSUFBdUI7TUFDMUMsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0QsSUFBSTtNQUM3QixPQUFPLElBQUk7O0VBQ1o7SUFBQTtJQUFBLE9BRUQsOEJBQXFCRSxpQkFBMEI7TUFDN0MsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR0EsaUJBQWlCO01BQzFDLE9BQU8sSUFBSTs7RUFDWjtJQUFBO0lBQUEsT0FFRCx5QkFBZ0JDLEtBQWlCO01BQy9CLElBQUksQ0FBQ0MsWUFBWSxHQUFHRCxLQUFLO01BQ3pCLE9BQU8sSUFBSTs7RUFDWjtJQUFBO0lBQUEsT0FFRCxvQ0FBMkJFLFFBQXNDO01BQy9ELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdELFFBQVE7TUFDakMsT0FBTyxJQUFJOztFQUNaO0VBQUE7QUFBQTtBQ3JFSDs7Ozs7Ozs7Ozs7Ozs7O0FBZUc7QUFFSSxJQUFNRSxrQkFBa0IsR0FBRyxXQUFXOztBQ2pCN0M7Ozs7Ozs7Ozs7Ozs7OztBQWVHO0FBY0g7OztBQUdHO0FBSEgsSUFJYUMsUUFBUTtFQVduQixrQkFDbUJYLElBQU8sRUFDUFksU0FBNkI7SUFBQTtJQUQ3QixJQUFJLFFB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QUFJLENBQUMsSUFBSSxDQUFDMEIsU0FBUyxDQUFDekIsTUFBTSxFQUFFLENBQUM7O0VBQzNDO0VBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi4vLi4vc3JjL2NvbXBvbmVudC50cz8wMjZlIiwid2VicGFjazovL2xpYnJhcnkvLi4vLi4vc3JjL2NvbnN0YW50cy50cz9kYTI2Iiwid2VicGFjazovL2xpYnJhcnkvLi4vLi4vc3JjL3Byb3ZpZGVyLnRzPzhkZDEiLCJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9zcmMvY29tcG9uZW50X2NvbnRhaW5lci50cz9mZjRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQge1xuICBJbnN0YW50aWF0aW9uTW9kZSxcbiAgSW5zdGFuY2VGYWN0b3J5LFxuICBDb21wb25lbnRUeXBlLFxuICBEaWN0aW9uYXJ5LFxuICBOYW1lLFxuICBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudDxUIGV4dGVuZHMgTmFtZSA9IE5hbWU+IHtcbiAgbXVsdGlwbGVJbnN0YW5jZXMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZpY2UgbmFtZXNwYWNlXG4gICAqL1xuICBzZXJ2aWNlUHJvcHM6IERpY3Rpb25hcnkgPSB7fTtcblxuICBpbnN0YW50aWF0aW9uTW9kZSA9IEluc3RhbnRpYXRpb25Nb2RlLkxBWlk7XG5cbiAgb25JbnN0YW5jZUNyZWF0ZWQ6IG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2s8VD4gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXG4gICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxuICAgKiBAcGFyYW0gdHlwZSB3aGV0aGVyIHRoZSBzZXJ2aWNlIHByb3ZpZGVkIGJ5IHRoZSBjb21wb25lbnQgaXMgcHVibGljIG9yIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IG5hbWU6IFQsXG4gICAgcmVhZG9ubHkgaW5zdGFuY2VGYWN0b3J5OiBJbnN0YW5jZUZhY3Rvcnk8VD4sXG4gICAgcmVhZG9ubHkgdHlwZTogQ29tcG9uZW50VHlwZVxuICApIHt9XG5cbiAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZTogSW5zdGFudGlhdGlvbk1vZGUpOiB0aGlzIHtcbiAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gbW9kZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE11bHRpcGxlSW5zdGFuY2VzKG11bHRpcGxlSW5zdGFuY2VzOiBib29sZWFuKTogdGhpcyB7XG4gICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U2VydmljZVByb3BzKHByb3BzOiBEaWN0aW9uYXJ5KTogdGhpcyB7XG4gICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSBwcm9wcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrOiBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrPFQ+KTogdGhpcyB7XG4gICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJy4vY29tcG9uZW50X2NvbnRhaW5lcic7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBJbml0aWFsaXplT3B0aW9ucyxcbiAgSW5zdGFudGlhdGlvbk1vZGUsXG4gIE5hbWUsXG4gIE5hbWVTZXJ2aWNlTWFwcGluZyxcbiAgT25Jbml0Q2FsbEJhY2tcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGluc3RhbmNlIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiAnYXV0aCcsICdhdXRoLWludGVybmFsJ1xuICogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIGlzIGFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFByb3ZpZGVyPFQgZXh0ZW5kcyBOYW1lPiB7XG4gIHByaXZhdGUgY29tcG9uZW50OiBDb21wb25lbnQ8VD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBpbnN0YW5jZXM6IE1hcDxzdHJpbmcsIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW5zdGFuY2VzRGVmZXJyZWQ6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgRGVmZXJyZWQ8TmFtZVNlcnZpY2VNYXBwaW5nW1RdPlxuICA+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IGluc3RhbmNlc09wdGlvbnM6IE1hcDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9XG4gICAgbmV3IE1hcCgpO1xuICBwcml2YXRlIG9uSW5pdENhbGxiYWNrczogTWFwPHN0cmluZywgU2V0PE9uSW5pdENhbGxCYWNrPFQ+Pj4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBULFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bGl0cGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcbiAgICogaWYgdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgaXMgdHJ1ZS5cbiAgICovXG4gIGdldChpZGVudGlmaWVyPzogc3RyaW5nKTogUHJvbWlzZTxOYW1lU2VydmljZU1hcHBpbmdbVF0+IHtcbiAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG5cbiAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQ8TmFtZVNlcnZpY2VNYXBwaW5nW1RdPigpO1xuICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNlcnZpY2UgaWYgaXQgY2FuIGJlIGF1dG8taW5pdGlhbGl6ZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIGdldCgpLCBpdCBzaG91bGQgbm90IGNhdXNlXG4gICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCByZXR1cm4gdGhlIHVucmVzb2x2ZWQgcHJvbWlzZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpIS5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXG4gICAqIGlmIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzIGlzIHRydWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLm9wdGlvbmFsIElmIG9wdGlvbmFsIGlzIGZhbHNlIG9yIG5vdCBwcm92aWRlZCwgdGhlIG1ldGhvZCB0aHJvd3MgYW4gZXJyb3Igd2hlblxuICAgKiB0aGUgc2VydmljZSBpcyBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICAgKiBJZiBvcHRpb25hbCBpcyB0cnVlLCB0aGUgbWV0aG9kIHJldHVybnMgbnVsbCBpZiB0aGUgc2VydmljZSBpcyBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0SW1tZWRpYXRlKG9wdGlvbnM6IHtcbiAgICBpZGVudGlmaWVyPzogc3RyaW5nO1xuICAgIG9wdGlvbmFsOiB0cnVlO1xuICB9KTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIHwgbnVsbDtcbiAgZ2V0SW1tZWRpYXRlKG9wdGlvbnM/OiB7XG4gICAgaWRlbnRpZmllcj86IHN0cmluZztcbiAgICBvcHRpb25hbD86IGZhbHNlO1xuICB9KTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdO1xuICBnZXRJbW1lZGlhdGUob3B0aW9ucz86IHtcbiAgICBpZGVudGlmaWVyPzogc3RyaW5nO1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgfSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSB8IG51bGwge1xuICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihcbiAgICAgIG9wdGlvbnM/LmlkZW50aWZpZXJcbiAgICApO1xuICAgIGNvbnN0IG9wdGlvbmFsID0gb3B0aW9ucz8ub3B0aW9uYWwgPz8gZmFsc2U7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKClcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gY2FzZSBhIGNvbXBvbmVudCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIHNob3VsZC9jYW4gbm90IGJlIGF1dG8taW5pdGlhbGl6ZWQgYXQgdGhlIG1vbWVudCwgcmV0dXJuIG51bGwgaWYgdGhlIG9wdGlvbmFsIGZsYWcgaXMgc2V0LCBvciB0aHJvd1xuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRDb21wb25lbnQoKTogQ29tcG9uZW50PFQ+IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xuICB9XG5cbiAgc2V0Q29tcG9uZW50KGNvbXBvbmVudDogQ29tcG9uZW50PFQ+KTogdm9pZCB7XG4gICAgaWYgKGNvbXBvbmVudC5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgTWlzbWF0Y2hpbmcgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZvciBQcm92aWRlciAke3RoaXMubmFtZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cbiAgICAvLyByZXR1cm4gZWFybHkgd2l0aG91dCBhdHRlbXB0aW5nIHRvIGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBpZiB0aGUgY29tcG9uZW50IHJlcXVpcmVzIGV4cGxpY2l0IGluaXRpYWxpemF0aW9uIChjYWxsaW5nIGBQcm92aWRlci5pbml0aWFsaXplKClgKVxuICAgIGlmICghdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHNlcnZpY2UgaXMgZWFnZXIsIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbiAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXI6IERFRkFVTFRfRU5UUllfTkFNRSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSBmb3IgYW4gZWFnZXIgQ29tcG9uZW50IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIHRoZSBlYWdlclxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxuICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXG4gICAgICAgIC8vIGEgZmF0YWwgZXJyb3IgaW4gdGhpcyBjYXNlP1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlcyBmb3IgdGhlIHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlc29sdmUgdGhlbVxuICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAgLy8gYW5kIGFsbCBwcm9taXNlcyB3aXRoIHJlc29sdmUgd2l0aCBpdCByZWdhcmRsZXNzIG9mIHRoZSBpZGVudGlmaWVyLlxuICAgIGZvciAoY29uc3QgW1xuICAgICAgaW5zdGFuY2VJZGVudGlmaWVyLFxuICAgICAgaW5zdGFuY2VEZWZlcnJlZFxuICAgIF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID1cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gYGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoKWAgc2hvdWxkIGFsd2F5cyByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBzaW5jZSBhIGNvbXBvbmVudCBpcyBndWFyYW50ZWVkLiB1c2UgISB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHkuXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgIH0pITtcbiAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlXG4gICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgbGVhdmUgdGhlIHByb21pc2UgdW5yZXNvbHZlZC5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhckluc3RhbmNlKGlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRSk6IHZvaWQge1xuICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgdGhpcy5pbnN0YW5jZXMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgLy8gYXBwLmRlbGV0ZSgpIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBvbiBldmVyeSBwcm92aWRlciB0byBkZWxldGUgdGhlIHNlcnZpY2VzXG4gIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xuICBhc3luYyBkZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnSU5URVJOQUwnIGluIHNlcnZpY2UpIC8vIGxlZ2FjeSBzZXJ2aWNlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAubWFwKHNlcnZpY2UgPT4gKHNlcnZpY2UgYXMgYW55KS5JTlRFUk5BTCEuZGVsZXRlKCkpLFxuICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAubWFwKHNlcnZpY2UgPT4gKHNlcnZpY2UgYXMgYW55KS5fZGVsZXRlKCkpXG4gICAgXSk7XG4gIH1cblxuICBpc0NvbXBvbmVudFNldCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQgIT0gbnVsbDtcbiAgfVxuXG4gIGlzSW5pdGlhbGl6ZWQoaWRlbnRpZmllcjogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcbiAgfVxuXG4gIGdldE9wdGlvbnMoaWRlbnRpZmllcjogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHRzOiBJbml0aWFsaXplT3B0aW9ucyA9IHt9KTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcbiAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKFxuICAgICAgb3B0cy5pbnN0YW5jZUlkZW50aWZpZXJcbiAgICApO1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYCR7dGhpcy5uYW1lfSgke25vcm1hbGl6ZWRJZGVudGlmaWVyfSkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXG4gICAgICBvcHRpb25zXG4gICAgfSkhO1xuXG4gICAgLy8gcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgZm9yIChjb25zdCBbXG4gICAgICBpbnN0YW5jZUlkZW50aWZpZXIsXG4gICAgICBpbnN0YW5jZURlZmVycmVkXG4gICAgXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9XG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcbiAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxuICAgKiBUaGUgZnVuY3Rpb24gaXMgaW52b2tlZCBTWU5DSFJPTk9VU0xZLCBzbyBpdCBzaG91bGQgbm90IGV4ZWN1dGUgYW55IGxvbmdydW5uaW5nIHRhc2tzIGluIG9yZGVyIHRvIG5vdCBibG9jayB0aGUgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBvbkluaXQoY2FsbGJhY2s6IE9uSW5pdENhbGxCYWNrPFQ+LCBpZGVudGlmaWVyPzogc3RyaW5nKTogKCkgPT4gdm9pZCB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9XG4gICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpID8/XG4gICAgICBuZXcgU2V0PE9uSW5pdENhbGxCYWNrPFQ+PigpO1xuICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgdGhpcy5vbkluaXRDYWxsYmFja3Muc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBleGlzdGluZ0NhbGxiYWNrcyk7XG5cbiAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcbiAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSkge1xuICAgICAgY2FsbGJhY2soZXhpc3RpbmdJbnN0YW5jZSwgbm9ybWFsaXplZElkZW50aWZpZXIpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBleGlzdGluZ0NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIG9uSW5pdCBjYWxsYmFja3Mgc3luY2hyb25vdXNseVxuICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXG4gICAqL1xuICBwcml2YXRlIGludm9rZU9uSW5pdENhbGxiYWNrcyhcbiAgICBpbnN0YW5jZTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdLFxuICAgIGlkZW50aWZpZXI6IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQoaWRlbnRpZmllcik7XG4gICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCBpZGVudGlmaWVyKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgIGluc3RhbmNlSWRlbnRpZmllcixcbiAgICBvcHRpb25zID0ge31cbiAgfToge1xuICAgIGluc3RhbmNlSWRlbnRpZmllcjogc3RyaW5nO1xuICAgIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSB8IG51bGwge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgIGlmICghaW5zdGFuY2UgJiYgdGhpcy5jb21wb25lbnQpIHtcbiAgICAgIGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2VGYWN0b3J5KHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaW5zdGFuY2VJZGVudGlmaWVyKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogSW52b2tlIG9uSW5pdCBsaXN0ZW5lcnMuXG4gICAgICAgKiBOb3RlIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkIGlzIGRpZmZlcmVudCwgd2hpY2ggaXMgdXNlZCBieSB0aGUgY29tcG9uZW50IGNyZWF0b3IsXG4gICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpbnN0YW5jZUlkZW50aWZpZXIpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxuICAgICAgICogb25JbnN0YW5jZUNyZWF0ZWQoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTsgd2hpY2hcbiAgICAgICAqIG1ha2VzIGBpc0luaXRpYWxpemVkKClgIHJldHVybiB0cnVlLlxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZChcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2UgfHwgbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKFxuICAgIGlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRVxuICApOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNob3VsZEF1dG9Jbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAhIXRoaXMuY29tcG9uZW50ICYmXG4gICAgICB0aGlzLmNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSAhPT0gSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVRcbiAgICApO1xuICB9XG59XG5cbi8vIHVuZGVmaW5lZCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBzZXJ2aWNlIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IGluc3RhbmNlXG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpZGVudGlmaWVyOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcbn1cblxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcjxUIGV4dGVuZHMgTmFtZT4oY29tcG9uZW50OiBDb21wb25lbnQ8VD4pOiBib29sZWFuIHtcbiAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gSW5zdGFudGlhdGlvbk1vZGUuRUFHRVI7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgTmFtZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENvbXBvbmVudENvbnRhaW5lciB0aGF0IHByb3ZpZGVzIFByb3ZpZGVycyBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJzID0gbmV3IE1hcDxzdHJpbmcsIFByb3ZpZGVyPE5hbWU+PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbmFtZTogc3RyaW5nKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxuICAgKiBAcGFyYW0gb3ZlcndyaXRlIFdoZW4gYSBjb21wb25lbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCxcbiAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xuICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcbiAgICogZm9yIGRpZmZlcmVudCB0ZXN0cy5cbiAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cbiAgICovXG4gIGFkZENvbXBvbmVudDxUIGV4dGVuZHMgTmFtZT4oY29tcG9uZW50OiBDb21wb25lbnQ8VD4pOiB2b2lkIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm92aWRlci5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfVxuXG4gIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBOYW1lPihjb21wb25lbnQ6IENvbXBvbmVudDxUPik6IHZvaWQge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XG4gICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgIC8vIGRlbGV0ZSB0aGUgZXhpc3RpbmcgcHJvdmlkZXIgZnJvbSB0aGUgY29udGFpbmVyLCBzbyB3ZSBjYW4gcmVnaXN0ZXIgdGhlIG5ldyBjb21wb25lbnRcbiAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXG4gICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cbiAgICpcbiAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXG4gICAqIHRoZW1zZWx2ZXMuXG4gICAqL1xuICBnZXRQcm92aWRlcjxUIGV4dGVuZHMgTmFtZT4obmFtZTogVCk6IFByb3ZpZGVyPFQ+IHtcbiAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpIGFzIHVua25vd24gYXMgUHJvdmlkZXI8VD47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQcm92aWRlcjxUPihuYW1lLCB0aGlzKTtcbiAgICB0aGlzLnByb3ZpZGVycy5zZXQobmFtZSwgcHJvdmlkZXIgYXMgdW5rbm93biBhcyBQcm92aWRlcjxOYW1lPik7XG5cbiAgICByZXR1cm4gcHJvdmlkZXIgYXMgUHJvdmlkZXI8VD47XG4gIH1cblxuICBnZXRQcm92aWRlcnMoKTogQXJyYXk8UHJvdmlkZXI8TmFtZT4+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJuYW1lIiwiaW5zdGFuY2VGYWN0b3J5IiwidHlwZSIsIm1vZGUiLCJpbnN0YW50aWF0aW9uTW9kZSIsIm11bHRpcGxlSW5zdGFuY2VzIiwicHJvcHMiLCJzZXJ2aWNlUHJvcHMiLCJjYWxsYmFjayIsIm9uSW5zdGFuY2VDcmVhdGVkIiwiREVGQVVMVF9FTlRSWV9OQU1FIiwiUHJvdmlkZXIiLCJjb250YWluZXIiLCJNYXAiLCJpZGVudGlmaWVyIiwibm9ybWFsaXplZElkZW50aWZpZXIiLCJub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIiLCJpbnN0YW5jZXNEZWZlcnJlZCIsImhhcyIsImRlZmVycmVkIiwiRGVmZXJyZWQiLCJzZXQiLCJpc0luaXRpYWxpemVkIiwic2hvdWxkQXV0b0luaXRpYWxpemUiLCJpbnN0YW5jZSIsImdldE9ySW5pdGlhbGl6ZVNlcnZpY2UiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJyZXNvbHZlIiwiZSIsImdldCIsInByb21pc2UiLCJvcHRpb25zIiwib3B0aW9uYWwiLCJFcnJvciIsImNvbXBvbmVudCIsImlzQ29tcG9uZW50RWFnZXIiLCJlbnRyaWVzIiwiaW5zdGFuY2VEZWZlcnJlZCIsImluc3RhbmNlc09wdGlvbnMiLCJpbnN0YW5jZXMiLCJzZXJ2aWNlcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsIlByb21pc2UiLCJhbGwiLCJmaWx0ZXIiLCJzZXJ2aWNlIiwibWFwIiwiSU5URVJOQUwiLCJfZGVsZXRlIiwib3B0cyIsImlzQ29tcG9uZW50U2V0Iiwibm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciIsImV4aXN0aW5nQ2FsbGJhY2tzIiwib25Jbml0Q2FsbGJhY2tzIiwiU2V0IiwiYWRkIiwiZXhpc3RpbmdJbnN0YW5jZSIsImNhbGxiYWNrcyIsIl9hIiwibm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkiLCJpbnZva2VPbkluaXRDYWxsYmFja3MiLCJ1bmRlZmluZWQiLCJDb21wb25lbnRDb250YWluZXIiLCJwcm92aWRlciIsImdldFByb3ZpZGVyIiwic2V0Q29tcG9uZW50IiwicHJvdmlkZXJzIiwiYWRkQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LogLevel\": () => (/* binding */ LogLevel),\n/* harmony export */   \"Logger\": () => (/* binding */ Logger),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel),\n/* harmony export */   \"setUserLogHandler\": () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\nvar _ConsoleMethod;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * A container for all of the Logger instances\r\n */\nvar instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n  LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n  LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nvar levelStringToEnum = {\n  'debug': LogLevel.DEBUG,\n  'verbose': LogLevel.VERBOSE,\n  'info': LogLevel.INFO,\n  'warn': LogLevel.WARN,\n  'error': LogLevel.ERROR,\n  'silent': LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */\nvar defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\nvar ConsoleMethod = (_ConsoleMethod = {}, _defineProperty(_ConsoleMethod, LogLevel.DEBUG, 'log'), _defineProperty(_ConsoleMethod, LogLevel.VERBOSE, 'log'), _defineProperty(_ConsoleMethod, LogLevel.INFO, 'info'), _defineProperty(_ConsoleMethod, LogLevel.WARN, 'warn'), _defineProperty(_ConsoleMethod, LogLevel.ERROR, 'error'), _ConsoleMethod);\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\nvar defaultLogHandler = function defaultLogHandler(instance, logType) {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  var now = new Date().toISOString();\n  var method = ConsoleMethod[logType];\n  if (method) {\n    var _console;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    (_console = console)[method].apply(_console, [\"[\".concat(now, \"]  \").concat(instance.name, \":\")].concat(args));\n  } else {\n    throw new Error(\"Attempted to log a message with an invalid logType (value: \".concat(logType, \")\"));\n  }\n};\nvar Logger = /*#__PURE__*/function () {\n  /**\r\n   * Gives you an instance of a Logger to capture messages according to\r\n   * Firebase's logging scheme.\r\n   *\r\n   * @param name The name that the logs will be associated with\r\n   */\n  function Logger(name) {\n    _classCallCheck(this, Logger);\n    this.name = name;\n    /**\r\n     * The log level of the given Logger instance.\r\n     */\n    this._logLevel = defaultLogLevel;\n    /**\r\n     * The main (internal) log handler for the Logger instance.\r\n     * Can be set to a new function in internal package code but not by user.\r\n     */\n    this._logHandler = defaultLogHandler;\n    /**\r\n     * The optional, additional, user-defined log handler for the Logger instance.\r\n     */\n    this._userLogHandler = null;\n    /**\r\n     * Capture the current instance for later use\r\n     */\n    instances.push(this);\n  }\n  _createClass(Logger, [{\n    key: \"logLevel\",\n    get: function get() {\n      return this._logLevel;\n    },\n    set: function set(val) {\n      if (!(val in LogLevel)) {\n        throw new TypeError(\"Invalid value \\\"\".concat(val, \"\\\" assigned to `logLevel`\"));\n      }\n      this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n  }, {\n    key: \"setLogLevel\",\n    value: function setLogLevel(val) {\n      this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n  }, {\n    key: \"logHandler\",\n    get: function get() {\n      return this._logHandler;\n    },\n    set: function set(val) {\n      if (typeof val !== 'function') {\n        throw new TypeError('Value assigned to `logHandler` must be a function');\n      }\n      this._logHandler = val;\n    }\n  }, {\n    key: \"userLogHandler\",\n    get: function get() {\n      return this._userLogHandler;\n    },\n    set: function set(val) {\n      this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.DEBUG].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.DEBUG].concat(args));\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.INFO].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.INFO].concat(args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.WARN].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.WARN].concat(args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.ERROR].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.ERROR].concat(args));\n    }\n  }]);\n  return Logger;\n}();\nfunction setLogLevel(level) {\n  instances.forEach(function (inst) {\n    inst.setLogLevel(level);\n  });\n}\nfunction setUserLogHandler(logCallback, options) {\n  var _iterator = _createForOfIteratorHelper(instances),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var instance = _step.value;\n      var customLogLevel = null;\n      if (options && options.level) {\n        customLogLevel = levelStringToEnum[options.level];\n      }\n      if (logCallback === null) {\n        instance.userLogHandler = null;\n      } else {\n        instance.userLogHandler = function (instance, level) {\n          for (var _len7 = arguments.length, args = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n            args[_key7 - 2] = arguments[_key7];\n          }\n          var message = args.map(function (arg) {\n            if (arg == null) {\n              return null;\n            } else if (typeof arg === 'string') {\n              return arg;\n            } else if (typeof arg === 'number' || typeof arg === 'boolean') {\n              return arg.toString();\n            } else if (arg instanceof Error) {\n              return arg.message;\n            } else {\n              try {\n                return JSON.stringify(arg);\n              } catch (ignored) {\n                return null;\n              }\n            }\n          }).filter(function (arg) {\n            return arg;\n          }).join(' ');\n          if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n            logCallback({\n              level: LogLevel[level].toLowerCase(),\n              message: message,\n              args: args,\n              type: instance.name\n            });\n          }\n        };\n      }\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFlRztBQXVCSDs7QUFFRztBQUNJLElBQU1BLFNBQVMsR0FBYSxFQUFFO0FBRXJDOzs7Ozs7Ozs7O0FBVUc7SUFDU0M7QUFBWixXQUFZQSxRQUFRO0VBQ2xCQSx5Q0FBSztFQUNMQSw2Q0FBTztFQUNQQSx1Q0FBSTtFQUNKQSx1Q0FBSTtFQUNKQSx5Q0FBSztFQUNMQSwyQ0FBTTtBQUNSLENBQUMsRUFQV0EsUUFBUSxLQUFSQSxRQUFRLEdBT25CO0FBRUQsSUFBTUMsaUJBQWlCLEdBQTBDO0VBQy9ELE9BQU8sRUFBRUQsUUFBUSxDQUFDRSxLQUFLO0VBQ3ZCLFNBQVMsRUFBRUYsUUFBUSxDQUFDRyxPQUFPO0VBQzNCLE1BQU0sRUFBRUgsUUFBUSxDQUFDSSxJQUFJO0VBQ3JCLE1BQU0sRUFBRUosUUFBUSxDQUFDSyxJQUFJO0VBQ3JCLE9BQU8sRUFBRUwsUUFBUSxDQUFDTSxLQUFLO0VBQ3ZCLFFBQVEsRUFBRU4sUUFBUSxDQUFDTztDQUNwQjtBQUVEOztBQUVHO0FBQ0gsSUFBTUMsZUFBZSxHQUFhUixRQUFRLENBQUNJLElBQUk7QUFhL0M7Ozs7O0FBS0c7QUFDSCxJQUFNSyxhQUFhLHlEQUNoQlQsUUFBUSxDQUFDRSxLQUFLLEVBQUcsS0FBSyxtQ0FDdEJGLFFBQVEsQ0FBQ0csT0FBTyxFQUFHLEtBQUssbUNBQ3hCSCxRQUFRLENBQUNJLElBQUksRUFBRyxNQUFNLG1DQUN0QkosUUFBUSxDQUFDSyxJQUFJLEVBQUcsTUFBTSxtQ0FDdEJMLFFBQVEsQ0FBQ00sS0FBSyxFQUFHLE9BQU8sa0JBQzFCO0FBRUQ7Ozs7QUFJRztBQUNILElBQU1JLGlCQUFpQixHQUFlLFNBQWhDQSxpQkFBaUIsQ0FBZ0JDLFFBQVEsRUFBRUMsT0FBTyxFQUFtQjtFQUN6RSxJQUFJQSxP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Q0UsUUFBUSxDQUFDLEVBQUU7WUFDbERtQixXQUFXLENBQUM7Y0FDVkgsS0FBSyxFQUFFN0IsUUFBUSxDQUFDNkIsS0FBSyxDQUFDLENBQUNnQixXQUFXLEVBQW9CO2NBQ3REVCxPQUFPLEVBQVBBLE9BQU87Y0FDUGxCLElBQUksRUFBSkEsSUFBSTtjQUNKNEIsSUFBSSxFQUFFbkMsUUFBUSxDQUFDUTtZQUNoQixFQUFDO1VBQ0g7UUFDSCxDQUFDO01BQ0Y7SUFBQTtJQTFDSCxvREFBa0M7TUFBQTtJQTJDakM7RUFBQTtJQUFBO0VBQUE7SUFBQTtFQUFBO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saWJyYXJ5Ly4uLy4uL3NyYy9sb2dnZXIudHM/ZjBiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgdHlwZSBMb2dMZXZlbFN0cmluZyA9XG4gIHwgJ2RlYnVnJ1xuICB8ICd2ZXJib3NlJ1xuICB8ICdpbmZvJ1xuICB8ICd3YXJuJ1xuICB8ICdlcnJvcidcbiAgfCAnc2lsZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBMb2dPcHRpb25zIHtcbiAgbGV2ZWw6IExvZ0xldmVsU3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBMb2dDYWxsYmFjayA9IChjYWxsYmFja1BhcmFtczogTG9nQ2FsbGJhY2tQYXJhbXMpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nQ2FsbGJhY2tQYXJhbXMge1xuICBsZXZlbDogTG9nTGV2ZWxTdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgYXJnczogdW5rbm93bltdO1xuICB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlc1xuICovXG5leHBvcnQgY29uc3QgaW5zdGFuY2VzOiBMb2dnZXJbXSA9IFtdO1xuXG4vKipcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cbiAqIHNpbGVuY2UgdGhlIGxvZ3MgYWx0b2dldGhlci5cbiAqXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxuICogREVCVUcgPCBWRVJCT1NFIDwgSU5GTyA8IFdBUk4gPCBFUlJPUlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYElORk9gLCBlcnJvcnMgd2lsbCBzdGlsbCBiZSBsb2dnZWQsIGJ1dCBgREVCVUdgIGFuZFxuICogYFZFUkJPU0VgIGxvZ3Mgd2lsbCBub3QpXG4gKi9cbmV4cG9ydCBlbnVtIExvZ0xldmVsIHtcbiAgREVCVUcsXG4gIFZFUkJPU0UsXG4gIElORk8sXG4gIFdBUk4sXG4gIEVSUk9SLFxuICBTSUxFTlRcbn1cblxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW06IHsgW2tleSBpbiBMb2dMZXZlbFN0cmluZ106IExvZ0xldmVsIH0gPSB7XG4gICdkZWJ1Zyc6IExvZ0xldmVsLkRFQlVHLFxuICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXG4gICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcbiAgJ3dhcm4nOiBMb2dMZXZlbC5XQVJOLFxuICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcbiAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWxcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0xldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk87XG5cbi8qKlxuICogV2UgYWxsb3cgdXNlcnMgdGhlIGFiaWxpdHkgdG8gcGFzcyB0aGVpciBvd24gbG9nIGhhbmRsZXIuIFdlIHdpbGwgcGFzcyB0aGVcbiAqIHR5cGUgb2YgbG9nLCB0aGUgY3VycmVudCBsb2cgbGV2ZWwsIGFuZCBhbnkgb3RoZXIgYXJndW1lbnRzIHBhc3NlZCAoaS5lLiB0aGVcbiAqIG1lc3NhZ2VzIHRoYXQgdGhlIHVzZXIgd2FudHMgdG8gbG9nKSB0byB0aGlzIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgdHlwZSBMb2dIYW5kbGVyID0gKFxuICBsb2dnZXJJbnN0YW5jZTogTG9nZ2VyLFxuICBsb2dUeXBlOiBMb2dMZXZlbCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXG4gKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxuICovXG5jb25zdCBDb25zb2xlTWV0aG9kID0ge1xuICBbTG9nTGV2ZWwuREVCVUddOiAnbG9nJyxcbiAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcbiAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXG4gIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxuICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBoYW5kbGVyIHdpbGwgZm9yd2FyZCBERUJVRywgVkVSQk9TRSwgSU5GTywgV0FSTiwgYW5kIEVSUk9SXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXI6IExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpOiB2b2lkID0+IHtcbiAgaWYgKGxvZ1R5cGUgPCBpbnN0YW5jZS5sb2dMZXZlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IG1ldGhvZCA9IENvbnNvbGVNZXRob2RbbG9nVHlwZSBhcyBrZXlvZiB0eXBlb2YgQ29uc29sZU1ldGhvZF07XG4gIGlmIChtZXRob2QpIHtcbiAgICBjb25zb2xlW21ldGhvZCBhcyAnbG9nJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvciddKFxuICAgICAgYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIGxvZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbnZhbGlkIGxvZ1R5cGUgKHZhbHVlOiAke2xvZ1R5cGV9KWBcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgLyoqXG4gICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xuICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmFtZTogc3RyaW5nKSB7XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXG4gICAgICovXG4gICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9nTGV2ZWwgPSBkZWZhdWx0TG9nTGV2ZWw7XG5cbiAgZ2V0IGxvZ0xldmVsKCk6IExvZ0xldmVsIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gIH1cblxuICBzZXQgbG9nTGV2ZWwodmFsOiBMb2dMZXZlbCkge1xuICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xuICAgIH1cbiAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXG4gIHNldExvZ0xldmVsKHZhbDogTG9nTGV2ZWwgfCBMb2dMZXZlbFN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAqIENhbiBiZSBzZXQgdG8gYSBuZXcgZnVuY3Rpb24gaW4gaW50ZXJuYWwgcGFja2FnZSBjb2RlIGJ1dCBub3QgYnkgdXNlci5cbiAgICovXG4gIHByaXZhdGUgX2xvZ0hhbmRsZXI6IExvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcbiAgZ2V0IGxvZ0hhbmRsZXIoKTogTG9nSGFuZGxlciB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XG4gIH1cbiAgc2V0IGxvZ0hhbmRsZXIodmFsOiBMb2dIYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGFzc2lnbmVkIHRvIGBsb2dIYW5kbGVyYCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nSGFuZGxlciA9IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICovXG4gIHByaXZhdGUgX3VzZXJMb2dIYW5kbGVyOiBMb2dIYW5kbGVyIHwgbnVsbCA9IG51bGw7XG4gIGdldCB1c2VyTG9nSGFuZGxlcigpOiBMb2dIYW5kbGVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xuICB9XG4gIHNldCB1c2VyTG9nSGFuZGxlcih2YWw6IExvZ0hhbmRsZXIgfCBudWxsKSB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSB2YWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYWxsIGJhc2VkIG9uIHRoZSBgY29uc29sZWAgaW50ZXJmYWNlXG4gICAqL1xuXG4gIGRlYnVnKC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgfVxuICBsb2coLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcbiAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XG4gIH1cbiAgaW5mbyguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xuICB9XG4gIHdhcm4oLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XG4gICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgfVxuICBlcnJvciguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsOiBMb2dMZXZlbFN0cmluZyB8IExvZ0xldmVsKTogdm9pZCB7XG4gIGluc3RhbmNlcy5mb3JFYWNoKGluc3QgPT4ge1xuICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFVzZXJMb2dIYW5kbGVyKFxuICBsb2dDYWxsYmFjazogTG9nQ2FsbGJhY2sgfCBudWxsLFxuICBvcHRpb25zPzogTG9nT3B0aW9uc1xuKTogdm9pZCB7XG4gIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgbGV0IGN1c3RvbUxvZ0xldmVsOiBMb2dMZXZlbCB8IG51bGwgPSBudWxsO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgIGN1c3RvbUxvZ0xldmVsID0gbGV2ZWxTdHJpbmdUb0VudW1bb3B0aW9ucy5sZXZlbF07XG4gICAgfVxuICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IChcbiAgICAgICAgaW5zdGFuY2U6IExvZ2dlcixcbiAgICAgICAgbGV2ZWw6IExvZ0xldmVsLFxuICAgICAgICAuLi5hcmdzOiB1bmtub3duW11cbiAgICAgICkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXJnc1xuICAgICAgICAgIC5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXG4gICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgaWYgKGxldmVsID49IChjdXN0b21Mb2dMZXZlbCA/PyBpbnN0YW5jZS5sb2dMZXZlbCkpIHtcbiAgICAgICAgICBsb2dDYWxsYmFjayh7XG4gICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCkgYXMgTG9nTGV2ZWxTdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbnN0YW5jZXMiLCJMb2dMZXZlbCIsImxldmVsU3RyaW5nVG9FbnVtIiwiREVCVUciLCJWRVJCT1NFIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsIlNJTEVOVCIsImRlZmF1bHRMb2dMZXZlbCIsIkNvbnNvbGVNZXRob2QiLCJkZWZhdWx0TG9nSGFuZGxlciIsImluc3RhbmNlIiwibG9nVHlwZSIsImxvZ0xldmVsIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibWV0aG9kIiwiYXJncyIsIm5hbWUiLCJFcnJvciIsIkxvZ2dlciIsInB1c2giLCJfbG9nTGV2ZWwiLCJ2YWwiLCJUeXBlRXJyb3IiLCJfbG9nSGFuZGxlciIsIl91c2VyTG9nSGFuZGxlciIsInNldExvZ0xldmVsIiwibGV2ZWwiLCJmb3JFYWNoIiwiaW5zdCIsImxvZ0NhbGxiYWNrIiwib3B0aW9ucyIsImN1c3RvbUxvZ0xldmVsIiwidXNlckxvZ0hhbmRsZXIiLCJtZXNzYWdlIiwibWFwIiwiYXJnIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiaWdub3JlZCIsImZpbHRlciIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "./node_modules/firebase/app/dist/esm/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/firebase/app/dist/esm/index.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FirebaseError\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.FirebaseError),\n/* harmony export */   \"SDK_VERSION\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION),\n/* harmony export */   \"_DEFAULT_ENTRY_NAME\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._DEFAULT_ENTRY_NAME),\n/* harmony export */   \"_addComponent\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addComponent),\n/* harmony export */   \"_addOrOverwriteComponent\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addOrOverwriteComponent),\n/* harmony export */   \"_apps\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._apps),\n/* harmony export */   \"_clearComponents\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._clearComponents),\n/* harmony export */   \"_components\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._components),\n/* harmony export */   \"_getProvider\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider),\n/* harmony export */   \"_registerComponent\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent),\n/* harmony export */   \"_removeServiceInstance\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance),\n/* harmony export */   \"deleteApp\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.deleteApp),\n/* harmony export */   \"getApp\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp),\n/* harmony export */   \"getApps\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps),\n/* harmony export */   \"initializeApp\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp),\n/* harmony export */   \"onLog\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.onLog),\n/* harmony export */   \"registerVersion\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion),\n/* harmony export */   \"setLogLevel\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n\n\nvar name = \"firebase\";\nvar version = \"9.15.0\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'app');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUc7QUFJSEEsOERBQWUsQ0FBQ0MsSUFBSSxFQUFFQyxPQUFPLEVBQUUsS0FBSyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlicmFyeS8uLi8uLi9pbmRleC50cz80ZTRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IG5hbWUsIHZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuXG5yZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2FwcCcpO1xuZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2FwcCc7XG4iXSwibmFtZXMiOlsicmVnaXN0ZXJWZXJzaW9uIiwibmFtZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/firebase/app/dist/esm/index.esm.js\n");

/***/ }),

/***/ "./node_modules/firebase/firestore/lite/dist/esm/index.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/firebase/firestore/lite/dist/esm/index.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AggregateField": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.AggregateField),
/* harmony export */   "AggregateQuerySnapshot": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.AggregateQuerySnapshot),
/* harmony export */   "Bytes": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.Bytes),
/* harmony export */   "CollectionReference": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.CollectionReference),
/* harmony export */   "DocumentReference": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.DocumentReference),
/* harmony export */   "DocumentSnapshot": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.DocumentSnapshot),
/* harmony export */   "FieldPath": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.FieldPath),
/* harmony export */   "FieldValue": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.FieldValue),
/* harmony export */   "Firestore": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.Firestore),
/* harmony export */   "FirestoreError": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.FirestoreError),
/* harmony export */   "GeoPoint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.GeoPoint),
/* harmony export */   "Query": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.Query),
/* harmony export */   "QueryCompositeFilterConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryCompositeFilterConstraint),
/* harmony export */   "QueryConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryConstraint),
/* harmony export */   "QueryDocumentSnapshot": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryDocumentSnapshot),
/* harmony export */   "QueryEndAtConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryEndAtConstraint),
/* harmony export */   "QueryFieldFilterConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryFieldFilterConstraint),
/* harmony export */   "QueryLimitConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryLimitConstraint),
/* harmony export */   "QueryOrderByConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryOrderByConstraint),
/* harmony export */   "QuerySnapshot": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QuerySnapshot),
/* harmony export */   "QueryStartAtConstraint": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.QueryStartAtConstraint),
/* harmony export */   "Timestamp": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.Timestamp),
/* harmony export */   "Transaction": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.Transaction),
/* harmony export */   "WriteBatch": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.WriteBatch),
/* harmony export */   "addDoc": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.addDoc),
/* harmony export */   "aggregateQuerySnapshotEqual": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.aggregateQuerySnapshotEqual),
/* harmony export */   "and": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.and),
/* harmony export */   "arrayRemove": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.arrayRemove),
/* harmony export */   "arrayUnion": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.arrayUnion),
/* harmony export */   "collection": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.collection),
/* harmony export */   "collectionGroup": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.collectionGroup),
/* harmony export */   "connectFirestoreEmulator": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.connectFirestoreEmulator),
/* harmony export */   "deleteDoc": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.deleteDoc),
/* harmony export */   "deleteField": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.deleteField),
/* harmony export */   "doc": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.doc),
/* harmony export */   "documentId": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.documentId),
/* harmony export */   "endAt": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.endAt),
/* harmony export */   "endBefore": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.endBefore),
/* harmony export */   "getCount": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.getCount),
/* harmony export */   "getDoc": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.getDoc),
/* harmony export */   "getDocs": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.getDocs),
/* harmony export */   "getFirestore": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.getFirestore),
/* harmony export */   "increment": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.increment),
/* harmony export */   "initializeFirestore": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.initializeFirestore),
/* harmony export */   "limit": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.limit),
/* harmony export */   "limitToLast": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.limitToLast),
/* harmony export */   "or": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.or),
/* harmony export */   "orderBy": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.orderBy),
/* harmony export */   "query": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.query),
/* harmony export */   "queryEqual": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.queryEqual),
/* harmony export */   "refEqual": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.refEqual),
/* harmony export */   "runTransaction": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.runTransaction),
/* harmony export */   "serverTimestamp": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp),
/* harmony export */   "setDoc": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.setDoc),
/* harmony export */   "setLogLevel": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),
/* harmony export */   "snapshotEqual": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.snapshotEqual),
/* harmony export */   "startAfter": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.startAfter),
/* harmony export */   "startAt": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.startAt),
/* harmony export */   "terminate": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.terminate),
/* harmony export */   "updateDoc": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.updateDoc),
/* harmony export */   "where": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.where),
/* harmony export */   "writeBatch": () => (/* reexport safe */ _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__.writeBatch)
/* harmony export */ });
/* harmony import */ var _firebase_firestore_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/firestore/lite */ "./node_modules/@firebase/firestore/dist/lite/index.browser.esm2017.js");


/***/ }),

/***/ "./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deleteDB\": () => (/* binding */ deleteDB),\n/* harmony export */   \"openDB\": () => (/* binding */ openDB),\n/* harmony export */   \"unwrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   \"wrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"./node_modules/idb/build/wrap-idb-value.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    blocked = _ref.blocked,\n    upgrade = _ref.upgrade,\n    blocking = _ref.blocking,\n    terminated = _ref.terminated;\n  var request = indexedDB.open(name, version);\n  var openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', function (event) {\n      upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction));\n    });\n  }\n  if (blocked) request.addEventListener('blocked', function () {\n    return blocked();\n  });\n  openPromise.then(function (db) {\n    if (terminated) db.addEventListener('close', function () {\n      return terminated();\n    });\n    if (blocking) db.addEventListener('versionchange', function () {\n      return blocking();\n    });\n  })[\"catch\"](function () {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    blocked = _ref2.blocked;\n  var request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', function () {\n    return blocked();\n  });\n  return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(function () {\n    return undefined;\n  });\n}\nvar readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nvar writeMethods = ['put', 'add', 'delete', 'clear'];\nvar cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  var targetFuncName = prop.replace(/FromIndex$/, '');\n  var useIndex = prop !== targetFuncName;\n  var isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  var method = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(storeName) {\n      var _target;\n      var tx,\n        target,\n        _len,\n        args,\n        _key,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n              tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n              target = tx.store;\n              for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = _args[_key];\n              }\n              if (useIndex) target = target.index(args.shift());\n              // Must reject if op rejects.\n              // If it's a write operation, must reject if tx.done rejects.\n              // Must reject with op rejection first.\n              // Must resolve with op value.\n              // Must handle both promises (no unhandled rejections)\n              _context.next = 6;\n              return Promise.all([(_target = target)[targetFuncName].apply(_target, args), isWrite && tx.done]);\n            case 6:\n              return _context.abrupt(\"return\", _context.sent[0]);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n    return function method(_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  cachedMethods.set(prop, method);\n  return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)(function (oldTraps) {\n  return _objectSpread(_objectSpread({}, oldTraps), {}, {\n    get: function get(target, prop, receiver) {\n      return getMethod(target, prop) || oldTraps.get(target, prop, receiver);\n    },\n    has: function has(target, prop) {\n      return !!getMethod(target, prop) || oldTraps.has(target, prop);\n    }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUcsQ0FBQ3JCLElBQUksRUFBRVcsTUFBTSxDQUFDO0VBQy9CLE9BQU9BLE1BQU07QUFDakI7QUFDQTFDLHFEQUFZLENBQUMsVUFBQ3FELFFBQVE7RUFBQSx1Q0FDZkEsUUFBUTtJQUNYcEIsR0FBRyxFQUFFLGFBQUNILE1BQU0sRUFBRUMsSUFBSSxFQUFFdUIsUUFBUTtNQUFBLE9BQUt6QixTQUFTLENBQUNDLE1BQU0sRUFBRUMsSUFBSSxDQUFDLElBQUlzQixRQUFRLENBQUNwQixHQUFHLENBQUNILE1BQU0sRUFBRUMsSUFBSSxFQUFFdUIsUUFBUSxDQUFDO0lBQUE7SUFDaEdDLEdBQUcsRUFBRSxhQUFDekIsTUFBTSxFQUFFQyxJQUFJO01BQUEsT0FBSyxDQUFDLENBQUNGLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFQyxJQUFJLENBQUMsSUFBSXNCLFFBQVEsQ0FBQ0UsR0FBRyxDQUFDekIsTUFBTSxFQUFFQyxJQUFJLENBQUM7SUFBQTtFQUFBO0FBQUEsQ0FDaEYsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpYnJhcnkvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzPzFkMjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdyBhcyB3cmFwLCByIGFzIHJlcGxhY2VUcmFwcyB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuZXhwb3J0IHsgdSBhcyB1bndyYXAsIHcgYXMgd3JhcCB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuXG4vKipcbiAqIE9wZW4gYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIFNjaGVtYSB2ZXJzaW9uLlxuICogQHBhcmFtIGNhbGxiYWNrcyBBZGRpdGlvbmFsIGNhbGxiYWNrcy5cbiAqL1xuZnVuY3Rpb24gb3BlbkRCKG5hbWUsIHZlcnNpb24sIHsgYmxvY2tlZCwgdXBncmFkZSwgYmxvY2tpbmcsIHRlcm1pbmF0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIHZlcnNpb24pO1xuICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gd3JhcChyZXF1ZXN0KTtcbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcChyZXF1ZXN0LnJlc3VsdCksIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIHdyYXAocmVxdWVzdC50cmFuc2FjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsICgpID0+IGJsb2NrZWQoKSk7XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKCkgPT4gYmxvY2tpbmcoKSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsICgpID0+IGJsb2NrZWQoKSk7XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlciksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiAhIWdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmhhcyh0YXJnZXQsIHByb3ApLFxufSkpO1xuXG5leHBvcnQgeyBkZWxldGVEQiwgb3BlbkRCIH07XG4iXSwibmFtZXMiOlsidyIsIndyYXAiLCJyIiwicmVwbGFjZVRyYXBzIiwidSIsInVud3JhcCIsIm9wZW5EQiIsIm5hbWUiLCJ2ZXJzaW9uIiwiYmxvY2tlZCIsInVwZ3JhZGUiLCJibG9ja2luZyIsInRlcm1pbmF0ZWQiLCJyZXF1ZXN0IiwiaW5kZXhlZERCIiwib3BlbiIsIm9wZW5Qcm9taXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVzdWx0Iiwib2xkVmVyc2lvbiIsIm5ld1ZlcnNpb24iLCJ0cmFuc2FjdGlvbiIsInRoZW4iLCJkYiIsImRlbGV0ZURCIiwiZGVsZXRlRGF0YWJhc2UiLCJ1bmRlZmluZWQiLCJyZWFkTWV0aG9kcyIsIndyaXRlTWV0aG9kcyIsImNhY2hlZE1ldGhvZHMiLCJNYXAiLCJnZXRNZXRob2QiLCJ0YXJnZXQiLCJwcm9wIiwiSURCRGF0YWJhc2UiLCJnZXQiLCJ0YXJnZXRGdW5jTmFtZSIsInJlcGxhY2UiLCJ1c2VJbmRleCIsImlzV3JpdGUiLCJpbmNsdWRlcyIsIklEQkluZGV4IiwiSURCT2JqZWN0U3RvcmUiLCJwcm90b3R5cGUiLCJtZXRob2QiLCJzdG9yZU5hbWUiLCJ0eCIsInN0b3JlIiwiYXJncyIsImluZGV4Iiwic2hpZnQiLCJQcm9taXNlIiwiYWxsIiwiZG9uZSIsInNldCIsIm9sZFRyYXBzIiwicmVjZWl2ZXIiLCJoYXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/idb/build/index.js\n");

/***/ }),

/***/ "./node_modules/idb/build/wrap-idb-value.js":
/*!**************************************************!*\
  !*** ./node_modules/idb/build/wrap-idb-value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"a\": () => (/* binding */ reverseTransformCache),\n/* harmony export */   \"i\": () => (/* binding */ instanceOfAny),\n/* harmony export */   \"r\": () => (/* binding */ replaceTraps),\n/* harmony export */   \"u\": () => (/* binding */ unwrap),\n/* harmony export */   \"w\": () => (/* binding */ wrap)\n/* harmony export */ });\nvar instanceOfAny = function instanceOfAny(object, constructors) {\n  return constructors.some(function (c) {\n    return object instanceof c;\n  });\n};\nvar idbProxyableTypes;\nvar cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype[\"continue\"], IDBCursor.prototype.continuePrimaryKey]);\n}\nvar cursorRequestMap = new WeakMap();\nvar transactionDoneMap = new WeakMap();\nvar transactionStoreNamesMap = new WeakMap();\nvar transformCache = new WeakMap();\nvar reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  var promise = new Promise(function (resolve, reject) {\n    var unlisten = function unlisten() {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    var success = function success() {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    var error = function error() {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(function (value) {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n  })[\"catch\"](function () {});\n  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  var done = new Promise(function (resolve, reject) {\n    var unlisten = function unlisten() {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    var complete = function complete() {\n      resolve();\n      unlisten();\n    };\n    var error = function error() {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nvar idbProxyTraps = {\n  get: function get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Polyfill for objectStoreNames because of Edge.\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set: function set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has: function has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      var tx = func.call.apply(func, [unwrap(this), storeNames].concat(args));\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  var newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nvar unwrap = function unwrap(value) {\n  return reverseTransformCache.get(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsSUFBTUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFhLENBQUlDLE1BQU0sRUFBRUMsWUFBWTtFQUFBLE9BQUtBLFlBQVksQ0FBQ0MsSUFBSSxDQUFDLFVBQUNDLENBQUM7SUFBQSxPQUFLSCxNQUFNLFlBQVlHLENBQUM7RUFBQSxFQUFDO0FBQUE7QUFFN0YsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLG9CQUFvQjtBQUN4QjtBQUNBLFNBQVNDLG9CQUFvQixHQUFHO0VBQzVCLE9BQVFGLGlCQUFpQixLQUNwQkEsaUJBQWlCLEdBQUcsQ0FDakJHLFdBQVcsRUFDWEMsY0FBYyxFQUNkQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsY0FBYyxDQUNqQixDQUFDO0FBQ1Y7QUFDQTtBQUNBLFNBQVNDLHVCQUF1QixHQUFHO0VBQy9CLE9BQVFQLG9CQUFvQixLQUN2QkEsb0JBQW9CLEdBQUcsQ0FDcEJLLFNBQVMsQ0FBQ0csU0FBUyxDQUFDQyxPQUFPLEVBQzNCSixTQUFTLENBQUNHLFNBQVMsWUFBUyxFQUM1QkgsU0FBUyxDQUFDRyxTQUFTLENBQUNFLGtCQUFrQixDQUN6QyxDQUFDO0FBQ1Y7QUFDQSxJQUFNQyxnQkFBZ0IsR0FBRyxJQUFJQyxPQUFPLEVBQUU7QUFDdEMsSUFBTUMsa0JBQWtCLEdBQUcsSUFBSUQsT0FBTyxFQUFFO0FBQ3hDLElBQU1FLHdCQUF3QixHQUFHLElBQUlGLE9BQU8sRUFBRTtBQUM5QyxJQUFNRyxjQUFjLEdBQUcsSUFBSUgsT0FBTyxFQUFFO0FBQ3BDLElBQU1JLHFCQUFxQixHQUFHLElBQUlKLE9BQU8sRUFBRTtBQUMzQyxTQUFTSyxnQkFBZ0IsQ0FBQ0MsT0FBTyxFQUFFO0VBQy9CLElBQU1DLE9BQU8sR0FBRyxJQUFJQyxPQUFPLENBQUMsVUFBQ0MsT0FBTyxFQUFFQyxNQUFNLEVBQUs7SUFDN0MsSUFBTUMsUUFBUSxH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YSxDQUFDcUMsS0FBSyxFQUFFOUIsb0JBQW9CLEVBQUUsQ0FBQyxFQUM1QyxPQUFPLElBQUkyRCxLQUFLLENBQUM3QixLQUFLLEVBQUVRLGFBQWEsQ0FBQztFQUMxQztFQUNBLE9BQU9SLEtBQUs7QUFDaEI7QUFDQSxTQUFTSixJQUFJLENBQUNJLEtBQUssRUFBRTtFQUNqQjtFQUNBO0VBQ0EsSUFBSUEsS0FBSyxZQUFZOEIsVUFBVSxFQUMzQixPQUFPNUMsZ0JBQWdCLENBQUNjLEtBQUssQ0FBQztFQUNsQztFQUNBO0VBQ0EsSUFBSWhCLGNBQWMsQ0FBQ29CLEdBQUcsQ0FBQ0osS0FBSyxDQUFDLEVBQ3pCLE9BQU9oQixjQUFjLENBQUN5QixHQUFHLENBQUNULEtBQUssQ0FBQztFQUNwQyxJQUFNK0IsUUFBUSxHQUFHSCxzQkFBc0IsQ0FBQzVCLEtBQUssQ0FBQztFQUM5QztFQUNBO0VBQ0EsSUFBSStCLFFBQVEsS0FBSy9CLEtBQUssRUFBRTtJQUNwQmhCLGNBQWMsQ0FBQ2lCLEdBQUcsQ0FBQ0QsS0FBSyxFQUFFK0IsUUFBUSxDQUFDO0lBQ25DOUMscUJBQXFCLENBQUNnQixHQUFHLENBQUM4QixRQUFRLEVBQUUvQixLQUFLLENBQUM7RUFDOUM7RUFDQSxPQUFPK0IsUUFBUTtBQUNuQjtBQUNBLElBQU1QLE1BQU0sR0FBRyxTQUFUQSxNQUFNLENBQUl4QixLQUFLO0VBQUEsT0FBS2YscUJBQXFCLENBQUN3QixHQUFHLENBQUNULEtBQUssQ0FBQztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlicmFyeS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvd3JhcC1pZGItdmFsdWUuanM/NWMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbnN0YW5jZU9mQW55ID0gKG9iamVjdCwgY29uc3RydWN0b3JzKSA9PiBjb25zdHJ1Y3RvcnMuc29tZSgoYykgPT4gb2JqZWN0IGluc3RhbmNlb2YgYyk7XG5cbmxldCBpZGJQcm94eWFibGVUeXBlcztcbmxldCBjdXJzb3JBZHZhbmNlTWV0aG9kcztcbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSB7XG4gICAgcmV0dXJuIChpZGJQcm94eWFibGVUeXBlcyB8fFxuICAgICAgICAoaWRiUHJveHlhYmxlVHlwZXMgPSBbXG4gICAgICAgICAgICBJREJEYXRhYmFzZSxcbiAgICAgICAgICAgIElEQk9iamVjdFN0b3JlLFxuICAgICAgICAgICAgSURCSW5kZXgsXG4gICAgICAgICAgICBJREJDdXJzb3IsXG4gICAgICAgICAgICBJREJUcmFuc2FjdGlvbixcbiAgICAgICAgXSkpO1xufVxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpIHtcbiAgICByZXR1cm4gKGN1cnNvckFkdmFuY2VNZXRob2RzIHx8XG4gICAgICAgIChjdXJzb3JBZHZhbmNlTWV0aG9kcyA9IFtcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuYWR2YW5jZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWUsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlUHJpbWFyeUtleSxcbiAgICAgICAgXSkpO1xufVxuY29uc3QgY3Vyc29yUmVxdWVzdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2FjdGlvbkRvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcChyZXF1ZXN0LnJlc3VsdCkpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICBwcm9taXNlXG4gICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBTaW5jZSBjdXJzb3JpbmcgcmV1c2VzIHRoZSBJREJSZXF1ZXN0ICgqc2lnaCopLCB3ZSBjYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gICAgICAgIC8vIChzZWUgd3JhcEZ1bmN0aW9uKS5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCQ3Vyc29yKSB7XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0TWFwLnNldCh2YWx1ZSwgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2F0Y2hpbmcgdG8gYXZvaWQgXCJVbmNhdWdodCBQcm9taXNlIGV4Y2VwdGlvbnNcIlxuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIC8vIFRoaXMgbWFwcGluZyBleGlzdHMgaW4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGJ1dCBkb2Vzbid0IGRvZXNuJ3QgZXhpc3QgaW4gdHJhbnNmb3JtQ2FjaGUuIFRoaXNcbiAgICAvLyBpcyBiZWNhdXNlIHdlIGNyZWF0ZSBtYW55IHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdC5cbiAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KHByb21pc2UsIHJlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uKHR4KSB7XG4gICAgLy8gRWFybHkgYmFpbCBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgYSBkb25lIHByb21pc2UgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgaWYgKHRyYW5zYWN0aW9uRG9uZU1hcC5oYXModHgpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZG9uZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QodHguZXJyb3IgfHwgbmV3IERPTUV4Y2VwdGlvbignQWJvcnRFcnJvcicsICdBYm9ydEVycm9yJykpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICB9KTtcbiAgICAvLyBDYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAgIHRyYW5zYWN0aW9uRG9uZU1hcC5zZXQodHgsIGRvbmUpO1xufVxubGV0IGlkYlByb3h5VHJhcHMgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0cmFuc2FjdGlvbi5kb25lLlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkb25lJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Eb25lTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgLy8gUG9seWZpbGwgZm9yIG9iamVjdFN0b3JlTmFtZXMgYmVjYXVzZSBvZiBFZGdlLlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdvYmplY3RTdG9yZU5hbWVzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQub2JqZWN0U3RvcmVOYW1lcyB8fCB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiByZWNlaXZlci5vYmplY3RTdG9yZShyZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHRyYW5zZm9ybSB3aGF0ZXZlciB3ZSBnZXQgYmFjay5cbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0W3Byb3BdKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAocHJvcCA9PT0gJ2RvbmUnIHx8IHByb3AgPT09ICdzdG9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZXBsYWNlVHJhcHMoY2FsbGJhY2spIHtcbiAgICBpZGJQcm94eVRyYXBzID0gY2FsbGJhY2soaWRiUHJveHlUcmFwcyk7XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24oZnVuYykge1xuICAgIC8vIER1ZSB0byBleHBlY3RlZCBvYmplY3QgZXF1YWxpdHkgKHdoaWNoIGlzIGVuZm9yY2VkIGJ5IHRoZSBjYWNoaW5nIGluIGB3cmFwYCksIHdlXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxuICAgIC8vIEVkZ2UgZG9lc24ndCBzdXBwb3J0IG9iamVjdFN0b3JlTmFtZXMgKGJvb28pLCBzbyB3ZSBwb2x5ZmlsbCBpdCBoZXJlLlxuICAgIGlmIChmdW5jID09PSBJREJEYXRhYmFzZS5wcm90b3R5cGUudHJhbnNhY3Rpb24gJiZcbiAgICAgICAgISgnb2JqZWN0U3RvcmVOYW1lcycgaW4gSURCVHJhbnNhY3Rpb24ucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0b3JlTmFtZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gZnVuYy5jYWxsKHVud3JhcCh0aGlzKSwgc3RvcmVOYW1lcywgLi4uYXJncyk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuc2V0KHR4LCBzdG9yZU5hbWVzLnNvcnQgPyBzdG9yZU5hbWVzLnNvcnQoKSA6IFtzdG9yZU5hbWVzXSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0eCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEN1cnNvciBtZXRob2RzIGFyZSBzcGVjaWFsLCBhcyB0aGUgYmVoYXZpb3VyIGlzIGEgbGl0dGxlIG1vcmUgZGlmZmVyZW50IHRvIHN0YW5kYXJkIElEQi4gSW5cbiAgICAvLyBJREIsIHlvdSBhZHZhbmNlIHRoZSBjdXJzb3IgYW5kIHdhaXQgZm9yIGEgbmV3ICdzdWNjZXNzJyBvbiB0aGUgSURCUmVxdWVzdCB0aGF0IGdhdmUgeW91IHRoZVxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gd2l0aCByZWFsIHByb21pc2VzLCBzbyBlYWNoIGFkdmFuY2UgbWV0aG9kcyByZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSBjdXJzb3Igb2JqZWN0LCBvclxuICAgIC8vIHVuZGVmaW5lZCBpZiB0aGUgZW5kIG9mIHRoZSBjdXJzb3IgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcChjdXJzb3JSZXF1ZXN0TWFwLmdldCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIHJldHVybiB3cmFwKGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgcmV0dXJuLCBpdCBqdXN0IGNyZWF0ZXMgYSAnZG9uZScgcHJvbWlzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLFxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pXG4gICAgICAgIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLCBpZGJQcm94eVRyYXBzKTtcbiAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFjayBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gdHJhbnNmb3JtIGl0LlxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcbiAgICAvLyBJREIgaXMgd2VpcmQgYW5kIGEgc2luZ2xlIElEQlJlcXVlc3QgY2FuIHlpZWxkIG1hbnkgcmVzcG9uc2VzLCBzbyB0aGVzZSBjYW4ndCBiZSBjYWNoZWQuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgdHJhbnNmb3JtZWQgdGhpcyB2YWx1ZSBiZWZvcmUsIHJldXNlIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGZhc3RlciwgYnV0IGl0IGFsc28gcHJvdmlkZXMgb2JqZWN0IGVxdWFsaXR5LlxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpO1xuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxuICAgIC8vIFRoZXNlIG1heSBiZSBwcmltaXRpdmUgdHlwZXMsIHNvIHRoZXkgY2FuJ3QgYmUgV2Vha01hcCBrZXlzLlxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQobmV3VmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuY29uc3QgdW53cmFwID0gKHZhbHVlKSA9PiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcblxuZXhwb3J0IHsgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGFzIGEsIGluc3RhbmNlT2ZBbnkgYXMgaSwgcmVwbGFjZVRyYXBzIGFzIHIsIHVud3JhcCBhcyB1LCB3cmFwIGFzIHcgfTtcbiJdLCJuYW1lcyI6WyJpbnN0YW5jZU9mQW55Iiwib2JqZWN0IiwiY29uc3RydWN0b3JzIiwic29tZSIsImMiLCJpZGJQcm94eWFibGVUeXBlcyIsImN1cnNvckFkdmFuY2VNZXRob2RzIiwiZ2V0SWRiUHJveHlhYmxlVHlwZXMiLCJJREJEYXRhYmFzZSIsIklEQk9iamVjdFN0b3JlIiwiSURCSW5kZXgiLCJJREJDdXJzb3IiLCJJREJUcmFuc2FjdGlvbiIsImdldEN1cnNvckFkdmFuY2VNZXRob2RzIiwicHJvdG90eXBlIiwiYWR2YW5jZSIsImNvbnRpbnVlUHJpbWFyeUtleSIsImN1cnNvclJlcXVlc3RNYXAiLCJXZWFrTWFwIiwidHJhbnNhY3Rpb25Eb25lTWFwIiwidHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwIiwidHJhbnNmb3JtQ2FjaGUiLCJyZXZlcnNlVHJhbnNmb3JtQ2FjaGUiLCJwcm9taXNpZnlSZXF1ZXN0IiwicmVxdWVzdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInVubGlzdGVuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN1Y2Nlc3MiLCJlcnJvciIsIndyYXAiLCJyZXN1bHQiLCJhZGRFdmVudExpc3RlbmVyIiwidGhlbiIsInZhbHVlIiwic2V0IiwiY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uIiwidHgiLCJoYXMiLCJkb25lIiwiY29tcGxldGUiLCJET01FeGNlcHRpb24iLCJpZGJQcm94eVRyYXBzIiwiZ2V0IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwib2JqZWN0U3RvcmVOYW1lcyIsInVuZGVmaW5lZCIsIm9iamVjdFN0b3JlIiwicmVwbGFjZVRyYXBzIiwiY2FsbGJhY2siLCJ3cmFwRnVuY3Rpb24iLCJmdW5jIiwidHJhbnNhY3Rpb24iLCJzdG9yZU5hbWVzIiwiYXJncyIsImNhbGwiLCJ1bndyYXAiLCJzb3J0IiwiaW5jbHVkZXMiLCJhcHBseSIsInRyYW5zZm9ybUNhY2hhYmxlVmFsdWUiLCJQcm94eSIsIklEQlJlcXVlc3QiLCJuZXdWYWx1ZSIsImEiLCJpIiwiciIsInUiLCJ3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/idb/build/wrap-idb-value.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;